#
# This file is generated using Tools/generate-helpers-vector.py
#
#    ** DO NOT EDIT **
#
from PyObjCTools.TestSupport import TestCase, min_os_level
import objc
from functools import partial
from objc import simd

# Tests use CGColorRef and CGColorSpaceRef. Try to import Quartz
# to get proper definitions for these types, otherwise fall back
# to minimal definitions (those aren't 100% correct, but good enough
# for these tests)
try:
    import Quartz  # noqa: F401
except ImportError:
    CGColorRef = objc.registerCFSignature("CGColorRef", b"^{CGColor=}", 0)
    CGColorSpaceRef = objc.registerCFSignature(
        "CGColorSpaceRef", b"^{CGColorSpace=}", 0
    )

from .vectorcall import OC_VectorCall, OC_VectorCallInvoke


class NoObjCClass:
    @property
    def __pyobjc_object__(self):
        raise TypeError("Cannot proxy")


class NoBool:
    def __bool__(self):
        raise TypeError("no valid in boolean context")


NoObjCValueObject = NoObjCClass()

# Register full signatures for the helper methods

objc.registerMetaDataForSelector(b"NSObject", b"v16C", {"full_signature": b"<16C>@:"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv16C", {"full_signature": b"<16C>@:"}
)
objc.registerMetaDataForSelector(b"NSObject", b"v2d", {"full_signature": b"<2d>@:"})
objc.registerMetaDataForSelector(b"NSObject", b"clsv2d", {"full_signature": b"<2d>@:"})
objc.registerMetaDataForSelector(b"NSObject", b"v2dd:", {"full_signature": b"<2d>@:d"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv2dd:", {"full_signature": b"<2d>@:d"}
)
objc.registerMetaDataForSelector(b"NSObject", b"v2f", {"full_signature": b"<2f>@:"})
objc.registerMetaDataForSelector(b"NSObject", b"clsv2f", {"full_signature": b"<2f>@:"})
objc.registerMetaDataForSelector(b"NSObject", b"v2fQ:", {"full_signature": b"<2f>@:Q"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv2fQ:", {"full_signature": b"<2f>@:Q"}
)
objc.registerMetaDataForSelector(b"NSObject", b"v2fd:", {"full_signature": b"<2f>@:d"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv2fd:", {"full_signature": b"<2f>@:d"}
)
objc.registerMetaDataForSelector(b"NSObject", b"v2fq:", {"full_signature": b"<2f>@:q"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv2fq:", {"full_signature": b"<2f>@:q"}
)
objc.registerMetaDataForSelector(b"NSObject", b"v2i", {"full_signature": b"<2i>@:"})
objc.registerMetaDataForSelector(b"NSObject", b"clsv2i", {"full_signature": b"<2i>@:"})
objc.registerMetaDataForSelector(b"NSObject", b"v3dd:", {"full_signature": b"<3d>@:d"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv3dd:", {"full_signature": b"<3d>@:d"}
)
objc.registerMetaDataForSelector(b"NSObject", b"v3f", {"full_signature": b"<3f>@:"})
objc.registerMetaDataForSelector(b"NSObject", b"clsv3f", {"full_signature": b"<3f>@:"})
objc.registerMetaDataForSelector(
    b"NSObject", b"v3fv2i:v2i:", {"full_signature": b"<3f>@:<2i><2i>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv3fv2i:v2i:", {"full_signature": b"<3f>@:<2i><2i>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"v3fv3f:", {"full_signature": b"<3f>@:<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv3fv3f:", {"full_signature": b"<3f>@:<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"v3fv3f:id:", {"full_signature": b"<3f>@:<3f>@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv3fv3f:id:", {"full_signature": b"<3f>@:<3f>@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"v3fv4i:", {"full_signature": b"<3f>@:<4i>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv3fv4i:", {"full_signature": b"<3f>@:<4i>"}
)
objc.registerMetaDataForSelector(b"NSObject", b"v3fQ:", {"full_signature": b"<3f>@:Q"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv3fQ:", {"full_signature": b"<3f>@:Q"}
)
objc.registerMetaDataForSelector(b"NSObject", b"v3fd:", {"full_signature": b"<3f>@:d"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv3fd:", {"full_signature": b"<3f>@:d"}
)
objc.registerMetaDataForSelector(b"NSObject", b"v4dd:", {"full_signature": b"<4d>@:d"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv4dd:", {"full_signature": b"<4d>@:d"}
)
objc.registerMetaDataForSelector(b"NSObject", b"v4f", {"full_signature": b"<4f>@:"})
objc.registerMetaDataForSelector(b"NSObject", b"clsv4f", {"full_signature": b"<4f>@:"})
objc.registerMetaDataForSelector(b"NSObject", b"v4fd:", {"full_signature": b"<4f>@:d"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv4fd:", {"full_signature": b"<4f>@:d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"v4iv3f:", {"full_signature": b"<4i>@:<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsv4iv3f:", {"full_signature": b"<4i>@:<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv2d:id:", {"full_signature": b"@@:<2d>@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv2d:id:", {"full_signature": b"@@:<2d>@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv2d:q:", {"full_signature": b"@@:<2d>q"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv2d:q:", {"full_signature": b"@@:<2d>q"}
)
objc.registerMetaDataForSelector(b"NSObject", b"idv2f:", {"full_signature": b"@@:<2f>"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv2f:", {"full_signature": b"@@:<2f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv2f:v2I:q:id:", {"full_signature": b"@@:<2f><2I>q@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv2f:v2I:q:id:", {"full_signature": b"@@:<2f><2I>q@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv2f:v2f:", {"full_signature": b"@@:<2f><2f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv2f:v2f:", {"full_signature": b"@@:<2f><2f>"}
)
objc.registerMetaDataForSelector(b"NSObject", b"idv2i:", {"full_signature": b"@@:<2i>"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv2i:", {"full_signature": b"@@:<2i>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv2i:i:i:Z:", {"full_signature": b"@@:<2i>iiZ"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv2i:i:i:Z:", {"full_signature": b"@@:<2i>iiZ"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv2i:i:i:Z:Class:", {"full_signature": b"@@:<2i>iiZ#"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv2i:i:i:Z:Class:", {"full_signature": b"@@:<2i>iiZ#"}
)
objc.registerMetaDataForSelector(b"NSObject", b"idv3f:", {"full_signature": b"@@:<3f>"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv3f:", {"full_signature": b"@@:<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv3f:v2I:Z:Z:Z:q:id:", {"full_signature": b"@@:<3f><2I>ZZZq@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv3f:v2I:Z:Z:Z:q:id:", {"full_signature": b"@@:<3f><2I>ZZZq@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv3f:v2I:Z:Z:q:id:", {"full_signature": b"@@:<3f><2I>ZZq@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv3f:v2I:Z:Z:q:id:", {"full_signature": b"@@:<3f><2I>ZZq@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv3f:v2I:Z:q:id:", {"full_signature": b"@@:<3f><2I>Zq@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv3f:v2I:Z:q:id:", {"full_signature": b"@@:<3f><2I>Zq@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv3f:v2I:i:Z:q:id:", {"full_signature": b"@@:<3f><2I>iZq@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv3f:v2I:i:Z:q:id:", {"full_signature": b"@@:<3f><2I>iZq@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv3f:v2I:q:id:", {"full_signature": b"@@:<3f><2I>q@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv3f:v2I:q:id:", {"full_signature": b"@@:<3f><2I>q@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv3f:v3I:Z:q:id:", {"full_signature": b"@@:<3f><3I>Zq@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv3f:v3I:Z:q:id:", {"full_signature": b"@@:<3f><3I>Zq@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv3f:v3I:q:Z:id:", {"full_signature": b"@@:<3f><3I>qZ@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv3f:v3I:q:Z:id:", {"full_signature": b"@@:<3f><3I>qZ@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv3f:Q:Q:q:Z:Z:id:", {"full_signature": b"@@:<3f>QQqZZ@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv3f:Q:Q:q:Z:Z:id:", {"full_signature": b"@@:<3f>QQqZZ@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idv3f:Z:q:id:", {"full_signature": b"@@:<3f>Zq@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv3f:Z:q:id:", {"full_signature": b"@@:<3f>Zq@"}
)
objc.registerMetaDataForSelector(b"NSObject", b"idv4f:", {"full_signature": b"@@:<4f>"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidv4f:", {"full_signature": b"@@:<4f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:v2d:v2d:v2i:Z:", {"full_signature": b"@@:@<2d><2d><2i>Z"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:v2d:v2d:v2i:Z:", {"full_signature": b"@@:@<2d><2d><2i>Z"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:v2f:", {"full_signature": b"@@:@<2f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:v2f:", {"full_signature": b"@@:@<2f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:v3f:", {"full_signature": b"@@:@<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:v3f:", {"full_signature": b"@@:@<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:v4f:", {"full_signature": b"@@:@<4f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:v4f:", {"full_signature": b"@@:@<4f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:id:v2i:", {"full_signature": b"@@:@@<2i>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:id:v2i:", {"full_signature": b"@@:@@<2i>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:id:v2i:f:", {"full_signature": b"@@:@@<2i>f"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:id:v2i:f:", {"full_signature": b"@@:@@<2i>f"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:Q:v2f:", {"full_signature": b"@@:@Q<2f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:Q:v2f:", {"full_signature": b"@@:@Q<2f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:Q:v3f:", {"full_signature": b"@@:@Q<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:Q:v3f:", {"full_signature": b"@@:@Q<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:Q:v4f:", {"full_signature": b"@@:@Q<4f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:Q:v4f:", {"full_signature": b"@@:@Q<4f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"idid:Q:simdfloat4x4:",
    {"full_signature": b"@@:@Q{simd_float4x4=[4<4f>]}"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsidid:Q:simdfloat4x4:",
    {"full_signature": b"@@:@Q{simd_float4x4=[4<4f>]}"},
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:Z:id:v2i:q:Q:q:Z:", {"full_signature": b"@@:@Z@<2i>qQqZ"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:Z:id:v2i:q:Q:q:Z:", {"full_signature": b"@@:@Z@<2i>qQqZ"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:q:v2i:f:f:f:f:", {"full_signature": b"@@:@q<2i>ffff"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:q:v2i:f:f:f:f:", {"full_signature": b"@@:@q<2i>ffff"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:q:v2i:f:f:f:f:f:", {"full_signature": b"@@:@q<2i>fffff"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:q:v2i:f:f:f:f:f:", {"full_signature": b"@@:@q<2i>fffff"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:GKBox:", {"full_signature": b"@@:@{GKBox=<3f><3f>}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:GKBox:", {"full_signature": b"@@:@{GKBox=<3f><3f>}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:GKQuad:", {"full_signature": b"@@:@{GKQuad=<2f><2f>}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:GKQuad:", {"full_signature": b"@@:@{GKQuad=<2f><2f>}"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"idid:MDLAxisAlignedBoundingBox:f:",
    {"full_signature": b"@@:@{MDLAxisAlignedBoundingBox=<3f><3f>}f"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsidid:MDLAxisAlignedBoundingBox:f:",
    {"full_signature": b"@@:@{MDLAxisAlignedBoundingBox=<3f><3f>}f"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"idid:simdfloat2x2:",
    {"full_signature": b"@@:@{simd_float2x2=[2<2f>]}"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsidid:simdfloat2x2:",
    {"full_signature": b"@@:@{simd_float2x2=[2<2f>]}"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"idid:simdfloat3x3:",
    {"full_signature": b"@@:@{simd_float3x3=[3<3f>]}"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsidid:simdfloat3x3:",
    {"full_signature": b"@@:@{simd_float3x3=[3<3f>]}"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"idid:simdfloat4x4:",
    {"full_signature": b"@@:@{simd_float4x4=[4<4f>]}"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsidid:simdfloat4x4:",
    {"full_signature": b"@@:@{simd_float4x4=[4<4f>]}"},
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:simdquatf:", {"full_signature": b"@@:@{simd_quatf=<4f>}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:simdquatf:", {"full_signature": b"@@:@{simd_quatf=<4f>}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idid:simdquatf:id:", {"full_signature": b"@@:@{simd_quatf=<4f>}@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidid:simdquatf:id:", {"full_signature": b"@@:@{simd_quatf=<4f>}@"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"idCGColor:CGColor:id:v2i:",
    {"full_signature": b"@@:^{CGColor=}^{CGColor=}@<2i>"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsidCGColor:CGColor:id:v2i:",
    {"full_signature": b"@@:^{CGColor=}^{CGColor=}@<2i>"},
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idf:v2f:v2f:", {"full_signature": b"@@:f<2f><2f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidf:v2f:v2f:", {"full_signature": b"@@:f<2f><2f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idf:v2f:v2f:Class:", {"full_signature": b"@@:f<2f><2f>#"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidf:v2f:v2f:Class:", {"full_signature": b"@@:f<2f><2f>#"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idf:v2f:Q:Q:Q:q:Z:id:", {"full_signature": b"@@:f<2f>QQQqZ@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidf:v2f:Q:Q:Q:q:Z:id:", {"full_signature": b"@@:f<2f>QQQqZ@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idf:v2f:Q:Q:q:Z:id:", {"full_signature": b"@@:f<2f>QQqZ@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidf:v2f:Q:Q:q:Z:id:", {"full_signature": b"@@:f<2f>QQqZ@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idf:id:v2i:i:q:Z:", {"full_signature": b"@@:f@<2i>iqZ"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidf:id:v2i:i:q:Z:", {"full_signature": b"@@:f@<2i>iqZ"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"idf:id:v2i:i:q:CGColor:CGColor:",
    {"full_signature": b"@@:f@<2i>iq^{CGColor=}^{CGColor=}"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsidf:id:v2i:i:q:CGColor:CGColor:",
    {"full_signature": b"@@:f@<2i>iq^{CGColor=}^{CGColor=}"},
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idf:id:v2i:q:", {"full_signature": b"@@:f@<2i>q"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidf:id:v2i:q:", {"full_signature": b"@@:f@<2i>q"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idf:f:id:v2i:", {"full_signature": b"@@:ff@<2i>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidf:f:id:v2i:", {"full_signature": b"@@:ff@<2i>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idGKBox:", {"full_signature": b"@@:{GKBox=<3f><3f>}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidGKBox:", {"full_signature": b"@@:{GKBox=<3f><3f>}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idGKBox:f:", {"full_signature": b"@@:{GKBox=<3f><3f>}f"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidGKBox:f:", {"full_signature": b"@@:{GKBox=<3f><3f>}f"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idGKQuad:", {"full_signature": b"@@:{GKQuad=<2f><2f>}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidGKQuad:", {"full_signature": b"@@:{GKQuad=<2f><2f>}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idGKQuad:f:", {"full_signature": b"@@:{GKQuad=<2f><2f>}f"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsidGKQuad:f:", {"full_signature": b"@@:{GKQuad=<2f><2f>}f"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"idMDLVoxelIndexExtent:",
    {"full_signature": b"@@:{MDLVoxelIndexExtent=<4i><4i>}"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsidMDLVoxelIndexExtent:",
    {"full_signature": b"@@:{MDLVoxelIndexExtent=<4i><4i>}"},
)
objc.registerMetaDataForSelector(
    b"NSObject", b"idsimdfloat4x4:", {"full_signature": b"@@:{simd_float4x4=[4<4f>]}"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsidsimdfloat4x4:",
    {"full_signature": b"@@:{simd_float4x4=[4<4f>]}"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"idsimdfloat4x4:Z:",
    {"full_signature": b"@@:{simd_float4x4=[4<4f>]}Z"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsidsimdfloat4x4:Z:",
    {"full_signature": b"@@:{simd_float4x4=[4<4f>]}Z"},
)
objc.registerMetaDataForSelector(
    b"NSObject", b"Zv2i:id:id:id:id:", {"full_signature": b"Z@:<2i>@@@@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsZv2i:id:id:id:id:", {"full_signature": b"Z@:<2i>@@@@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"Zv2i:q:f:id:id:id:", {"full_signature": b"Z@:<2i>qf@@@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsZv2i:q:f:id:id:id:", {"full_signature": b"Z@:<2i>qf@@@"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"Zv4i:Z:Z:Z:Z:", {"full_signature": b"Z@:<4i>ZZZZ"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsZv4i:Z:Z:Z:Z:", {"full_signature": b"Z@:<4i>ZZZZ"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"CGColorv3f:", {"full_signature": b"^{CGColor=}@:<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsCGColorv3f:", {"full_signature": b"^{CGColor=}@:<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"CGColorv3f:CGColorSpace:",
    {"full_signature": b"^{CGColor=}@:<3f>^{CGColorSpace=}"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsCGColorv3f:CGColorSpace:",
    {"full_signature": b"^{CGColor=}@:<3f>^{CGColorSpace=}"},
)
objc.registerMetaDataForSelector(b"NSObject", b"fv2f:", {"full_signature": b"f@:<2f>"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsfv2f:", {"full_signature": b"f@:<2f>"}
)
objc.registerMetaDataForSelector(b"NSObject", b"fv2i:", {"full_signature": b"f@:<2i>"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsfv2i:", {"full_signature": b"f@:<2i>"}
)
objc.registerMetaDataForSelector(b"NSObject", b"vv2d:", {"full_signature": b"v@:<2d>"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv2d:", {"full_signature": b"v@:<2d>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vv2d:d:", {"full_signature": b"v@:<2d>d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv2d:d:", {"full_signature": b"v@:<2d>d"}
)
objc.registerMetaDataForSelector(b"NSObject", b"vv2f:", {"full_signature": b"v@:<2f>"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv2f:", {"full_signature": b"v@:<2f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vv2f:d:", {"full_signature": b"v@:<2f>d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv2f:d:", {"full_signature": b"v@:<2f>d"}
)
objc.registerMetaDataForSelector(b"NSObject", b"vv3d:", {"full_signature": b"v@:<3d>"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv3d:", {"full_signature": b"v@:<3d>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vv3d:d:", {"full_signature": b"v@:<3d>d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv3d:d:", {"full_signature": b"v@:<3d>d"}
)
objc.registerMetaDataForSelector(b"NSObject", b"vv3f:", {"full_signature": b"v@:<3f>"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv3f:", {"full_signature": b"v@:<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vv3f:v3f:", {"full_signature": b"v@:<3f><3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv3f:v3f:", {"full_signature": b"v@:<3f><3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vv3f:v3f:v3f:", {"full_signature": b"v@:<3f><3f><3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv3f:v3f:v3f:", {"full_signature": b"v@:<3f><3f><3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vv3f:d:", {"full_signature": b"v@:<3f>d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv3f:d:", {"full_signature": b"v@:<3f>d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vv4d:d:", {"full_signature": b"v@:<4d>d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv4d:d:", {"full_signature": b"v@:<4d>d"}
)
objc.registerMetaDataForSelector(b"NSObject", b"vv4f:", {"full_signature": b"v@:<4f>"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv4f:", {"full_signature": b"v@:<4f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vv4f:d:", {"full_signature": b"v@:<4f>d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv4f:d:", {"full_signature": b"v@:<4f>d"}
)
objc.registerMetaDataForSelector(b"NSObject", b"vv4i:", {"full_signature": b"v@:<4i>"})
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvv4i:", {"full_signature": b"v@:<4i>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vid:v2f:v2f:", {"full_signature": b"v@:@<2f><2f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvid:v2f:v2f:", {"full_signature": b"v@:@<2f><2f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vid:v2f:v2f:q:", {"full_signature": b"v@:@<2f><2f>q"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvid:v2f:v2f:q:", {"full_signature": b"v@:@<2f><2f>q"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vf:v2i:", {"full_signature": b"v@:f<2i>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvf:v2i:", {"full_signature": b"v@:f<2i>"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"vMDLAxisAlignedBoundingBox:",
    {"full_signature": b"v@:{MDLAxisAlignedBoundingBox=<3f><3f>}"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsvMDLAxisAlignedBoundingBox:",
    {"full_signature": b"v@:{MDLAxisAlignedBoundingBox=<3f><3f>}"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"vMDLAxisAlignedBoundingBox:Z:",
    {"full_signature": b"v@:{MDLAxisAlignedBoundingBox=<3f><3f>}Z"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsvMDLAxisAlignedBoundingBox:Z:",
    {"full_signature": b"v@:{MDLAxisAlignedBoundingBox=<3f><3f>}Z"},
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vsimddouble4x4:", {"full_signature": b"v@:{simd_double4x4=[4<4d>]}"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsvsimddouble4x4:",
    {"full_signature": b"v@:{simd_double4x4=[4<4d>]}"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"vsimddouble4x4:d:",
    {"full_signature": b"v@:{simd_double4x4=[4<4d>]}d"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsvsimddouble4x4:d:",
    {"full_signature": b"v@:{simd_double4x4=[4<4d>]}d"},
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vsimdfloat2x2:", {"full_signature": b"v@:{simd_float2x2=[2<2f>]}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvsimdfloat2x2:", {"full_signature": b"v@:{simd_float2x2=[2<2f>]}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vsimdfloat3x3:", {"full_signature": b"v@:{simd_float3x3=[3<3f>]}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvsimdfloat3x3:", {"full_signature": b"v@:{simd_float3x3=[3<3f>]}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vsimdfloat4x4:", {"full_signature": b"v@:{simd_float4x4=[4<4f>]}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvsimdfloat4x4:", {"full_signature": b"v@:{simd_float4x4=[4<4f>]}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vsimdfloat4x4:d:", {"full_signature": b"v@:{simd_float4x4=[4<4f>]}d"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsvsimdfloat4x4:d:",
    {"full_signature": b"v@:{simd_float4x4=[4<4f>]}d"},
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vsimdquatd:d:", {"full_signature": b"v@:{simd_quatd=<4d>}d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvsimdquatd:d:", {"full_signature": b"v@:{simd_quatd=<4d>}d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vsimdquatf:", {"full_signature": b"v@:{simd_quatf=<4f>}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvsimdquatf:", {"full_signature": b"v@:{simd_quatf=<4f>}"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vsimdquatf:v3f:", {"full_signature": b"v@:{simd_quatf=<4f>}<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvsimdquatf:v3f:", {"full_signature": b"v@:{simd_quatf=<4f>}<3f>"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"vsimdquatf:d:", {"full_signature": b"v@:{simd_quatf=<4f>}d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsvsimdquatf:d:", {"full_signature": b"v@:{simd_quatf=<4f>}d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"GKBox", {"full_signature": b"{GKBox=<3f><3f>}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsGKBox", {"full_signature": b"{GKBox=<3f><3f>}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"GKQuad", {"full_signature": b"{GKQuad=<2f><2f>}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsGKQuad", {"full_signature": b"{GKQuad=<2f><2f>}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"GKTriangleQ:", {"full_signature": b"{GKTriangle=[3<3f>]}@:Q"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clsGKTriangleQ:", {"full_signature": b"{GKTriangle=[3<3f>]}@:Q"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"MDLAxisAlignedBoundingBox",
    {"full_signature": b"{MDLAxisAlignedBoundingBox=<3f><3f>}@:"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsMDLAxisAlignedBoundingBox",
    {"full_signature": b"{MDLAxisAlignedBoundingBox=<3f><3f>}@:"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"MDLAxisAlignedBoundingBoxv4i:",
    {"full_signature": b"{MDLAxisAlignedBoundingBox=<3f><3f>}@:<4i>"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsMDLAxisAlignedBoundingBoxv4i:",
    {"full_signature": b"{MDLAxisAlignedBoundingBox=<3f><3f>}@:<4i>"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"MDLAxisAlignedBoundingBoxd:",
    {"full_signature": b"{MDLAxisAlignedBoundingBox=<3f><3f>}@:d"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsMDLAxisAlignedBoundingBoxd:",
    {"full_signature": b"{MDLAxisAlignedBoundingBox=<3f><3f>}@:d"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"MDLVoxelIndexExtent",
    {"full_signature": b"{MDLVoxelIndexExtent=<4i><4i>}@:"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsMDLVoxelIndexExtent",
    {"full_signature": b"{MDLVoxelIndexExtent=<4i><4i>}@:"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"MPSImageHistogramInfo",
    {"full_signature": b"{MPSImageHistogramInfo=QZ<4f><4f>}@:"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsMPSImageHistogramInfo",
    {"full_signature": b"{MPSImageHistogramInfo=QZ<4f><4f>}@:"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"MPSAxisAlignedBoundingBox",
    {"full_signature": b"{_MPSAxisAlignedBoundingBox=<3f><3f>}@:"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clsMPSAxisAlignedBoundingBox",
    {"full_signature": b"{_MPSAxisAlignedBoundingBox=<3f><3f>}@:"},
)
objc.registerMetaDataForSelector(
    b"NSObject", b"simddouble4x4", {"full_signature": b"{simd_double4x4=[4<4d>]}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clssimddouble4x4", {"full_signature": b"{simd_double4x4=[4<4d>]}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"simddouble4x4d:", {"full_signature": b"{simd_double4x4=[4<4d>]}@:d"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clssimddouble4x4d:",
    {"full_signature": b"{simd_double4x4=[4<4d>]}@:d"},
)
objc.registerMetaDataForSelector(
    b"NSObject", b"simdfloat2x2", {"full_signature": b"{simd_float2x2=[2<2f>]}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clssimdfloat2x2", {"full_signature": b"{simd_float2x2=[2<2f>]}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"simdfloat3x3", {"full_signature": b"{simd_float3x3=[3<3f>]}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clssimdfloat3x3", {"full_signature": b"{simd_float3x3=[3<3f>]}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"simdfloat4x3", {"full_signature": b"{simd_float4x3=[4<3f>]}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clssimdfloat4x3", {"full_signature": b"{simd_float4x3=[4<3f>]}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"simdfloat4x4", {"full_signature": b"{simd_float4x4=[4<4f>]}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clssimdfloat4x4", {"full_signature": b"{simd_float4x4=[4<4f>]}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"simdfloat4x4id:d:",
    {"full_signature": b"{simd_float4x4=[4<4f>]}@:@d"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clssimdfloat4x4id:d:",
    {"full_signature": b"{simd_float4x4=[4<4f>]}@:@d"},
)
objc.registerMetaDataForSelector(
    b"NSObject", b"simdfloat4x4d:", {"full_signature": b"{simd_float4x4=[4<4f>]}@:d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clssimdfloat4x4d:", {"full_signature": b"{simd_float4x4=[4<4f>]}@:d"}
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"simdfloat4x4simdfloat4x4:id:",
    {"full_signature": b"{simd_float4x4=[4<4f>]}@:{simd_float4x4=[4<4f>]}@"},
)
objc.registerMetaDataForSelector(
    b"NSObject",
    b"clssimdfloat4x4simdfloat4x4:id:",
    {"full_signature": b"{simd_float4x4=[4<4f>]}@:{simd_float4x4=[4<4f>]}@"},
)
objc.registerMetaDataForSelector(
    b"NSObject", b"simdquatdd:", {"full_signature": b"{simd_quatd=<4d>}@:d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clssimdquatdd:", {"full_signature": b"{simd_quatd=<4d>}@:d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"simdquatf", {"full_signature": b"{simd_quatf=<4f>}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clssimdquatf", {"full_signature": b"{simd_quatf=<4f>}@:"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"simdquatfd:", {"full_signature": b"{simd_quatf=<4f>}@:d"}
)
objc.registerMetaDataForSelector(
    b"NSObject", b"clssimdquatfd:", {"full_signature": b"{simd_quatf=<4f>}@:d"}
)


class OC_VectorCallInstance(objc.lookUpClass("NSObject")):
    def v16C(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_uchar16(
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
        )

    def v2d(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_double2(0.0, 1.5)

    def v2dd_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_double2(0.0, 1.5)

    def v2f(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float2(0.0, 1.5)

    def v2fQ_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float2(0.0, 1.5)

    def v2fd_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float2(0.0, 1.5)

    def v2fq_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float2(0.0, 1.5)

    def v2i(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_int2(0, 1)

    def v3dd_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_double3(0.0, 1.5, 3.0)

    def v3f(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    def v3fv2i_v2i_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    def v3fv3f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    def v3fv3f_id_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    def v3fv4i_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    def v3fQ_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    def v3fd_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    def v4dd_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)

    def v4f(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)

    def v4fd_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)

    def v4iv3f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_int4(0, 1, 2, 3)

    def idv2d_id_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv2d_q_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv2f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv2f_v2I_q_id_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv2f_v2f_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv2i_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv2i_i_i_Z_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv2i_i_i_Z_Class_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv3f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv3f_v2I_Z_Z_Z_q_id_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv3f_v2I_Z_Z_q_id_(self, arg0, arg1, arg2, arg3, arg4, arg5):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv3f_v2I_Z_q_id_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv3f_v2I_i_Z_q_id_(self, arg0, arg1, arg2, arg3, arg4, arg5):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv3f_v2I_q_id_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv3f_v3I_Z_q_id_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv3f_v3I_q_Z_id_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv3f_Q_Q_q_Z_Z_id_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv3f_Z_q_id_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idv4f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_v2d_v2d_v2i_Z_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_v2f_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_v3f_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_v4f_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_id_v2i_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_id_v2i_f_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_Q_v2f_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_Q_v3f_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_Q_v4f_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_Q_simdfloat4x4_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_Z_id_v2i_q_Q_q_Z_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_q_v2i_f_f_f_f_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_q_v2i_f_f_f_f_f_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    if objc.macos_available(10, 12):

        def idid_GKBox_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 12):

        def idid_GKQuad_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 11):

        def idid_MDLAxisAlignedBoundingBox_f_(self, arg0, arg1, arg2):
            self.argvalues = (
                arg0,
                arg1,
                arg2,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    def idid_simdfloat2x2_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_simdfloat3x3_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idid_simdfloat4x4_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    if objc.macos_available(10, 13):

        def idid_simdquatf_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 13):

        def idid_simdquatf_id_(self, arg0, arg1, arg2):
            self.argvalues = (
                arg0,
                arg1,
                arg2,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    def idCGColor_CGColor_id_v2i_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idf_v2f_v2f_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idf_v2f_v2f_Class_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idf_v2f_Q_Q_Q_q_Z_id_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idf_v2f_Q_Q_q_Z_id_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idf_id_v2i_i_q_Z_(self, arg0, arg1, arg2, arg3, arg4, arg5):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idf_id_v2i_i_q_CGColor_CGColor_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idf_id_v2i_q_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idf_f_id_v2i_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    if objc.macos_available(10, 12):

        def idGKBox_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 12):

        def idGKBox_f_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 12):

        def idGKQuad_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 12):

        def idGKQuad_f_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 11):

        def idMDLVoxelIndexExtent_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    def idsimdfloat4x4_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def idsimdfloat4x4_Z_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    def Zv2i_id_id_id_id_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return False

    def Zv2i_q_f_id_id_id_(self, arg0, arg1, arg2, arg3, arg4, arg5):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return False

    def Zv4i_Z_Z_Z_Z_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return False

    def CGColorv3f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "color!"

    def CGColorv3f_CGColorSpace_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "color!"

    def fv2f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return 2500000000.0

    def fv2i_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return 2500000000.0

    def vv2d_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vv2d_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vv2f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vv2f_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vv3d_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vv3d_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vv3f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vv3f_v3f_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vv3f_v3f_v3f_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vv3f_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vv4d_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vv4f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vv4f_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vv4i_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vid_v2f_v2f_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vid_v2f_v2f_q_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vf_v2i_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    if objc.macos_available(10, 11):

        def vMDLAxisAlignedBoundingBox_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()

    if objc.macos_available(10, 11):

        def vMDLAxisAlignedBoundingBox_Z_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()

    def vsimddouble4x4_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vsimddouble4x4_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vsimdfloat2x2_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vsimdfloat3x3_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vsimdfloat4x4_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    def vsimdfloat4x4_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    if objc.macos_available(10, 13):

        def vsimdquatd_d_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()

    if objc.macos_available(10, 13):

        def vsimdquatf_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()

    if objc.macos_available(10, 13):

        def vsimdquatf_v3f_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()

    if objc.macos_available(10, 13):

        def vsimdquatf_d_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()

    if objc.macos_available(10, 12):

        def GKBox(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            )

    if objc.macos_available(10, 12):

        def GKQuad(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_float2(9.0, 10.0),
                objc.simd.vector_float2(11.0, 12.0),
            )

    if objc.macos_available(10, 12):

        def GKTriangleQ_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                (
                    objc.simd.vector_float3(-18.5, -19.5, -110.5),
                    objc.simd.vector_float3(-111.5, -112.5, -113.5),
                    objc.simd.vector_float3(-17.5, 11.5, 122.5),
                ),
            )

    if objc.macos_available(10, 11):

        def MDLAxisAlignedBoundingBox(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            )

    if objc.macos_available(10, 11):

        def MDLAxisAlignedBoundingBoxv4i_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            )

    if objc.macos_available(10, 11):

        def MDLAxisAlignedBoundingBoxd_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            )

    if objc.macos_available(10, 11):

        def MDLVoxelIndexExtent(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            )

    if objc.macos_available(10, 13):

        def MPSImageHistogramInfo(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                4398046511104,
                True,
                objc.simd.vector_float4(1.0, 2.0, 3.0, 4.0),
                objc.simd.vector_float4(-1.0, -2.0, -3.0, -4.0),
            )

    if objc.macos_available(10, 14):

        def MPSAxisAlignedBoundingBox(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_float3(1.5, 2.5, 3.5),
                objc.simd.vector_float3(4.5, 5.5, 6.5),
            )

    def simddouble4x4(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_double4x4(
            (
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
            )
        )

    def simddouble4x4d_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_double4x4(
            (
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
            )
        )

    def simdfloat2x2(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float2x2(
            (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
        )

    def simdfloat3x3(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float3x3(
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )
        )

    def simdfloat4x3(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float4x3(
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )
        )

    def simdfloat4x4(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float4x4(
            (
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            )
        )

    def simdfloat4x4id_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float4x4(
            (
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            )
        )

    def simdfloat4x4d_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float4x4(
            (
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            )
        )

    def simdfloat4x4simdfloat4x4_id_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float4x4(
            (
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            )
        )

    if objc.macos_available(10, 13):

        def simdquatdd_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))

    if objc.macos_available(10, 13):

        def simdquatf(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    if objc.macos_available(10, 13):

        def simdquatfd_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))


class OC_VectorCallClass(objc.lookUpClass("NSObject")):
    @classmethod
    def v16C(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_uchar16(
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
        )

    @classmethod
    def v2d(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_double2(0.0, 1.5)

    @classmethod
    def v2dd_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_double2(0.0, 1.5)

    @classmethod
    def v2f(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float2(0.0, 1.5)

    @classmethod
    def v2fQ_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float2(0.0, 1.5)

    @classmethod
    def v2fd_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float2(0.0, 1.5)

    @classmethod
    def v2fq_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float2(0.0, 1.5)

    @classmethod
    def v2i(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_int2(0, 1)

    @classmethod
    def v3dd_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_double3(0.0, 1.5, 3.0)

    @classmethod
    def v3f(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    @classmethod
    def v3fv2i_v2i_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    @classmethod
    def v3fv3f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    @classmethod
    def v3fv3f_id_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    @classmethod
    def v3fv4i_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    @classmethod
    def v3fQ_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    @classmethod
    def v3fd_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float3(0.0, 1.5, 3.0)

    @classmethod
    def v4dd_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)

    @classmethod
    def v4f(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)

    @classmethod
    def v4fd_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)

    @classmethod
    def v4iv3f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return objc.simd.vector_int4(0, 1, 2, 3)

    @classmethod
    def idv2d_id_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv2d_q_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv2f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv2f_v2I_q_id_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv2f_v2f_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv2i_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv2i_i_i_Z_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv2i_i_i_Z_Class_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv3f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv3f_v2I_Z_Z_Z_q_id_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv3f_v2I_Z_Z_q_id_(self, arg0, arg1, arg2, arg3, arg4, arg5):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv3f_v2I_Z_q_id_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv3f_v2I_i_Z_q_id_(self, arg0, arg1, arg2, arg3, arg4, arg5):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv3f_v2I_q_id_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv3f_v3I_Z_q_id_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv3f_v3I_q_Z_id_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv3f_Q_Q_q_Z_Z_id_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv3f_Z_q_id_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idv4f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_v2d_v2d_v2i_Z_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_v2f_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_v3f_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_v4f_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_id_v2i_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_id_v2i_f_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_Q_v2f_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_Q_v3f_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_Q_v4f_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_Q_simdfloat4x4_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_Z_id_v2i_q_Q_q_Z_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_q_v2i_f_f_f_f_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_q_v2i_f_f_f_f_f_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    if objc.macos_available(10, 12):

        @classmethod
        def idid_GKBox_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 12):

        @classmethod
        def idid_GKQuad_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 11):

        @classmethod
        def idid_MDLAxisAlignedBoundingBox_f_(self, arg0, arg1, arg2):
            self.argvalues = (
                arg0,
                arg1,
                arg2,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    @classmethod
    def idid_simdfloat2x2_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_simdfloat3x3_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idid_simdfloat4x4_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    if objc.macos_available(10, 13):

        @classmethod
        def idid_simdquatf_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 13):

        @classmethod
        def idid_simdquatf_id_(self, arg0, arg1, arg2):
            self.argvalues = (
                arg0,
                arg1,
                arg2,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    @classmethod
    def idCGColor_CGColor_id_v2i_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idf_v2f_v2f_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idf_v2f_v2f_Class_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idf_v2f_Q_Q_Q_q_Z_id_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idf_v2f_Q_Q_q_Z_id_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idf_id_v2i_i_q_Z_(self, arg0, arg1, arg2, arg3, arg4, arg5):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idf_id_v2i_i_q_CGColor_CGColor_(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idf_id_v2i_q_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idf_f_id_v2i_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    if objc.macos_available(10, 12):

        @classmethod
        def idGKBox_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 12):

        @classmethod
        def idGKBox_f_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 12):

        @classmethod
        def idGKQuad_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 12):

        @classmethod
        def idGKQuad_f_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    if objc.macos_available(10, 11):

        @classmethod
        def idMDLVoxelIndexExtent_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return "hello"

    @classmethod
    def idsimdfloat4x4_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def idsimdfloat4x4_Z_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "hello"

    @classmethod
    def Zv2i_id_id_id_id_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return False

    @classmethod
    def Zv2i_q_f_id_id_id_(self, arg0, arg1, arg2, arg3, arg4, arg5):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return False

    @classmethod
    def Zv4i_Z_Z_Z_Z_(self, arg0, arg1, arg2, arg3, arg4):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return False

    @classmethod
    def CGColorv3f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "color!"

    @classmethod
    def CGColorv3f_CGColorSpace_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return "color!"

    @classmethod
    def fv2f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return 2500000000.0

    @classmethod
    def fv2i_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return 2500000000.0

    @classmethod
    def vv2d_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vv2d_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vv2f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vv2f_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vv3d_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vv3d_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vv3f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vv3f_v3f_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vv3f_v3f_v3f_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vv3f_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vv4d_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vv4f_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vv4f_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vv4i_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vid_v2f_v2f_(self, arg0, arg1, arg2):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vid_v2f_v2f_q_(self, arg0, arg1, arg2, arg3):
        self.argvalues = (
            arg0,
            arg1,
            arg2,
            arg3,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vf_v2i_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    if objc.macos_available(10, 11):

        @classmethod
        def vMDLAxisAlignedBoundingBox_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()

    if objc.macos_available(10, 11):

        @classmethod
        def vMDLAxisAlignedBoundingBox_Z_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()

    @classmethod
    def vsimddouble4x4_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vsimddouble4x4_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vsimdfloat2x2_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vsimdfloat3x3_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vsimdfloat4x4_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    @classmethod
    def vsimdfloat4x4_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()

    if objc.macos_available(10, 13):

        @classmethod
        def vsimdquatd_d_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()

    if objc.macos_available(10, 13):

        @classmethod
        def vsimdquatf_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()

    if objc.macos_available(10, 13):

        @classmethod
        def vsimdquatf_v3f_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()

    if objc.macos_available(10, 13):

        @classmethod
        def vsimdquatf_d_(self, arg0, arg1):
            self.argvalues = (
                arg0,
                arg1,
            )
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()

    if objc.macos_available(10, 12):

        @classmethod
        def GKBox(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            )

    if objc.macos_available(10, 12):

        @classmethod
        def GKQuad(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_float2(9.0, 10.0),
                objc.simd.vector_float2(11.0, 12.0),
            )

    if objc.macos_available(10, 12):

        @classmethod
        def GKTriangleQ_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                (
                    objc.simd.vector_float3(-18.5, -19.5, -110.5),
                    objc.simd.vector_float3(-111.5, -112.5, -113.5),
                    objc.simd.vector_float3(-17.5, 11.5, 122.5),
                ),
            )

    if objc.macos_available(10, 11):

        @classmethod
        def MDLAxisAlignedBoundingBox(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            )

    if objc.macos_available(10, 11):

        @classmethod
        def MDLAxisAlignedBoundingBoxv4i_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            )

    if objc.macos_available(10, 11):

        @classmethod
        def MDLAxisAlignedBoundingBoxd_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            )

    if objc.macos_available(10, 11):

        @classmethod
        def MDLVoxelIndexExtent(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            )

    if objc.macos_available(10, 13):

        @classmethod
        def MPSImageHistogramInfo(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                4398046511104,
                True,
                objc.simd.vector_float4(1.0, 2.0, 3.0, 4.0),
                objc.simd.vector_float4(-1.0, -2.0, -3.0, -4.0),
            )

    if objc.macos_available(10, 14):

        @classmethod
        def MPSAxisAlignedBoundingBox(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return (
                objc.simd.vector_float3(1.5, 2.5, 3.5),
                objc.simd.vector_float3(4.5, 5.5, 6.5),
            )

    @classmethod
    def simddouble4x4(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_double4x4(
            (
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
            )
        )

    @classmethod
    def simddouble4x4d_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_double4x4(
            (
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
            )
        )

    @classmethod
    def simdfloat2x2(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float2x2(
            (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
        )

    @classmethod
    def simdfloat3x3(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float3x3(
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )
        )

    @classmethod
    def simdfloat4x3(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float4x3(
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )
        )

    @classmethod
    def simdfloat4x4(self):
        self.argvalues = None
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float4x4(
            (
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            )
        )

    @classmethod
    def simdfloat4x4id_d_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float4x4(
            (
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            )
        )

    @classmethod
    def simdfloat4x4d_(self, arg0):
        self.argvalues = (arg0,)
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float4x4(
            (
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            )
        )

    @classmethod
    def simdfloat4x4simdfloat4x4_id_(self, arg0, arg1):
        self.argvalues = (
            arg0,
            arg1,
        )
        if getattr(self, "shouldRaise", False):
            raise RuntimeError("failure!")
        if getattr(self, "returnInvalid", False):
            return NoObjCClass()
        return simd.simd_float4x4(
            (
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            )
        )

    if objc.macos_available(10, 13):

        @classmethod
        def simdquatdd_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))

    if objc.macos_available(10, 13):

        @classmethod
        def simdquatf(self):
            self.argvalues = None
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    if objc.macos_available(10, 13):

        @classmethod
        def simdquatfd_(self, arg0):
            self.argvalues = (arg0,)
            if getattr(self, "shouldRaise", False):
                raise RuntimeError("failure!")
            if getattr(self, "returnInvalid", False):
                return NoObjCClass()
            return simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))


class TestVectorCall(TestCase):
    def __init__(self, *args, **kwds):
        super().__init__(*args, **kwds)
        self.addTypeEqualityFunc(simd.matrix_float2x2, "assertMatrixEqual")
        self.addTypeEqualityFunc(simd.matrix_float3x3, "assertMatrixEqual")
        self.addTypeEqualityFunc(simd.matrix_float4x3, "assertMatrixEqual")
        self.addTypeEqualityFunc(simd.matrix_float4x4, "assertMatrixEqual")
        self.addTypeEqualityFunc(simd.matrix_double4x4, "assertMatrixEqual")
        self.addTypeEqualityFunc(simd.simd_quatf, "assertMatrixEqual")
        self.addTypeEqualityFunc(simd.simd_quatd, "assertMatrixEqual")
        self.addTypeEqualityFunc(simd.simd_float4x4, "assertMatrixEqual")
        self.addTypeEqualityFunc(simd.simd_float2x2, "assertMatrixEqual")
        self.addTypeEqualityFunc(simd.simd_float3x3, "assertMatrixEqual")
        self.addTypeEqualityFunc(simd.simd_float4x3, "assertMatrixEqual")
        self.addTypeEqualityFunc(simd.simd_float4x4, "assertMatrixEqual")
        self.addTypeEqualityFunc(simd.simd_double4x4, "assertMatrixEqual")

    def assertMatrixEqual(self, first, second, msg=None):
        self.assertEqual(type(first), type(second))
        if hasattr(first, "vector"):
            self.assertSequenceEqual(first.vector, second.vector, msg)
        else:
            self.assertSequenceEqual(first.columns, second.columns, msg)

    def test_v16C(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v16C.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v16C)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v16C, b"<16C>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v16C

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            objc.simd.vector_uchar16(
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_clsv16C(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv16C.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv16C)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv16C, b"<16C>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv16C

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            objc.simd.vector_uchar16(
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_v16C_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v16C.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v16C)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v16C, b"<16C>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v16C")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            objc.simd.vector_uchar16(
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    def test_clsv16C_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv16C.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv16C)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv16C, b"<16C>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv16C")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            objc.simd.vector_uchar16(
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
            ),
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(
            rv,
            objc.simd.vector_uchar16(
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
            ),
        )

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(
            rv,
            objc.simd.vector_uchar16(
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    def test_imp_v16C(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v16COn_(value)
        self.assertEqual(
            result,
            objc.simd.vector_uchar16(
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v16COn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v16COn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v16C_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v16COn_(value)
        self.assertEqual(
            result,
            objc.simd.vector_uchar16(
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v16COn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v16COn_(value)
        finally:
            del value.returnInvalid

    def test_v2d(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2d.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2d)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2d, b"<2d>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v2d

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_double2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_clsv2d(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2d.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2d)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2d, b"<2d>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv2d

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_double2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_v2d_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2d.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2d)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2d, b"<2d>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v2d")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_double2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    def test_clsv2d_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2d.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2d)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2d, b"<2d>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv2d")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_double2(0.0, 1.5))

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(rv, objc.simd.vector_double2(0.0, 1.5))

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(rv, objc.simd.vector_double2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    def test_imp_v2d(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2dOn_(value)
        self.assertEqual(result, objc.simd.vector_double2(0.0, 1.5))
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2dOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v2d_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2dOn_(value)
        self.assertEqual(result, objc.simd.vector_double2(0.0, 1.5))
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2dOn_(value)
        finally:
            del value.returnInvalid

    def test_v2dd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2dd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2dd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2dd_, b"<2d>")
        self.assertArgHasType(OC_VectorCall.v2dd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v2dd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_clsv2dd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2dd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2dd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2dd_, b"<2d>")
        self.assertArgHasType(OC_VectorCall.clsv2dd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv2dd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_v2dd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2dd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2dd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2dd_, b"<2d>")
        self.assertArgHasType(OC_VectorCall.v2dd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v2dd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, -557000000000.0)

    def test_clsv2dd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2dd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2dd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2dd_, b"<2d>")
        self.assertArgHasType(OC_VectorCall.clsv2dd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv2dd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double2(0.0, 1.5))

        # Valid call through instance
        rv = imp(oc_inst, -557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double2(0.0, 1.5))

        # Valid call through meta
        rv = imp(type(oc), -557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, -557000000000.0)

    def test_imp_v2dd_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2ddOn_(value)
        self.assertEqual(result, objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2ddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2ddOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v2dd__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2ddOn_(value)
        self.assertEqual(result, objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2ddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2ddOn_(value)
        finally:
            del value.returnInvalid

    def test_v2f(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2f.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2f)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2f, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v2f

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_clsv2f(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2f.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2f)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2f, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv2f

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_v2f_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2f.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2f)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2f, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v2f")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    def test_clsv2f_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2f.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2f)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2f, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv2f")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    def test_imp_v2f(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2fOn_(value)
        self.assertEqual(result, objc.simd.vector_float2(0.0, 1.5))
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v2f_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2fOn_(value)
        self.assertEqual(result, objc.simd.vector_float2(0.0, 1.5))
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2fOn_(value)
        finally:
            del value.returnInvalid

    def test_v2fQ_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2fQ_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2fQ_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2fQ_, b"<2f>")
        self.assertArgHasType(OC_VectorCall.v2fQ_, 0, b"Q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v2fQ_

        # Valid call
        rv = caller(35184372088832)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], 35184372088832)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(35184372088832, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(35184372088832)

    def test_clsv2fQ_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2fQ_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2fQ_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2fQ_, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsv2fQ_, 0, b"Q")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv2fQ_

        # Valid call
        rv = caller(35184372088832)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], 35184372088832)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(35184372088832, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(35184372088832)

    def test_v2fQ__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2fQ_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2fQ_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2fQ_, b"<2f>")
        self.assertArgHasType(OC_VectorCall.v2fQ_, 0, b"Q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v2fQ:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(35184372088832)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], 35184372088832)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(35184372088832, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(35184372088832)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, 35184372088832)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, 35184372088832)

    def test_clsv2fQ__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2fQ_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2fQ_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2fQ_, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsv2fQ_, 0, b"Q")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv2fQ:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(35184372088832)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        # Valid call through instance
        rv = imp(oc_inst, 35184372088832)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        # Valid call through meta
        rv = imp(type(oc), 35184372088832)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], 35184372088832)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(35184372088832, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(35184372088832)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, 35184372088832)

    def test_imp_v2fQ_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2fQOn_(value)
        self.assertEqual(result, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(value.argvalues, (35184372088832,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2fQOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2fQOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v2fQ__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2fQOn_(value)
        self.assertEqual(result, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(value.argvalues, (35184372088832,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2fQOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2fQOn_(value)
        finally:
            del value.returnInvalid

    def test_v2fd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2fd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2fd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2fd_, b"<2f>")
        self.assertArgHasType(OC_VectorCall.v2fd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v2fd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_clsv2fd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2fd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2fd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2fd_, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsv2fd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv2fd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_v2fd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2fd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2fd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2fd_, b"<2f>")
        self.assertArgHasType(OC_VectorCall.v2fd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v2fd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, -557000000000.0)

    def test_clsv2fd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2fd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2fd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2fd_, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsv2fd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv2fd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        # Valid call through instance
        rv = imp(oc_inst, -557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        # Valid call through meta
        rv = imp(type(oc), -557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, -557000000000.0)

    def test_imp_v2fd_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2fdOn_(value)
        self.assertEqual(result, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2fdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2fdOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v2fd__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2fdOn_(value)
        self.assertEqual(result, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2fdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2fdOn_(value)
        finally:
            del value.returnInvalid

    def test_v2fq_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2fq_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2fq_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2fq_, b"<2f>")
        self.assertArgHasType(OC_VectorCall.v2fq_, 0, b"q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v2fq_

        # Valid call
        rv = caller(-17592186044416)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-17592186044416, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-17592186044416)

    def test_clsv2fq_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2fq_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2fq_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2fq_, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsv2fq_, 0, b"q")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv2fq_

        # Valid call
        rv = caller(-17592186044416)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-17592186044416, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-17592186044416)

    def test_v2fq__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2fq_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2fq_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2fq_, b"<2f>")
        self.assertArgHasType(OC_VectorCall.v2fq_, 0, b"q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v2fq:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-17592186044416)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-17592186044416, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-17592186044416)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, -17592186044416)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, -17592186044416)

    def test_clsv2fq__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2fq_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2fq_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2fq_, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsv2fq_, 0, b"q")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv2fq:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-17592186044416)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        # Valid call through instance
        rv = imp(oc_inst, -17592186044416)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        # Valid call through meta
        rv = imp(type(oc), -17592186044416)
        self.assertEqual(rv, objc.simd.vector_float2(0.0, 1.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-17592186044416, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-17592186044416)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, -17592186044416)

    def test_imp_v2fq_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2fqOn_(value)
        self.assertEqual(result, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(value.argvalues, (-17592186044416,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2fqOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2fqOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v2fq__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2fqOn_(value)
        self.assertEqual(result, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(value.argvalues, (-17592186044416,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2fqOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2fqOn_(value)
        finally:
            del value.returnInvalid

    def test_v2i(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2i.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2i)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2i, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v2i

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_int2(0, 1))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_clsv2i(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2i.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2i)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2i, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv2i

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_int2(0, 1))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_v2i_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v2i.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v2i)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v2i, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v2i")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_int2(0, 1))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    def test_clsv2i_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv2i.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv2i)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv2i, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv2i")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_int2(0, 1))

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(rv, objc.simd.vector_int2(0, 1))

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(rv, objc.simd.vector_int2(0, 1))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    def test_imp_v2i(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2iOn_(value)
        self.assertEqual(result, objc.simd.vector_int2(0, 1))
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2iOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v2i_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v2iOn_(value)
        self.assertEqual(result, objc.simd.vector_int2(0, 1))
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v2iOn_(value)
        finally:
            del value.returnInvalid

    def test_v3dd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3dd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3dd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3dd_, b"<3d>")
        self.assertArgHasType(OC_VectorCall.v3dd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v3dd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_clsv3dd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3dd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3dd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3dd_, b"<3d>")
        self.assertArgHasType(OC_VectorCall.clsv3dd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv3dd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_v3dd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3dd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3dd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3dd_, b"<3d>")
        self.assertArgHasType(OC_VectorCall.v3dd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v3dd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, -557000000000.0)

    def test_clsv3dd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3dd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3dd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3dd_, b"<3d>")
        self.assertArgHasType(OC_VectorCall.clsv3dd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv3dd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double3(0.0, 1.5, 3.0))

        # Valid call through instance
        rv = imp(oc_inst, -557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double3(0.0, 1.5, 3.0))

        # Valid call through meta
        rv = imp(type(oc), -557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, -557000000000.0)

    def test_imp_v3dd_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3ddOn_(value)
        self.assertEqual(result, objc.simd.vector_double3(0.0, 1.5, 3.0))
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3ddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3ddOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v3dd__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3ddOn_(value)
        self.assertEqual(result, objc.simd.vector_double3(0.0, 1.5, 3.0))
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3ddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3ddOn_(value)
        finally:
            del value.returnInvalid

    def test_v3f(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3f.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3f)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3f, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v3f

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_clsv3f(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3f.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3f)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3f, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv3f

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_v3f_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3f.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3f)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3f, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v3f")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    def test_clsv3f_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3f.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3f)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3f, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv3f")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    def test_imp_v3f(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v3f_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fOn_(value)
        finally:
            del value.returnInvalid

    def test_v3fv2i_v2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3fv2i_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3fv2i_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3fv2i_v2i_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fv2i_v2i_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.v3fv2i_v2i_, 1, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v3fv2i_v2i_

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1))

    def test_clsv3fv2i_v2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3fv2i_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3fv2i_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3fv2i_v2i_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fv2i_v2i_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsv3fv2i_v2i_, 1, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv3fv2i_v2i_

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1))

    def test_v3fv2i_v2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3fv2i_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3fv2i_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3fv2i_v2i_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fv2i_v2i_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.v3fv2i_v2i_, 1, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v3fv2i:v2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                objc.simd.vector_int2(0, 1),
            )

    def test_clsv3fv2i_v2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3fv2i_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3fv2i_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3fv2i_v2i_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fv2i_v2i_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsv3fv2i_v2i_, 1, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv3fv2i:v2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_int2(0, 1), objc.simd.vector_int2(0, 1))

    def test_imp_v3fv2i_v2i_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fv2iv2iOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_int2(0, 1),
                objc.simd.vector_int2(0, 1),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fv2iv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fv2iv2iOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v3fv2i_v2i__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fv2iv2iOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_int2(0, 1),
                objc.simd.vector_int2(0, 1),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fv2iv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fv2iv2iOn_(value)
        finally:
            del value.returnInvalid

    def test_v3fv3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3fv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3fv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3fv3f_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v3fv3f_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_clsv3fv3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3fv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3fv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3fv3f_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv3fv3f_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_v3fv3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3fv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3fv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3fv3f_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v3fv3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_clsv3fv3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3fv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3fv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3fv3f_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv3fv3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_imp_v3fv3f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fv3fOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(value.argvalues, (objc.simd.vector_float3(0.0, 1.5, 3.0),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v3fv3f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fv3fOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(value.argvalues, (objc.simd.vector_float3(0.0, 1.5, 3.0),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_v3fv3f_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3fv3f_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3fv3f_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3fv3f_id_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fv3f_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fv3f_id_, 1, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v3fv3f_id_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello", "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), NoObjCValueObject)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

    def test_clsv3fv3f_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3fv3f_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3fv3f_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3fv3f_id_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fv3f_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fv3f_id_, 1, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv3fv3f_id_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello", "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), NoObjCValueObject)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

    def test_v3fv3f_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3fv3f_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3fv3f_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3fv3f_id_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fv3f_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fv3f_id_, 1, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v3fv3f:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello", "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), NoObjCValueObject)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

    def test_clsv3fv3f_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3fv3f_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3fv3f_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3fv3f_id_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fv3f_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fv3f_id_, 1, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv3fv3f:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello", "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), NoObjCValueObject)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

    def test_imp_v3fv3f_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fv3fidOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fv3fidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fv3fidOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v3fv3f_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fv3fidOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fv3fidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fv3fidOn_(value)
        finally:
            del value.returnInvalid

    def test_v3fv4i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3fv4i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3fv4i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3fv4i_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fv4i_, 0, b"<4i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v3fv4i_

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3))

    def test_clsv3fv4i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3fv4i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3fv4i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3fv4i_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fv4i_, 0, b"<4i>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv3fv4i_

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3))

    def test_v3fv4i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3fv4i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3fv4i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3fv4i_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fv4i_, 0, b"<4i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v3fv4i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_int4(0, 1, 2, 3))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_int4(0, 1, 2, 3))

    def test_clsv3fv4i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3fv4i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3fv4i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3fv4i_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fv4i_, 0, b"<4i>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv3fv4i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_int4(0, 1, 2, 3))

    def test_imp_v3fv4i_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fv4iOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(value.argvalues, (objc.simd.vector_int4(0, 1, 2, 3),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fv4iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fv4iOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v3fv4i__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fv4iOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(value.argvalues, (objc.simd.vector_int4(0, 1, 2, 3),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fv4iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fv4iOn_(value)
        finally:
            del value.returnInvalid

    def test_v3fQ_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3fQ_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3fQ_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3fQ_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fQ_, 0, b"Q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v3fQ_

        # Valid call
        rv = caller(35184372088832)
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], 35184372088832)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(35184372088832, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(35184372088832)

    def test_clsv3fQ_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3fQ_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3fQ_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3fQ_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fQ_, 0, b"Q")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv3fQ_

        # Valid call
        rv = caller(35184372088832)
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], 35184372088832)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(35184372088832, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(35184372088832)

    def test_v3fQ__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3fQ_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3fQ_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3fQ_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fQ_, 0, b"Q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v3fQ:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(35184372088832)
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], 35184372088832)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(35184372088832, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(35184372088832)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, 35184372088832)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, 35184372088832)

    def test_clsv3fQ__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3fQ_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3fQ_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3fQ_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fQ_, 0, b"Q")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv3fQ:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(35184372088832)
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through instance
        rv = imp(oc_inst, 35184372088832)
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through meta
        rv = imp(type(oc), 35184372088832)
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], 35184372088832)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(35184372088832, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(35184372088832)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, 35184372088832)

    def test_imp_v3fQ_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fQOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(value.argvalues, (35184372088832,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fQOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fQOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v3fQ__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fQOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(value.argvalues, (35184372088832,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fQOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fQOn_(value)
        finally:
            del value.returnInvalid

    def test_v3fd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3fd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3fd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3fd_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v3fd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_clsv3fd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3fd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3fd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3fd_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv3fd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_v3fd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v3fd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v3fd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v3fd_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.v3fd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v3fd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, -557000000000.0)

    def test_clsv3fd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv3fd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv3fd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv3fd_, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsv3fd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv3fd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through instance
        rv = imp(oc_inst, -557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Valid call through meta
        rv = imp(type(oc), -557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float3(0.0, 1.5, 3.0))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, -557000000000.0)

    def test_imp_v3fd_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fdOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fdOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v3fd__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v3fdOn_(value)
        self.assertEqual(result, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v3fdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v3fdOn_(value)
        finally:
            del value.returnInvalid

    def test_v4dd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v4dd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v4dd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v4dd_, b"<4d>")
        self.assertArgHasType(OC_VectorCall.v4dd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v4dd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_clsv4dd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv4dd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv4dd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv4dd_, b"<4d>")
        self.assertArgHasType(OC_VectorCall.clsv4dd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv4dd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_v4dd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v4dd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v4dd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v4dd_, b"<4d>")
        self.assertArgHasType(OC_VectorCall.v4dd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v4dd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, -557000000000.0)

    def test_clsv4dd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv4dd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv4dd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv4dd_, b"<4d>")
        self.assertArgHasType(OC_VectorCall.clsv4dd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv4dd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))

        # Valid call through instance
        rv = imp(oc_inst, -557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))

        # Valid call through meta
        rv = imp(type(oc), -557000000000.0)
        self.assertEqual(rv, objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, -557000000000.0)

    def test_imp_v4dd_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v4ddOn_(value)
        self.assertEqual(result, objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v4ddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v4ddOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v4dd__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v4ddOn_(value)
        self.assertEqual(result, objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v4ddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v4ddOn_(value)
        finally:
            del value.returnInvalid

    def test_v4f(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v4f.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v4f)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v4f, b"<4f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v4f

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_clsv4f(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv4f.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv4f)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv4f, b"<4f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv4f

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_v4f_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v4f.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v4f)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v4f, b"<4f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v4f")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    def test_clsv4f_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv4f.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv4f)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv4f, b"<4f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv4f")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(rv, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(rv, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(rv, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    def test_imp_v4f(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v4fOn_(value)
        self.assertEqual(result, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v4fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v4fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v4f_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v4fOn_(value)
        self.assertEqual(result, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v4fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v4fOn_(value)
        finally:
            del value.returnInvalid

    def test_v4fd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v4fd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v4fd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v4fd_, b"<4f>")
        self.assertArgHasType(OC_VectorCall.v4fd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v4fd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_clsv4fd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv4fd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv4fd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv4fd_, b"<4f>")
        self.assertArgHasType(OC_VectorCall.clsv4fd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv4fd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_v4fd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v4fd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v4fd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v4fd_, b"<4f>")
        self.assertArgHasType(OC_VectorCall.v4fd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v4fd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, -557000000000.0)

    def test_clsv4fd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv4fd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv4fd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv4fd_, b"<4f>")
        self.assertArgHasType(OC_VectorCall.clsv4fd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv4fd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Valid call through instance
        rv = imp(oc_inst, -557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Valid call through meta
        rv = imp(type(oc), -557000000000.0)
        self.assertEqual(rv, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, -557000000000.0)

    def test_imp_v4fd_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v4fdOn_(value)
        self.assertEqual(result, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v4fdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v4fdOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v4fd__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v4fdOn_(value)
        self.assertEqual(result, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v4fdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v4fdOn_(value)
        finally:
            del value.returnInvalid

    def test_v4iv3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v4iv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v4iv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v4iv3f_, b"<4i>")
        self.assertArgHasType(OC_VectorCall.v4iv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.v4iv3f_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, objc.simd.vector_int4(0, 1, 2, 3))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_clsv4iv3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv4iv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv4iv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv4iv3f_, b"<4i>")
        self.assertArgHasType(OC_VectorCall.clsv4iv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsv4iv3f_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, objc.simd.vector_int4(0, 1, 2, 3))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_v4iv3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.v4iv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.v4iv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.v4iv3f_, b"<4i>")
        self.assertArgHasType(OC_VectorCall.v4iv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"v4iv3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, objc.simd.vector_int4(0, 1, 2, 3))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_clsv4iv3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsv4iv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsv4iv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsv4iv3f_, b"<4i>")
        self.assertArgHasType(OC_VectorCall.clsv4iv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsv4iv3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, objc.simd.vector_int4(0, 1, 2, 3))

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, objc.simd.vector_int4(0, 1, 2, 3))

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, objc.simd.vector_int4(0, 1, 2, 3))

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_imp_v4iv3f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.v4iv3fOn_(value)
        self.assertEqual(result, objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(value.argvalues, (objc.simd.vector_float3(0.0, 1.5, 3.0),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v4iv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v4iv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_v4iv3f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.v4iv3fOn_(value)
        self.assertEqual(result, objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(value.argvalues, (objc.simd.vector_float3(0.0, 1.5, 3.0),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.v4iv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.v4iv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_idv2d_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2d_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2d_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2d_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2d_id_, 0, b"<2d>")
        self.assertArgHasType(OC_VectorCall.idv2d_id_, 1, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv2d_id_

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5), "hello")
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[1], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), "hello", "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double2(0.0, 1.5), NoObjCValueObject)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5), "hello")

    def test_clsidv2d_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2d_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2d_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2d_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2d_id_, 0, b"<2d>")
        self.assertArgHasType(OC_VectorCall.clsidv2d_id_, 1, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv2d_id_

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5), "hello")
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[1], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), "hello", "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double2(0.0, 1.5), NoObjCValueObject)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5), "hello")

    def test_idv2d_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2d_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2d_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2d_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2d_id_, 0, b"<2d>")
        self.assertArgHasType(OC_VectorCall.idv2d_id_, 1, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv2d:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5), "hello")
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[1], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), "hello", "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double2(0.0, 1.5), NoObjCValueObject)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5), "hello")

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_double2(0.0, 1.5), "hello")

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_double2(0.0, 1.5), "hello")

    def test_clsidv2d_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2d_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2d_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2d_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2d_id_, 0, b"<2d>")
        self.assertArgHasType(OC_VectorCall.clsidv2d_id_, 1, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv2d:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5), "hello")
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_double2(0.0, 1.5), "hello")
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_double2(0.0, 1.5), "hello")
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[1], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), "hello", "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double2(0.0, 1.5), NoObjCValueObject)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5), "hello")

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_double2(0.0, 1.5), "hello")

    def test_imp_idv2d_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2didOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_double2(0.0, 1.5),
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2didOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2didOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv2d_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2didOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_double2(0.0, 1.5),
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2didOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2didOn_(value)
        finally:
            del value.returnInvalid

    def test_idv2d_q_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2d_q_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2d_q_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2d_q_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2d_q_, 0, b"<2d>")
        self.assertArgHasType(OC_VectorCall.idv2d_q_, 1, b"q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv2d_q_

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5), -17592186044416)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[1], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), -17592186044416, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5), -17592186044416)

    def test_clsidv2d_q_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2d_q_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2d_q_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2d_q_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2d_q_, 0, b"<2d>")
        self.assertArgHasType(OC_VectorCall.clsidv2d_q_, 1, b"q")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv2d_q_

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5), -17592186044416)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[1], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), -17592186044416, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5), -17592186044416)

    def test_idv2d_q__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2d_q_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2d_q_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2d_q_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2d_q_, 0, b"<2d>")
        self.assertArgHasType(OC_VectorCall.idv2d_q_, 1, b"q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv2d:q:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5), -17592186044416)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[1], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), -17592186044416, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5), -17592186044416)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_double2(0.0, 1.5), -17592186044416)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_double2(0.0, 1.5), -17592186044416)

    def test_clsidv2d_q__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2d_q_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2d_q_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2d_q_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2d_q_, 0, b"<2d>")
        self.assertArgHasType(OC_VectorCall.clsidv2d_q_, 1, b"q")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv2d:q:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5), -17592186044416)
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_double2(0.0, 1.5), -17592186044416)
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_double2(0.0, 1.5), -17592186044416)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[1], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), -17592186044416, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5), -17592186044416)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_double2(0.0, 1.5), -17592186044416)

    def test_imp_idv2d_q_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2dqOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_double2(0.0, 1.5),
                -17592186044416,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2dqOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2dqOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv2d_q__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2dqOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_double2(0.0, 1.5),
                -17592186044416,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2dqOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2dqOn_(value)
        finally:
            del value.returnInvalid

    def test_idv2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2f_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2f_, 0, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv2f_

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5))

    def test_clsidv2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2f_, 0, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv2f_

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5))

    def test_idv2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2f_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2f_, 0, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_float2(0.0, 1.5))

    def test_clsidv2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2f_, 0, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float2(0.0, 1.5))

    def test_imp_idv2f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(value.argvalues, (objc.simd.vector_float2(0.0, 1.5),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv2f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(value.argvalues, (objc.simd.vector_float2(0.0, 1.5),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_idv2f_v2I_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2f_v2I_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2f_v2I_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2f_v2I_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2f_v2I_q_id_, 0, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idv2f_v2I_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.idv2f_v2I_q_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.idv2f_v2I_q_id_, 3, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv2f_v2I_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_uint2(0, 1),
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_uint2(0, 1), -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float2(0.0, 1.5), None, -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

    def test_clsidv2f_v2I_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2f_v2I_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2f_v2I_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2f_v2I_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2f_v2I_q_id_, 0, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidv2f_v2I_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.clsidv2f_v2I_q_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv2f_v2I_q_id_, 3, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv2f_v2I_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_uint2(0, 1),
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_uint2(0, 1), -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float2(0.0, 1.5), None, -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

    def test_idv2f_v2I_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2f_v2I_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2f_v2I_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2f_v2I_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2f_v2I_q_id_, 0, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idv2f_v2I_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.idv2f_v2I_q_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.idv2f_v2I_q_id_, 3, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv2f:v2I:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_uint2(0, 1),
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_uint2(0, 1), -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float2(0.0, 1.5), None, -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

    def test_clsidv2f_v2I_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2f_v2I_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2f_v2I_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2f_v2I_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2f_v2I_q_id_, 0, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidv2f_v2I_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.clsidv2f_v2I_q_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv2f_v2I_q_id_, 3, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv2f:v2I:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_uint2(0, 1),
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_uint2(0, 1),
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_uint2(0, 1),
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_uint2(0, 1), -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float2(0.0, 1.5), None, -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

    def test_imp_idv2f_v2I_q_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2fv2IqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2fv2IqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2fv2IqidOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv2f_v2I_q_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2fv2IqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2fv2IqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2fv2IqidOn_(value)
        finally:
            del value.returnInvalid

    def test_idv2f_v2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2f_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2f_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2f_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2f_v2f_, 0, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idv2f_v2f_, 1, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv2f_v2f_

        # Valid call
        rv = caller(
            objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5)
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))

    def test_clsidv2f_v2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2f_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2f_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2f_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2f_v2f_, 0, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidv2f_v2f_, 1, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv2f_v2f_

        # Valid call
        rv = caller(
            objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5)
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))

    def test_idv2f_v2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2f_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2f_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2f_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2f_v2f_, 0, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idv2f_v2f_, 1, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv2f:v2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5)
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42, objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5)
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

    def test_clsidv2f_v2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2f_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2f_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2f_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2f_v2f_, 0, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidv2f_v2f_, 1, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv2f:v2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5)
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42, objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5)
            )

    def test_imp_idv2f_v2f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2fv2fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2fv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2fv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv2f_v2f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2fv2fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2fv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2fv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_idv2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2i_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2i_, 0, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv2i_

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1))

    def test_clsidv2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2i_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2i_, 0, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv2i_

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1))

    def test_idv2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2i_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2i_, 0, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_int2(0, 1))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_int2(0, 1))

    def test_clsidv2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2i_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2i_, 0, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_int2(0, 1))

    def test_imp_idv2i_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2iOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(value.argvalues, (objc.simd.vector_int2(0, 1),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2iOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv2i__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2iOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(value.argvalues, (objc.simd.vector_int2(0, 1),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2iOn_(value)
        finally:
            del value.returnInvalid

    def test_idv2i_i_i_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2i_i_i_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2i_i_i_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2i_i_i_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_, 1, b"i")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_, 2, b"i")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_, 3, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv2i_i_i_Z_

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1), -42, -42, False)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], -42)
        self.assertEqual(stored[2], -42)
        self.assertEqual(stored[3], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), -42, -42)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -42, -42, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), None, -42, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), -42, None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), -42, -42, NoBool())

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False)

    def test_clsidv2i_i_i_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2i_i_i_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2i_i_i_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2i_i_i_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_, 1, b"i")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_, 2, b"i")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_, 3, b"Z")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv2i_i_i_Z_

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1), -42, -42, False)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], -42)
        self.assertEqual(stored[2], -42)
        self.assertEqual(stored[3], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), -42, -42)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -42, -42, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), None, -42, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), -42, None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), -42, -42, NoBool())

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False)

    def test_idv2i_i_i_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2i_i_i_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2i_i_i_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2i_i_i_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_, 1, b"i")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_, 2, b"i")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_, 3, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv2i:i:i:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1), -42, -42, False)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], -42)
        self.assertEqual(stored[2], -42)
        self.assertEqual(stored[3], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), -42, -42)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -42, -42, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), None, -42, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), -42, None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), -42, -42, NoBool())

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_int2(0, 1), -42, -42, False)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_int2(0, 1), -42, -42, False)

    def test_clsidv2i_i_i_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2i_i_i_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2i_i_i_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2i_i_i_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_, 1, b"i")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_, 2, b"i")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_, 3, b"Z")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv2i:i:i:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1), -42, -42, False)
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_int2(0, 1), -42, -42, False)
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_int2(0, 1), -42, -42, False)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], -42)
        self.assertEqual(stored[2], -42)
        self.assertEqual(stored[3], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), -42, -42)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -42, -42, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), None, -42, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), -42, None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), -42, -42, NoBool())

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_int2(0, 1), -42, -42, False)

    def test_imp_idv2i_i_i_Z_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2iiiZOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2iiiZOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2iiiZOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv2i_i_i_Z__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2iiiZOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2iiiZOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2iiiZOn_(value)
        finally:
            del value.returnInvalid

    def test_idv2i_i_i_Z_Class_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2i_i_i_Z_Class_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2i_i_i_Z_Class_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2i_i_i_Z_Class_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_Class_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_Class_, 1, b"i")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_Class_, 2, b"i")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_Class_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_Class_, 4, b"#")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv2i_i_i_Z_Class_

        # Valid call
        rv = caller(
            objc.simd.vector_int2(0, 1), -42, -42, False, objc.lookUpClass("NSObject")
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], -42)
        self.assertEqual(stored[2], -42)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], objc.lookUpClass("NSObject"))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
                objc.lookUpClass("NSObject"),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -42, -42, False, objc.lookUpClass("NSObject"))

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                None,
                -42,
                False,
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                None,
                False,
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                NoBool(),
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False, 42)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
                objc.lookUpClass("NSObject"),
            )

    def test_clsidv2i_i_i_Z_Class_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2i_i_i_Z_Class_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2i_i_i_Z_Class_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2i_i_i_Z_Class_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_Class_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_Class_, 1, b"i")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_Class_, 2, b"i")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_Class_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_Class_, 4, b"#")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv2i_i_i_Z_Class_

        # Valid call
        rv = caller(
            objc.simd.vector_int2(0, 1), -42, -42, False, objc.lookUpClass("NSObject")
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], -42)
        self.assertEqual(stored[2], -42)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], objc.lookUpClass("NSObject"))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
                objc.lookUpClass("NSObject"),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -42, -42, False, objc.lookUpClass("NSObject"))

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                None,
                -42,
                False,
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                None,
                False,
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                NoBool(),
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False, 42)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
                objc.lookUpClass("NSObject"),
            )

    def test_idv2i_i_i_Z_Class__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv2i_i_i_Z_Class_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv2i_i_i_Z_Class_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv2i_i_i_Z_Class_, b"@")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_Class_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_Class_, 1, b"i")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_Class_, 2, b"i")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_Class_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.idv2i_i_i_Z_Class_, 4, b"#")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv2i:i:i:Z:Class:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_int2(0, 1), -42, -42, False, objc.lookUpClass("NSObject")
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], -42)
        self.assertEqual(stored[2], -42)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], objc.lookUpClass("NSObject"))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
                objc.lookUpClass("NSObject"),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -42, -42, False, objc.lookUpClass("NSObject"))

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                None,
                -42,
                False,
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                None,
                False,
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                NoBool(),
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False, 42)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
                objc.lookUpClass("NSObject"),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
                objc.lookUpClass("NSObject"),
            )

    def test_clsidv2i_i_i_Z_Class__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv2i_i_i_Z_Class_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv2i_i_i_Z_Class_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv2i_i_i_Z_Class_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_Class_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_Class_, 1, b"i")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_Class_, 2, b"i")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_Class_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv2i_i_i_Z_Class_, 4, b"#")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv2i:i:i:Z:Class:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_int2(0, 1), -42, -42, False, objc.lookUpClass("NSObject")
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_int2(0, 1),
            -42,
            -42,
            False,
            objc.lookUpClass("NSObject"),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_int2(0, 1),
            -42,
            -42,
            False,
            objc.lookUpClass("NSObject"),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], -42)
        self.assertEqual(stored[2], -42)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], objc.lookUpClass("NSObject"))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
                objc.lookUpClass("NSObject"),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -42, -42, False, objc.lookUpClass("NSObject"))

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                None,
                -42,
                False,
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                None,
                False,
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                NoBool(),
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int2(0, 1), -42, -42, False, 42)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
                objc.lookUpClass("NSObject"),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
                objc.lookUpClass("NSObject"),
            )

    def test_imp_idv2i_i_i_Z_Class_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2iiiZClassOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
                objc.lookUpClass("NSObject"),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2iiiZClassOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2iiiZClassOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv2i_i_i_Z_Class__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv2iiiZClassOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_int2(0, 1),
                -42,
                -42,
                False,
                objc.lookUpClass("NSObject"),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv2iiiZClassOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv2iiiZClassOn_(value)
        finally:
            del value.returnInvalid

    def test_idv3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv3f_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_clsidv3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv3f_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_idv3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_clsidv3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_imp_idv3f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(value.argvalues, (objc.simd.vector_float3(0.0, 1.5, 3.0),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv3f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(value.argvalues, (objc.simd.vector_float3(0.0, 1.5, 3.0),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_idv3f_v2I_Z_Z_Z_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 4, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 5, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 6, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv3f_v2I_Z_Z_Z_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            False,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], False)
        self.assertEqual(stored[5], -17592186044416)
        self.assertEqual(stored[6], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                NoBool(),
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                NoBool(),
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

    def test_clsidv3f_v2I_Z_Z_Z_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 4, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 5, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 6, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv3f_v2I_Z_Z_Z_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            False,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], False)
        self.assertEqual(stored[5], -17592186044416)
        self.assertEqual(stored[6], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                NoBool(),
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                NoBool(),
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

    def test_idv3f_v2I_Z_Z_Z_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 4, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 5, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_Z_q_id_, 6, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv3f:v2I:Z:Z:Z:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            False,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], False)
        self.assertEqual(stored[5], -17592186044416)
        self.assertEqual(stored[6], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                NoBool(),
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                NoBool(),
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

    def test_clsidv3f_v2I_Z_Z_Z_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 4, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 5, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_Z_q_id_, 6, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv3f:v2I:Z:Z:Z:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            False,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            False,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            False,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], False)
        self.assertEqual(stored[5], -17592186044416)
        self.assertEqual(stored[6], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                NoBool(),
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                NoBool(),
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
            )

    def test_imp_idv3f_v2I_Z_Z_Z_q_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv2IZZZqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv2IZZZqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv2IZZZqidOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv3f_v2I_Z_Z_Z_q_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv2IZZZqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                False,
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv2IZZZqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv2IZZZqidOn_(value)
        finally:
            del value.returnInvalid

    def test_idv3f_v2I_Z_Z_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v2I_Z_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v2I_Z_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, 5, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv3f_v2I_Z_Z_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                NoBool(),
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
            )

    def test_clsidv3f_v2I_Z_Z_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, 5, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv3f_v2I_Z_Z_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                NoBool(),
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
            )

    def test_idv3f_v2I_Z_Z_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v2I_Z_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v2I_Z_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_Z_q_id_, 5, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv3f:v2I:Z:Z:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                NoBool(),
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
            )

    def test_clsidv3f_v2I_Z_Z_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_Z_q_id_, 5, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv3f:v2I:Z:Z:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                NoBool(),
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
            )

    def test_imp_idv3f_v2I_Z_Z_q_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv2IZZqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv2IZZqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv2IZZqidOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv3f_v2I_Z_Z_q_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv2IZZqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                False,
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv2IZZqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv2IZZqidOn_(value)
        finally:
            del value.returnInvalid

    def test_idv3f_v2I_Z_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v2I_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v2I_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v2I_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_q_id_, 3, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_q_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv3f_v2I_Z_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], -17592186044416)
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_uint2(0, 1), False, -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                "hello",
            )

    def test_clsidv3f_v2I_Z_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v2I_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v2I_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v2I_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_q_id_, 3, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_q_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv3f_v2I_Z_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], -17592186044416)
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_uint2(0, 1), False, -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                "hello",
            )

    def test_idv3f_v2I_Z_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v2I_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v2I_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v2I_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_q_id_, 3, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_Z_q_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv3f:v2I:Z:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], -17592186044416)
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_uint2(0, 1), False, -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                "hello",
            )

    def test_clsidv3f_v2I_Z_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v2I_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v2I_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v2I_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_q_id_, 3, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_Z_q_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv3f:v2I:Z:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], -17592186044416)
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_uint2(0, 1), False, -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                "hello",
            )

    def test_imp_idv3f_v2I_Z_q_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv2IZqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv2IZqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv2IZqidOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv3f_v2I_Z_q_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv2IZqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                False,
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv2IZqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv2IZqidOn_(value)
        finally:
            del value.returnInvalid

    def test_idv3f_v2I_i_Z_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v2I_i_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v2I_i_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, 2, b"i")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, 5, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv3f_v2I_i_Z_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            -42,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], -42)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, objc.simd.vector_uint2(0, 1), -42, False, -17592186044416, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                -42,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                None,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                "hello",
            )

    def test_clsidv3f_v2I_i_Z_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, 2, b"i")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, 5, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv3f_v2I_i_Z_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            -42,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], -42)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, objc.simd.vector_uint2(0, 1), -42, False, -17592186044416, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                -42,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                None,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                "hello",
            )

    def test_idv3f_v2I_i_Z_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v2I_i_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v2I_i_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, 2, b"i")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_i_Z_q_id_, 5, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv3f:v2I:i:Z:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            -42,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], -42)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, objc.simd.vector_uint2(0, 1), -42, False, -17592186044416, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                -42,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                None,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                "hello",
            )

    def test_clsidv3f_v2I_i_Z_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, 2, b"i")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_i_Z_q_id_, 5, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv3f:v2I:i:Z:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            -42,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            -42,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            -42,
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], -42)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, objc.simd.vector_uint2(0, 1), -42, False, -17592186044416, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                -42,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                None,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                "hello",
            )

    def test_imp_idv3f_v2I_i_Z_q_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv2IiZqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv2IiZqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv2IiZqidOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv3f_v2I_i_Z_q_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv2IiZqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -42,
                False,
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv2IiZqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv2IiZqidOn_(value)
        finally:
            del value.returnInvalid

    def test_idv3f_v2I_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v2I_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v2I_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v2I_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_q_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_q_id_, 3, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv3f_v2I_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_uint2(0, 1), -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0), None, -17592186044416, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

    def test_clsidv3f_v2I_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v2I_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v2I_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v2I_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_q_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_q_id_, 3, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv3f_v2I_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_uint2(0, 1), -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0), None, -17592186044416, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

    def test_idv3f_v2I_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v2I_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v2I_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v2I_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_q_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v2I_q_id_, 3, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv3f:v2I:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_uint2(0, 1), -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0), None, -17592186044416, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

    def test_clsidv3f_v2I_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v2I_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v2I_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v2I_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_q_id_, 1, b"<2I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_q_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v2I_q_id_, 3, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv3f:v2I:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint2(0, 1),
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint2(0, 1))
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_uint2(0, 1), -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0), None, -17592186044416, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            )

    def test_imp_idv3f_v2I_q_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv2IqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv2IqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv2IqidOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv3f_v2I_q_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv2IqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint2(0, 1),
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv2IqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv2IqidOn_(value)
        finally:
            del value.returnInvalid

    def test_idv3f_v3I_Z_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v3I_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v3I_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v3I_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_Z_q_id_, 1, b"<3I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_Z_q_id_, 3, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_Z_q_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv3f_v3I_Z_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint3(0, 1, 2),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint3(0, 1, 2))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], -17592186044416)
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, objc.simd.vector_uint3(0, 1, 2), False, -17592186044416, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                "hello",
            )

    def test_clsidv3f_v3I_Z_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v3I_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v3I_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v3I_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_Z_q_id_, 1, b"<3I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_Z_q_id_, 3, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_Z_q_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv3f_v3I_Z_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint3(0, 1, 2),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint3(0, 1, 2))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], -17592186044416)
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, objc.simd.vector_uint3(0, 1, 2), False, -17592186044416, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                "hello",
            )

    def test_idv3f_v3I_Z_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v3I_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v3I_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v3I_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_Z_q_id_, 1, b"<3I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_Z_q_id_, 3, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_Z_q_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv3f:v3I:Z:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint3(0, 1, 2),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint3(0, 1, 2))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], -17592186044416)
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, objc.simd.vector_uint3(0, 1, 2), False, -17592186044416, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                "hello",
            )

    def test_clsidv3f_v3I_Z_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v3I_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v3I_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v3I_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_Z_q_id_, 1, b"<3I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_Z_q_id_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_Z_q_id_, 3, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_Z_q_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv3f:v3I:Z:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint3(0, 1, 2),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint3(0, 1, 2),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint3(0, 1, 2),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint3(0, 1, 2))
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], -17592186044416)
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, objc.simd.vector_uint3(0, 1, 2), False, -17592186044416, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                None,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                "hello",
            )

    def test_imp_idv3f_v3I_Z_q_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv3IZqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv3IZqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv3IZqidOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv3f_v3I_Z_q_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv3IZqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                False,
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv3IZqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv3IZqidOn_(value)
        finally:
            del value.returnInvalid

    def test_idv3f_v3I_q_Z_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v3I_q_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v3I_q_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v3I_q_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_q_Z_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_q_Z_id_, 1, b"<3I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_q_Z_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_q_Z_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_q_Z_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv3f_v3I_q_Z_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint3(0, 1, 2),
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint3(0, 1, 2))
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, objc.simd.vector_uint3(0, 1, 2), -17592186044416, False, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                None,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                "hello",
            )

    def test_clsidv3f_v3I_q_Z_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v3I_q_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v3I_q_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v3I_q_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_q_Z_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_q_Z_id_, 1, b"<3I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_q_Z_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_q_Z_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_q_Z_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv3f_v3I_q_Z_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint3(0, 1, 2),
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint3(0, 1, 2))
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, objc.simd.vector_uint3(0, 1, 2), -17592186044416, False, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                None,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                "hello",
            )

    def test_idv3f_v3I_q_Z_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_v3I_q_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_v3I_q_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_v3I_q_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_q_Z_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_q_Z_id_, 1, b"<3I>")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_q_Z_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_q_Z_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_v3I_q_Z_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv3f:v3I:q:Z:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint3(0, 1, 2),
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint3(0, 1, 2))
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, objc.simd.vector_uint3(0, 1, 2), -17592186044416, False, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                None,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                "hello",
            )

    def test_clsidv3f_v3I_q_Z_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_v3I_q_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_v3I_q_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_v3I_q_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_q_Z_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_q_Z_id_, 1, b"<3I>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_q_Z_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_q_Z_id_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_v3I_q_Z_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv3f:v3I:q:Z:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint3(0, 1, 2),
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint3(0, 1, 2),
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_uint3(0, 1, 2),
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_uint3(0, 1, 2))
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, objc.simd.vector_uint3(0, 1, 2), -17592186044416, False, "hello"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                None,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                "hello",
            )

    def test_imp_idv3f_v3I_q_Z_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv3IqZidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv3IqZidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv3IqZidOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv3f_v3I_q_Z_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fv3IqZidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_uint3(0, 1, 2),
                -17592186044416,
                False,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fv3IqZidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fv3IqZidOn_(value)
        finally:
            del value.returnInvalid

    def test_idv3f_Q_Q_q_Z_Z_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 2, b"Q")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 3, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 4, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 5, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 6, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv3f_Q_Q_q_Z_Z_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], 35184372088832)
        self.assertEqual(stored[3], -17592186044416)
        self.assertEqual(stored[4], False)
        self.assertEqual(stored[5], False)
        self.assertEqual(stored[6], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                None,
                -17592186044416,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                None,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                NoBool(),
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

    def test_clsidv3f_Q_Q_q_Z_Z_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 2, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 3, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 4, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 5, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 6, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv3f_Q_Q_q_Z_Z_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], 35184372088832)
        self.assertEqual(stored[3], -17592186044416)
        self.assertEqual(stored[4], False)
        self.assertEqual(stored[5], False)
        self.assertEqual(stored[6], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                None,
                -17592186044416,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                None,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                NoBool(),
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

    def test_idv3f_Q_Q_q_Z_Z_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 2, b"Q")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 3, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 4, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 5, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_Q_Q_q_Z_Z_id_, 6, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv3f:Q:Q:q:Z:Z:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], 35184372088832)
        self.assertEqual(stored[3], -17592186044416)
        self.assertEqual(stored[4], False)
        self.assertEqual(stored[5], False)
        self.assertEqual(stored[6], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                None,
                -17592186044416,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                None,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                NoBool(),
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

    def test_clsidv3f_Q_Q_q_Z_Z_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 2, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 3, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 4, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 5, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Q_Q_q_Z_Z_id_, 6, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv3f:Q:Q:q:Z:Z:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], 35184372088832)
        self.assertEqual(stored[3], -17592186044416)
        self.assertEqual(stored[4], False)
        self.assertEqual(stored[5], False)
        self.assertEqual(stored[6], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                None,
                -17592186044416,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                None,
                False,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                NoBool(),
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            )

    def test_imp_idv3f_Q_Q_q_Z_Z_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fQQqZZidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fQQqZZidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fQQqZZidOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv3f_Q_Q_q_Z_Z_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fQQqZZidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                False,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fQQqZZidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fQQqZZidOn_(value)
        finally:
            del value.returnInvalid

    def test_idv3f_Z_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_Z_q_id_, 1, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_Z_q_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_Z_q_id_, 3, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv3f_Z_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0), False, -17592186044416, "hello"
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], False)
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), False, -17592186044416)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False, -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), False, None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0), False, -17592186044416, "hello"
            )

    def test_clsidv3f_Z_q_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Z_q_id_, 1, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Z_q_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Z_q_id_, 3, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv3f_Z_q_id_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0), False, -17592186044416, "hello"
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], False)
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), False, -17592186044416)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False, -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), False, None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0), False, -17592186044416, "hello"
            )

    def test_idv3f_Z_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv3f_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv3f_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv3f_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idv3f_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.idv3f_Z_q_id_, 1, b"Z")
        self.assertArgHasType(OC_VectorCall.idv3f_Z_q_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.idv3f_Z_q_id_, 3, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv3f:Z:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0), False, -17592186044416, "hello"
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], False)
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), False, -17592186044416)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False, -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), False, None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0), False, -17592186044416, "hello"
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                False,
                -17592186044416,
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                False,
                -17592186044416,
                "hello",
            )

    def test_clsidv3f_Z_q_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv3f_Z_q_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv3f_Z_q_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv3f_Z_q_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Z_q_id_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Z_q_id_, 1, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Z_q_id_, 2, b"q")
        self.assertArgHasType(OC_VectorCall.clsidv3f_Z_q_id_, 3, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv3f:Z:q:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0), False, -17592186044416, "hello"
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            False,
            -17592186044416,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], False)
        self.assertEqual(stored[2], -17592186044416)
        self.assertEqual(stored[3], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), False, -17592186044416)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                False,
                -17592186044416,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False, -17592186044416, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                NoBool(),
                -17592186044416,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), False, None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                False,
                -17592186044416,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0), False, -17592186044416, "hello"
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                False,
                -17592186044416,
                "hello",
            )

    def test_imp_idv3f_Z_q_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fZqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                False,
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fZqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fZqidOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv3f_Z_q_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv3fZqidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                False,
                -17592186044416,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv3fZqidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv3fZqidOn_(value)
        finally:
            del value.returnInvalid

    def test_idv4f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv4f_, b"@")
        self.assertArgHasType(OC_VectorCall.idv4f_, 0, b"<4f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idv4f_

        # Valid call
        rv = caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_clsidv4f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv4f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv4f_, 0, b"<4f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidv4f_

        # Valid call
        rv = caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_idv4f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idv4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idv4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idv4f_, b"@")
        self.assertArgHasType(OC_VectorCall.idv4f_, 0, b"<4f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idv4f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_clsidv4f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidv4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidv4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidv4f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidv4f_, 0, b"<4f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidv4f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_imp_idv4f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv4fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues, (objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),)
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv4fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv4fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idv4f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idv4fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues, (objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),)
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idv4fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idv4fOn_(value)
        finally:
            del value.returnInvalid

    def test_idid_v2d_v2d_v2i_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_v2d_v2d_v2i_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_v2d_v2d_v2i_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_v2d_v2d_v2i_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v2d_v2d_v2i_Z_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v2d_v2d_v2i_Z_, 1, b"<2d>")
        self.assertArgHasType(OC_VectorCall.idid_v2d_v2d_v2i_Z_, 2, b"<2d>")
        self.assertArgHasType(OC_VectorCall.idid_v2d_v2d_v2i_Z_, 3, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idid_v2d_v2d_v2i_Z_, 4, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_v2d_v2d_v2i_Z_

        # Valid call
        rv = caller(
            "hello",
            objc.simd.vector_double2(0.0, 1.5),
            objc.simd.vector_double2(0.0, 1.5),
            objc.simd.vector_int2(0, 1),
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[4], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                None,
                objc.simd.vector_int2(0, 1),
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                None,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

    def test_clsidid_v2d_v2d_v2i_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_, 1, b"<2d>")
        self.assertArgHasType(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_, 2, b"<2d>")
        self.assertArgHasType(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_, 3, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_, 4, b"Z")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_v2d_v2d_v2i_Z_

        # Valid call
        rv = caller(
            "hello",
            objc.simd.vector_double2(0.0, 1.5),
            objc.simd.vector_double2(0.0, 1.5),
            objc.simd.vector_int2(0, 1),
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[4], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                None,
                objc.simd.vector_int2(0, 1),
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                None,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

    def test_idid_v2d_v2d_v2i_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_v2d_v2d_v2i_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_v2d_v2d_v2i_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_v2d_v2d_v2i_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v2d_v2d_v2i_Z_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v2d_v2d_v2i_Z_, 1, b"<2d>")
        self.assertArgHasType(OC_VectorCall.idid_v2d_v2d_v2i_Z_, 2, b"<2d>")
        self.assertArgHasType(OC_VectorCall.idid_v2d_v2d_v2i_Z_, 3, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idid_v2d_v2d_v2i_Z_, 4, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:v2d:v2d:v2i:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            objc.simd.vector_double2(0.0, 1.5),
            objc.simd.vector_double2(0.0, 1.5),
            objc.simd.vector_int2(0, 1),
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[4], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                None,
                objc.simd.vector_int2(0, 1),
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                None,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

    def test_clsidid_v2d_v2d_v2i_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_, 1, b"<2d>")
        self.assertArgHasType(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_, 2, b"<2d>")
        self.assertArgHasType(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_, 3, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidid_v2d_v2d_v2i_Z_, 4, b"Z")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:v2d:v2d:v2i:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            objc.simd.vector_double2(0.0, 1.5),
            objc.simd.vector_double2(0.0, 1.5),
            objc.simd.vector_int2(0, 1),
            False,
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            objc.simd.vector_double2(0.0, 1.5),
            objc.simd.vector_double2(0.0, 1.5),
            objc.simd.vector_int2(0, 1),
            False,
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            objc.simd.vector_double2(0.0, 1.5),
            objc.simd.vector_double2(0.0, 1.5),
            objc.simd.vector_int2(0, 1),
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[4], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                None,
                objc.simd.vector_int2(0, 1),
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                None,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            )

    def test_imp_idid_v2d_v2d_v2i_Z_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididv2dv2dv2iZOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididv2dv2dv2iZOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididv2dv2dv2iZOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_v2d_v2d_v2i_Z__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididv2dv2dv2iZOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_double2(0.0, 1.5),
                objc.simd.vector_int2(0, 1),
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididv2dv2dv2iZOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididv2dv2dv2iZOn_(value)
        finally:
            del value.returnInvalid

    def test_idid_v2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v2f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v2f_, 1, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_v2f_

        # Valid call
        rv = caller("hello", objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", objc.simd.vector_float2(0.0, 1.5))

    def test_clsidid_v2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v2f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v2f_, 1, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_v2f_

        # Valid call
        rv = caller("hello", objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", objc.simd.vector_float2(0.0, 1.5))

    def test_idid_v2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v2f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v2f_, 1, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:v2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", objc.simd.vector_float2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, "hello", objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, "hello", objc.simd.vector_float2(0.0, 1.5))

    def test_clsidid_v2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v2f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v2f_, 1, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:v2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, "hello", objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), "hello", objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", objc.simd.vector_float2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, "hello", objc.simd.vector_float2(0.0, 1.5))

    def test_imp_idid_v2f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididv2fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_v2f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididv2fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_idid_v3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_v3f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v3f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v3f_, 1, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_v3f_

        # Valid call
        rv = caller("hello", objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_clsidid_v3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_v3f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v3f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v3f_, 1, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_v3f_

        # Valid call
        rv = caller("hello", objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_idid_v3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_v3f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v3f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v3f_, 1, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:v3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, "hello", objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, "hello", objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_clsidid_v3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_v3f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v3f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v3f_, 1, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:v3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, "hello", objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), "hello", objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, "hello", objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_imp_idid_v3f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididv3fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_v3f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididv3fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_idid_v4f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_v4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_v4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_v4f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v4f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v4f_, 1, b"<4f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_v4f_

        # Valid call
        rv = caller("hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_clsidid_v4f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_v4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_v4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_v4f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v4f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v4f_, 1, b"<4f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_v4f_

        # Valid call
        rv = caller("hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_idid_v4f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_v4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_v4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_v4f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v4f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_v4f_, 1, b"<4f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:v4f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, "hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, "hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_clsidid_v4f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_v4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_v4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_v4f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v4f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_v4f_, 1, b"<4f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:v4f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, "hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), "hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, "hello", objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_imp_idid_v4f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididv4fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididv4fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididv4fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_v4f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididv4fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididv4fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididv4fOn_(value)
        finally:
            del value.returnInvalid

    def test_idid_id_v2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_id_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_id_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_id_v2i_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_, 2, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_id_v2i_

        # Valid call
        rv = caller("hello", "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", NoObjCValueObject, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", "hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1))

    def test_clsidid_id_v2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_id_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_id_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_id_v2i_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_, 2, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_id_v2i_

        # Valid call
        rv = caller("hello", "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", NoObjCValueObject, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", "hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1))

    def test_idid_id_v2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_id_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_id_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_id_v2i_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_, 2, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:id:v2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", NoObjCValueObject, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", "hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, "hello", "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, "hello", "hello", objc.simd.vector_int2(0, 1))

    def test_clsidid_id_v2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_id_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_id_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_id_v2i_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_, 2, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:id:v2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, "hello", "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), "hello", "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", NoObjCValueObject, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", "hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, "hello", "hello", objc.simd.vector_int2(0, 1))

    def test_imp_idid_id_v2i_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idididv2iOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                "hello",
                objc.simd.vector_int2(0, 1),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idididv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idididv2iOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_id_v2i__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idididv2iOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                "hello",
                objc.simd.vector_int2(0, 1),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idididv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idididv2iOn_(value)
        finally:
            del value.returnInvalid

    def test_idid_id_v2i_f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_id_v2i_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_id_v2i_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_id_v2i_f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_f_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_f_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_f_, 3, b"f")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_id_v2i_f_

        # Valid call
        rv = caller("hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject, "hello", objc.simd.vector_int2(0, 1), 2500000000.0
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello", NoObjCValueObject, objc.simd.vector_int2(0, 1), 2500000000.0
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", "hello", None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0)

    def test_clsidid_id_v2i_f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_id_v2i_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_id_v2i_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_id_v2i_f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_f_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_f_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_f_, 3, b"f")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_id_v2i_f_

        # Valid call
        rv = caller("hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject, "hello", objc.simd.vector_int2(0, 1), 2500000000.0
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello", NoObjCValueObject, objc.simd.vector_int2(0, 1), 2500000000.0
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", "hello", None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0)

    def test_idid_id_v2i_f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_id_v2i_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_id_v2i_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_id_v2i_f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_f_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_f_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idid_id_v2i_f_, 3, b"f")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:id:v2i:f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject, "hello", objc.simd.vector_int2(0, 1), 2500000000.0
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello", NoObjCValueObject, objc.simd.vector_int2(0, 1), 2500000000.0
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", "hello", None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, "hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                "hello",
                objc.simd.vector_int2(0, 1),
                2500000000.0,
            )

    def test_clsidid_id_v2i_f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_id_v2i_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_id_v2i_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_id_v2i_f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_f_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_f_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidid_id_v2i_f_, 3, b"f")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:id:v2i:f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0)
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, "hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0)
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), "hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject, "hello", objc.simd.vector_int2(0, 1), 2500000000.0
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello", NoObjCValueObject, objc.simd.vector_int2(0, 1), 2500000000.0
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", "hello", None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, "hello", "hello", objc.simd.vector_int2(0, 1), 2500000000.0)

    def test_imp_idid_id_v2i_f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idididv2ifOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                "hello",
                objc.simd.vector_int2(0, 1),
                2500000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idididv2ifOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idididv2ifOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_id_v2i_f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idididv2ifOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                "hello",
                objc.simd.vector_int2(0, 1),
                2500000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idididv2ifOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idididv2ifOn_(value)
        finally:
            del value.returnInvalid

    def test_idid_Q_v2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_Q_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_Q_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_Q_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_v2f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_v2f_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.idid_Q_v2f_, 2, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_Q_v2f_

        # Valid call
        rv = caller("hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, 35184372088832, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5))

    def test_clsidid_Q_v2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_Q_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_Q_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_Q_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v2f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v2f_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v2f_, 2, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_Q_v2f_

        # Valid call
        rv = caller("hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, 35184372088832, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5))

    def test_idid_Q_v2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_Q_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_Q_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_Q_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_v2f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_v2f_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.idid_Q_v2f_, 2, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:Q:v2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, 35184372088832, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, "hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                35184372088832,
                objc.simd.vector_float2(0.0, 1.5),
            )

    def test_clsidid_Q_v2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_Q_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_Q_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_Q_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v2f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v2f_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v2f_, 2, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:Q:v2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, "hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), "hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, 35184372088832, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, "hello", 35184372088832, objc.simd.vector_float2(0.0, 1.5))

    def test_imp_idid_Q_v2f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididQv2fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                35184372088832,
                objc.simd.vector_float2(0.0, 1.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididQv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididQv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_Q_v2f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididQv2fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                35184372088832,
                objc.simd.vector_float2(0.0, 1.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididQv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididQv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_idid_Q_v3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_Q_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_Q_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_Q_v3f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_v3f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_v3f_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.idid_Q_v3f_, 2, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_Q_v3f_

        # Valid call
        rv = caller("hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0), "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                35184372088832,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_clsidid_Q_v3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_Q_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_Q_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_Q_v3f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v3f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v3f_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v3f_, 2, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_Q_v3f_

        # Valid call
        rv = caller("hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0), "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                35184372088832,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_idid_Q_v3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_Q_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_Q_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_Q_v3f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_v3f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_v3f_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.idid_Q_v3f_, 2, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:Q:v3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0), "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                35184372088832,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, "hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                35184372088832,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

    def test_clsidid_Q_v3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_Q_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_Q_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_Q_v3f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v3f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v3f_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v3f_, 2, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:Q:v3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst, "hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0)
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc), "hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0)
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0), "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                35184372088832,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, "hello", 35184372088832, objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_imp_idid_Q_v3f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididQv3fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                35184372088832,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididQv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididQv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_Q_v3f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididQv3fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                35184372088832,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididQv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididQv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_idid_Q_v4f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_Q_v4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_Q_v4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_Q_v4f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_v4f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_v4f_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.idid_Q_v4f_, 2, b"<4f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_Q_v4f_

        # Valid call
        rv = caller(
            "hello", 35184372088832, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                35184372088832,
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                35184372088832,
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", 35184372088832, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_clsidid_Q_v4f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_Q_v4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_Q_v4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_Q_v4f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v4f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v4f_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v4f_, 2, b"<4f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_Q_v4f_

        # Valid call
        rv = caller(
            "hello", 35184372088832, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                35184372088832,
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                35184372088832,
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", 35184372088832, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_idid_Q_v4f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_Q_v4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_Q_v4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_Q_v4f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_v4f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_v4f_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.idid_Q_v4f_, 2, b"<4f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:Q:v4f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello", 35184372088832, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                35184372088832,
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                35184372088832,
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", 35184372088832, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42, "hello", 35184372088832, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                35184372088832,
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            )

    def test_clsidid_Q_v4f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_Q_v4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_Q_v4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_Q_v4f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v4f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v4f_, 1, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_v4f_, 2, b"<4f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:Q:v4f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello", 35184372088832, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            35184372088832,
            objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            35184372088832,
            objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(stored[2], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                35184372088832,
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                35184372088832,
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", 35184372088832, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42, "hello", 35184372088832, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)
            )

    def test_imp_idid_Q_v4f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididQv4fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                35184372088832,
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididQv4fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididQv4fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_Q_v4f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididQv4fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                35184372088832,
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididQv4fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididQv4fOn_(value)
        finally:
            del value.returnInvalid

    def test_idid_Q_simdfloat4x4_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_Q_simdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_Q_simdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_Q_simdfloat4x4_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_simdfloat4x4_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_simdfloat4x4_, 1, b"Q")
        self.assertArgHasType(
            OC_VectorCall.idid_Q_simdfloat4x4_, 2, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_Q_simdfloat4x4_

        # Valid call
        rv = caller(
            "hello",
            35184372088832,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(
            stored[2],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_clsidid_Q_simdfloat4x4_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_Q_simdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_Q_simdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_Q_simdfloat4x4_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_simdfloat4x4_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_simdfloat4x4_, 1, b"Q")
        self.assertArgHasType(
            OC_VectorCall.clsidid_Q_simdfloat4x4_, 2, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_Q_simdfloat4x4_

        # Valid call
        rv = caller(
            "hello",
            35184372088832,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(
            stored[2],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_idid_Q_simdfloat4x4__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_Q_simdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_Q_simdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_Q_simdfloat4x4_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_simdfloat4x4_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Q_simdfloat4x4_, 1, b"Q")
        self.assertArgHasType(
            OC_VectorCall.idid_Q_simdfloat4x4_, 2, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:Q:simdfloat4x4:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            35184372088832,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(
            stored[2],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_clsidid_Q_simdfloat4x4__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_Q_simdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_Q_simdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_Q_simdfloat4x4_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_simdfloat4x4_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Q_simdfloat4x4_, 1, b"Q")
        self.assertArgHasType(
            OC_VectorCall.clsidid_Q_simdfloat4x4_, 2, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:Q:simdfloat4x4:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            35184372088832,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            35184372088832,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            35184372088832,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], 35184372088832)
        self.assertEqual(
            stored[2],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", 35184372088832)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", 35184372088832, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_imp_idid_Q_simdfloat4x4_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididQsimdfloat4x4On_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididQsimdfloat4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididQsimdfloat4x4On_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_Q_simdfloat4x4__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididQsimdfloat4x4On_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                35184372088832,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididQsimdfloat4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididQsimdfloat4x4On_(value)
        finally:
            del value.returnInvalid

    def test_idid_Z_id_v2i_q_Q_q_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 1, b"Z")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 3, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 5, b"Q")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 6, b"q")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 7, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_Z_id_v2i_q_Q_q_Z_

        # Valid call
        rv = caller(
            "hello",
            False,
            "hello",
            objc.simd.vector_int2(0, 1),
            -17592186044416,
            35184372088832,
            -17592186044416,
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 8)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], False)
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], 35184372088832)
        self.assertEqual(stored[6], -17592186044416)
        self.assertEqual(stored[7], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                NoBool(),
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                None,
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                None,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                None,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                None,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

    def test_clsidid_Z_id_v2i_q_Q_q_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 1, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 3, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 5, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 6, b"q")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 7, b"Z")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_Z_id_v2i_q_Q_q_Z_

        # Valid call
        rv = caller(
            "hello",
            False,
            "hello",
            objc.simd.vector_int2(0, 1),
            -17592186044416,
            35184372088832,
            -17592186044416,
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 8)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], False)
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], 35184372088832)
        self.assertEqual(stored[6], -17592186044416)
        self.assertEqual(stored[7], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                NoBool(),
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                None,
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                None,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                None,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                None,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

    def test_idid_Z_id_v2i_q_Q_q_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 1, b"Z")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 3, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 5, b"Q")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 6, b"q")
        self.assertArgHasType(OC_VectorCall.idid_Z_id_v2i_q_Q_q_Z_, 7, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:Z:id:v2i:q:Q:q:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            False,
            "hello",
            objc.simd.vector_int2(0, 1),
            -17592186044416,
            35184372088832,
            -17592186044416,
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 8)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], False)
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], 35184372088832)
        self.assertEqual(stored[6], -17592186044416)
        self.assertEqual(stored[7], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                NoBool(),
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                None,
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                None,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                None,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                None,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

    def test_clsidid_Z_id_v2i_q_Q_q_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 1, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 3, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 5, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 6, b"q")
        self.assertArgHasType(OC_VectorCall.clsidid_Z_id_v2i_q_Q_q_Z_, 7, b"Z")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:Z:id:v2i:q:Q:q:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            False,
            "hello",
            objc.simd.vector_int2(0, 1),
            -17592186044416,
            35184372088832,
            -17592186044416,
            False,
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            False,
            "hello",
            objc.simd.vector_int2(0, 1),
            -17592186044416,
            35184372088832,
            -17592186044416,
            False,
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            False,
            "hello",
            objc.simd.vector_int2(0, 1),
            -17592186044416,
            35184372088832,
            -17592186044416,
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 8)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], False)
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], 35184372088832)
        self.assertEqual(stored[6], -17592186044416)
        self.assertEqual(stored[7], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                NoBool(),
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                None,
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                None,
                35184372088832,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                None,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                None,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            )

    def test_imp_idid_Z_id_v2i_q_Q_q_Z_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididZidv2iqQqZOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididZidv2iqQqZOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididZidv2iqQqZOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_Z_id_v2i_q_Q_q_Z__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididZidv2iqQqZOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                False,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                35184372088832,
                -17592186044416,
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididZidv2iqQqZOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididZidv2iqQqZOn_(value)
        finally:
            del value.returnInvalid

    def test_idid_q_v2i_f_f_f_f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_q_v2i_f_f_f_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_q_v2i_f_f_f_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 1, b"q")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 3, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 4, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 5, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 6, b"f")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_q_v2i_f_f_f_f_

        # Valid call
        rv = caller(
            "hello",
            -17592186044416,
            objc.simd.vector_int2(0, 1),
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], -17592186044416)
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], 2500000000.0)
        self.assertEqual(stored[4], 2500000000.0)
        self.assertEqual(stored[5], 2500000000.0)
        self.assertEqual(stored[6], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                None,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                None,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

    def test_clsidid_q_v2i_f_f_f_f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_q_v2i_f_f_f_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_q_v2i_f_f_f_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 1, b"q")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 3, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 4, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 5, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 6, b"f")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_q_v2i_f_f_f_f_

        # Valid call
        rv = caller(
            "hello",
            -17592186044416,
            objc.simd.vector_int2(0, 1),
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], -17592186044416)
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], 2500000000.0)
        self.assertEqual(stored[4], 2500000000.0)
        self.assertEqual(stored[5], 2500000000.0)
        self.assertEqual(stored[6], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                None,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                None,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

    def test_idid_q_v2i_f_f_f_f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_q_v2i_f_f_f_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_q_v2i_f_f_f_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 1, b"q")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 3, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 4, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 5, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_, 6, b"f")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:q:v2i:f:f:f:f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            -17592186044416,
            objc.simd.vector_int2(0, 1),
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], -17592186044416)
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], 2500000000.0)
        self.assertEqual(stored[4], 2500000000.0)
        self.assertEqual(stored[5], 2500000000.0)
        self.assertEqual(stored[6], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                None,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                None,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

    def test_clsidid_q_v2i_f_f_f_f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_q_v2i_f_f_f_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_q_v2i_f_f_f_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 1, b"q")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 3, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 4, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 5, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_, 6, b"f")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:q:v2i:f:f:f:f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            -17592186044416,
            objc.simd.vector_int2(0, 1),
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            -17592186044416,
            objc.simd.vector_int2(0, 1),
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            -17592186044416,
            objc.simd.vector_int2(0, 1),
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], -17592186044416)
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], 2500000000.0)
        self.assertEqual(stored[4], 2500000000.0)
        self.assertEqual(stored[5], 2500000000.0)
        self.assertEqual(stored[6], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                None,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                None,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

    def test_imp_idid_q_v2i_f_f_f_f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididqv2iffffOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididqv2iffffOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididqv2iffffOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_q_v2i_f_f_f_f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididqv2iffffOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididqv2iffffOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididqv2iffffOn_(value)
        finally:
            del value.returnInvalid

    def test_idid_q_v2i_f_f_f_f_f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_q_v2i_f_f_f_f_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_q_v2i_f_f_f_f_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 1, b"q")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 3, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 4, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 5, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 6, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 7, b"f")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_q_v2i_f_f_f_f_f_

        # Valid call
        rv = caller(
            "hello",
            -17592186044416,
            objc.simd.vector_int2(0, 1),
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 8)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], -17592186044416)
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], 2500000000.0)
        self.assertEqual(stored[4], 2500000000.0)
        self.assertEqual(stored[5], 2500000000.0)
        self.assertEqual(stored[6], 2500000000.0)
        self.assertEqual(stored[7], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                None,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                None,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

    def test_clsidid_q_v2i_f_f_f_f_f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 1, b"q")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 3, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 4, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 5, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 6, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 7, b"f")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_q_v2i_f_f_f_f_f_

        # Valid call
        rv = caller(
            "hello",
            -17592186044416,
            objc.simd.vector_int2(0, 1),
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 8)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], -17592186044416)
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], 2500000000.0)
        self.assertEqual(stored[4], 2500000000.0)
        self.assertEqual(stored[5], 2500000000.0)
        self.assertEqual(stored[6], 2500000000.0)
        self.assertEqual(stored[7], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                None,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                None,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

    def test_idid_q_v2i_f_f_f_f_f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_q_v2i_f_f_f_f_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_q_v2i_f_f_f_f_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 1, b"q")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 3, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 4, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 5, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 6, b"f")
        self.assertArgHasType(OC_VectorCall.idid_q_v2i_f_f_f_f_f_, 7, b"f")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:q:v2i:f:f:f:f:f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            -17592186044416,
            objc.simd.vector_int2(0, 1),
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 8)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], -17592186044416)
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], 2500000000.0)
        self.assertEqual(stored[4], 2500000000.0)
        self.assertEqual(stored[5], 2500000000.0)
        self.assertEqual(stored[6], 2500000000.0)
        self.assertEqual(stored[7], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                None,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                None,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

    def test_clsidid_q_v2i_f_f_f_f_f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 1, b"q")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 3, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 4, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 5, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 6, b"f")
        self.assertArgHasType(OC_VectorCall.clsidid_q_v2i_f_f_f_f_f_, 7, b"f")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:q:v2i:f:f:f:f:f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            -17592186044416,
            objc.simd.vector_int2(0, 1),
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            -17592186044416,
            objc.simd.vector_int2(0, 1),
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            -17592186044416,
            objc.simd.vector_int2(0, 1),
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 8)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], -17592186044416)
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], 2500000000.0)
        self.assertEqual(stored[4], 2500000000.0)
        self.assertEqual(stored[5], 2500000000.0)
        self.assertEqual(stored[6], 2500000000.0)
        self.assertEqual(stored[7], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                None,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                None,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                None,
                2500000000.0,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                None,
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            )

    def test_imp_idid_q_v2i_f_f_f_f_f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididqv2ifffffOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididqv2ifffffOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididqv2ifffffOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_q_v2i_f_f_f_f_f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididqv2ifffffOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                -17592186044416,
                objc.simd.vector_int2(0, 1),
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
                2500000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididqv2ifffffOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididqv2ifffffOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_idid_GKBox_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_GKBox_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_GKBox_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_GKBox_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_GKBox_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_GKBox_, 1, b"{GKBox=<3f><3f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_GKBox_

        # Valid call
        rv = caller(
            "hello",
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

    @min_os_level("10.12")
    def test_clsidid_GKBox_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_GKBox_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_GKBox_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_GKBox_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_GKBox_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_GKBox_, 1, b"{GKBox=<3f><3f>}")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_GKBox_

        # Valid call
        rv = caller(
            "hello",
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

    @min_os_level("10.12")
    def test_idid_GKBox__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_GKBox_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_GKBox_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_GKBox_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_GKBox_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_GKBox_, 1, b"{GKBox=<3f><3f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:GKBox:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

    @min_os_level("10.12")
    def test_clsidid_GKBox__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_GKBox_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_GKBox_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_GKBox_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_GKBox_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_GKBox_, 1, b"{GKBox=<3f><3f>}")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:GKBox:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

    @min_os_level("10.12")
    def test_imp_idid_GKBox_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididGKBoxOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididGKBoxOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididGKBoxOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_imp_idid_GKBox__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididGKBoxOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididGKBoxOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididGKBoxOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_idid_GKQuad_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_GKQuad_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_GKQuad_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_GKQuad_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_GKQuad_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_GKQuad_, 1, b"{GKQuad=<2f><2f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_GKQuad_

        # Valid call
        rv = caller(
            "hello",
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

    @min_os_level("10.12")
    def test_clsidid_GKQuad_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_GKQuad_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_GKQuad_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_GKQuad_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_GKQuad_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_GKQuad_, 1, b"{GKQuad=<2f><2f>}")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_GKQuad_

        # Valid call
        rv = caller(
            "hello",
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

    @min_os_level("10.12")
    def test_idid_GKQuad__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_GKQuad_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_GKQuad_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_GKQuad_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_GKQuad_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_GKQuad_, 1, b"{GKQuad=<2f><2f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:GKQuad:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

    @min_os_level("10.12")
    def test_clsidid_GKQuad__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_GKQuad_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_GKQuad_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_GKQuad_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_GKQuad_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_GKQuad_, 1, b"{GKQuad=<2f><2f>}")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:GKQuad:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

    @min_os_level("10.12")
    def test_imp_idid_GKQuad_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididGKQuadOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididGKQuadOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididGKQuadOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_imp_idid_GKQuad__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididGKQuadOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididGKQuadOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididGKQuadOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_idid_MDLAxisAlignedBoundingBox_f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_MDLAxisAlignedBoundingBox_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_MDLAxisAlignedBoundingBox_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_MDLAxisAlignedBoundingBox_f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_MDLAxisAlignedBoundingBox_f_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.idid_MDLAxisAlignedBoundingBox_f_,
            1,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(OC_VectorCall.idid_MDLAxisAlignedBoundingBox_f_, 2, b"f")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_MDLAxisAlignedBoundingBox_f_

        # Valid call
        rv = caller(
            "hello",
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertEqual(stored[2], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
            )

    @min_os_level("10.11")
    def test_clsidid_MDLAxisAlignedBoundingBox_f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(
            OC_VectorCall.clsidid_MDLAxisAlignedBoundingBox_f_.isClassMethod
        )
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_MDLAxisAlignedBoundingBox_f_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsidid_MDLAxisAlignedBoundingBox_f_, b"@"
        )
        self.assertArgHasType(
            OC_VectorCall.clsidid_MDLAxisAlignedBoundingBox_f_, 0, b"@"
        )
        self.assertArgHasType(
            OC_VectorCall.clsidid_MDLAxisAlignedBoundingBox_f_,
            1,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(
            OC_VectorCall.clsidid_MDLAxisAlignedBoundingBox_f_, 2, b"f"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_MDLAxisAlignedBoundingBox_f_

        # Valid call
        rv = caller(
            "hello",
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertEqual(stored[2], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
            )

    @min_os_level("10.11")
    def test_idid_MDLAxisAlignedBoundingBox_f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_MDLAxisAlignedBoundingBox_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_MDLAxisAlignedBoundingBox_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_MDLAxisAlignedBoundingBox_f_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_MDLAxisAlignedBoundingBox_f_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.idid_MDLAxisAlignedBoundingBox_f_,
            1,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(OC_VectorCall.idid_MDLAxisAlignedBoundingBox_f_, 2, b"f")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:MDLAxisAlignedBoundingBox:f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertEqual(stored[2], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
            )

    @min_os_level("10.11")
    def test_clsidid_MDLAxisAlignedBoundingBox_f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(
            OC_VectorCall.clsidid_MDLAxisAlignedBoundingBox_f_.isClassMethod
        )
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_MDLAxisAlignedBoundingBox_f_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsidid_MDLAxisAlignedBoundingBox_f_, b"@"
        )
        self.assertArgHasType(
            OC_VectorCall.clsidid_MDLAxisAlignedBoundingBox_f_, 0, b"@"
        )
        self.assertArgHasType(
            OC_VectorCall.clsidid_MDLAxisAlignedBoundingBox_f_,
            1,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(
            OC_VectorCall.clsidid_MDLAxisAlignedBoundingBox_f_, 2, b"f"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:MDLAxisAlignedBoundingBox:f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertEqual(stored[2], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
            )

    @min_os_level("10.11")
    def test_imp_idid_MDLAxisAlignedBoundingBox_f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididMDLAxisAlignedBoundingBoxfOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididMDLAxisAlignedBoundingBoxfOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididMDLAxisAlignedBoundingBoxfOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_imp_idid_MDLAxisAlignedBoundingBox_f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididMDLAxisAlignedBoundingBoxfOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                2500000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididMDLAxisAlignedBoundingBoxfOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididMDLAxisAlignedBoundingBoxfOn_(value)
        finally:
            del value.returnInvalid

    def test_idid_simdfloat2x2_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_simdfloat2x2_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_simdfloat2x2_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_simdfloat2x2_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdfloat2x2_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.idid_simdfloat2x2_, 1, b"{simd_float2x2=[2<2f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_simdfloat2x2_

        # Valid call
        rv = caller(
            "hello",
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

    def test_clsidid_simdfloat2x2_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_simdfloat2x2_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_simdfloat2x2_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_simdfloat2x2_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_simdfloat2x2_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidid_simdfloat2x2_, 1, b"{simd_float2x2=[2<2f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_simdfloat2x2_

        # Valid call
        rv = caller(
            "hello",
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

    def test_idid_simdfloat2x2__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_simdfloat2x2_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_simdfloat2x2_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_simdfloat2x2_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdfloat2x2_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.idid_simdfloat2x2_, 1, b"{simd_float2x2=[2<2f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:simdfloat2x2:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

    def test_clsidid_simdfloat2x2__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_simdfloat2x2_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_simdfloat2x2_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_simdfloat2x2_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_simdfloat2x2_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidid_simdfloat2x2_, 1, b"{simd_float2x2=[2<2f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:simdfloat2x2:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

    def test_imp_idid_simdfloat2x2_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididsimdfloat2x2On_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididsimdfloat2x2On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididsimdfloat2x2On_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_simdfloat2x2__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididsimdfloat2x2On_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididsimdfloat2x2On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididsimdfloat2x2On_(value)
        finally:
            del value.returnInvalid

    def test_idid_simdfloat3x3_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_simdfloat3x3_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_simdfloat3x3_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_simdfloat3x3_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdfloat3x3_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.idid_simdfloat3x3_, 1, b"{simd_float3x3=[3<3f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_simdfloat3x3_

        # Valid call
        rv = caller(
            "hello",
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

    def test_clsidid_simdfloat3x3_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_simdfloat3x3_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_simdfloat3x3_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_simdfloat3x3_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_simdfloat3x3_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidid_simdfloat3x3_, 1, b"{simd_float3x3=[3<3f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_simdfloat3x3_

        # Valid call
        rv = caller(
            "hello",
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

    def test_idid_simdfloat3x3__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_simdfloat3x3_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_simdfloat3x3_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_simdfloat3x3_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdfloat3x3_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.idid_simdfloat3x3_, 1, b"{simd_float3x3=[3<3f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:simdfloat3x3:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

    def test_clsidid_simdfloat3x3__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_simdfloat3x3_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_simdfloat3x3_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_simdfloat3x3_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_simdfloat3x3_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidid_simdfloat3x3_, 1, b"{simd_float3x3=[3<3f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:simdfloat3x3:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

    def test_imp_idid_simdfloat3x3_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididsimdfloat3x3On_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididsimdfloat3x3On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididsimdfloat3x3On_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_simdfloat3x3__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididsimdfloat3x3On_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididsimdfloat3x3On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididsimdfloat3x3On_(value)
        finally:
            del value.returnInvalid

    def test_idid_simdfloat4x4_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_simdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_simdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_simdfloat4x4_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdfloat4x4_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.idid_simdfloat4x4_, 1, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_simdfloat4x4_

        # Valid call
        rv = caller(
            "hello",
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_clsidid_simdfloat4x4_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_simdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_simdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_simdfloat4x4_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_simdfloat4x4_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidid_simdfloat4x4_, 1, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_simdfloat4x4_

        # Valid call
        rv = caller(
            "hello",
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_idid_simdfloat4x4__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_simdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_simdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_simdfloat4x4_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdfloat4x4_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.idid_simdfloat4x4_, 1, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:simdfloat4x4:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_clsidid_simdfloat4x4__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_simdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_simdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_simdfloat4x4_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_simdfloat4x4_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidid_simdfloat4x4_, 1, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:simdfloat4x4:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_imp_idid_simdfloat4x4_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididsimdfloat4x4On_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididsimdfloat4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididsimdfloat4x4On_(value)
        finally:
            del value.returnInvalid

    def test_imp_idid_simdfloat4x4__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididsimdfloat4x4On_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididsimdfloat4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididsimdfloat4x4On_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_idid_simdquatf_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_simdquatf_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_simdquatf_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_simdquatf_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdquatf_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdquatf_, 1, b"{simd_quatf=<4f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_simdquatf_

        # Valid call
        rv = caller(
            "hello", simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello", simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
            )

    @min_os_level("10.13")
    def test_clsidid_simdquatf_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_simdquatf_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_simdquatf_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_simdquatf_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_simdquatf_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_simdquatf_, 1, b"{simd_quatf=<4f>}")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_simdquatf_

        # Valid call
        rv = caller(
            "hello", simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello", simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
            )

    @min_os_level("10.13")
    def test_idid_simdquatf__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_simdquatf_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_simdquatf_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_simdquatf_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdquatf_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdquatf_, 1, b"{simd_quatf=<4f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:simdquatf:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello", simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello", simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            )

    @min_os_level("10.13")
    def test_clsidid_simdquatf__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_simdquatf_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_simdquatf_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_simdquatf_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_simdquatf_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_simdquatf_, 1, b"{simd_quatf=<4f>}")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:simdquatf:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello", simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello", simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            )

    @min_os_level("10.13")
    def test_imp_idid_simdquatf_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididsimdquatfOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididsimdquatfOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididsimdquatfOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_imp_idid_simdquatf__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididsimdquatfOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididsimdquatfOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididsimdquatfOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_idid_simdquatf_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_simdquatf_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_simdquatf_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_simdquatf_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdquatf_id_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdquatf_id_, 1, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.idid_simdquatf_id_, 2, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idid_simdquatf_id_

        # Valid call
        rv = caller(
            "hello",
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[2], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello", simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

    @min_os_level("10.13")
    def test_clsidid_simdquatf_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_simdquatf_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_simdquatf_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_simdquatf_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_simdquatf_id_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidid_simdquatf_id_, 1, b"{simd_quatf=<4f>}"
        )
        self.assertArgHasType(OC_VectorCall.clsidid_simdquatf_id_, 2, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidid_simdquatf_id_

        # Valid call
        rv = caller(
            "hello",
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[2], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello", simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

    @min_os_level("10.13")
    def test_idid_simdquatf_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idid_simdquatf_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idid_simdquatf_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idid_simdquatf_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdquatf_id_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.idid_simdquatf_id_, 1, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.idid_simdquatf_id_, 2, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idid:simdquatf:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[2], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello", simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

    @min_os_level("10.13")
    def test_clsidid_simdquatf_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidid_simdquatf_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidid_simdquatf_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidid_simdquatf_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidid_simdquatf_id_, 0, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidid_simdquatf_id_, 1, b"{simd_quatf=<4f>}"
        )
        self.assertArgHasType(OC_VectorCall.clsidid_simdquatf_id_, 2, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidid:simdquatf:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(
            stored[1], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[2], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello", simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            )

    @min_os_level("10.13")
    def test_imp_idid_simdquatf_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididsimdquatfidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididsimdquatfidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididsimdquatfidOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_imp_idid_simdquatf_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.ididsimdquatfidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.ididsimdquatfidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.ididsimdquatfidOn_(value)
        finally:
            del value.returnInvalid

    def test_idCGColor_CGColor_id_v2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idCGColor_CGColor_id_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idCGColor_CGColor_id_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idCGColor_CGColor_id_v2i_, b"@")
        self.assertArgHasType(
            OC_VectorCall.idCGColor_CGColor_id_v2i_, 0, b"^{CGColor=}"
        )
        self.assertArgHasType(
            OC_VectorCall.idCGColor_CGColor_id_v2i_, 1, b"^{CGColor=}"
        )
        self.assertArgHasType(OC_VectorCall.idCGColor_CGColor_id_v2i_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.idCGColor_CGColor_id_v2i_, 3, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idCGColor_CGColor_id_v2i_

        # Valid call
        rv = caller("color!", "color!", "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], "color!")
        self.assertEqual(stored[1], "color!")
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("color!", "color!", "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("color!", "color!", "hello", objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, "color!", "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("color!", NoObjCValueObject, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("color!", "color!", NoObjCValueObject, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("color!", "color!", "hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("color!", "color!", "hello", objc.simd.vector_int2(0, 1))

    def test_clsidCGColor_CGColor_id_v2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidCGColor_CGColor_id_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidCGColor_CGColor_id_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidCGColor_CGColor_id_v2i_, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidCGColor_CGColor_id_v2i_, 0, b"^{CGColor=}"
        )
        self.assertArgHasType(
            OC_VectorCall.clsidCGColor_CGColor_id_v2i_, 1, b"^{CGColor=}"
        )
        self.assertArgHasType(OC_VectorCall.clsidCGColor_CGColor_id_v2i_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.clsidCGColor_CGColor_id_v2i_, 3, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidCGColor_CGColor_id_v2i_

        # Valid call
        rv = caller("color!", "color!", "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], "color!")
        self.assertEqual(stored[1], "color!")
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("color!", "color!", "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("color!", "color!", "hello", objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, "color!", "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("color!", NoObjCValueObject, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("color!", "color!", NoObjCValueObject, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("color!", "color!", "hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("color!", "color!", "hello", objc.simd.vector_int2(0, 1))

    def test_idCGColor_CGColor_id_v2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idCGColor_CGColor_id_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idCGColor_CGColor_id_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idCGColor_CGColor_id_v2i_, b"@")
        self.assertArgHasType(
            OC_VectorCall.idCGColor_CGColor_id_v2i_, 0, b"^{CGColor=}"
        )
        self.assertArgHasType(
            OC_VectorCall.idCGColor_CGColor_id_v2i_, 1, b"^{CGColor=}"
        )
        self.assertArgHasType(OC_VectorCall.idCGColor_CGColor_id_v2i_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.idCGColor_CGColor_id_v2i_, 3, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idCGColor:CGColor:id:v2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("color!", "color!", "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], "color!")
        self.assertEqual(stored[1], "color!")
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("color!", "color!", "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("color!", "color!", "hello", objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, "color!", "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("color!", NoObjCValueObject, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("color!", "color!", NoObjCValueObject, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("color!", "color!", "hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("color!", "color!", "hello", objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, "color!", "color!", "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "color!",
                "color!",
                "hello",
                objc.simd.vector_int2(0, 1),
            )

    def test_clsidCGColor_CGColor_id_v2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidCGColor_CGColor_id_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidCGColor_CGColor_id_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidCGColor_CGColor_id_v2i_, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidCGColor_CGColor_id_v2i_, 0, b"^{CGColor=}"
        )
        self.assertArgHasType(
            OC_VectorCall.clsidCGColor_CGColor_id_v2i_, 1, b"^{CGColor=}"
        )
        self.assertArgHasType(OC_VectorCall.clsidCGColor_CGColor_id_v2i_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.clsidCGColor_CGColor_id_v2i_, 3, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidCGColor:CGColor:id:v2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("color!", "color!", "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(oc_inst, "color!", "color!", "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(type(oc), "color!", "color!", "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], "color!")
        self.assertEqual(stored[1], "color!")
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("color!", "color!", "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("color!", "color!", "hello", objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, "color!", "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("color!", NoObjCValueObject, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("color!", "color!", NoObjCValueObject, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller("color!", "color!", "hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("color!", "color!", "hello", objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, "color!", "color!", "hello", objc.simd.vector_int2(0, 1))

    def test_imp_idCGColor_CGColor_id_v2i_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idCGColorCGColoridv2iOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "color!",
                "color!",
                "hello",
                objc.simd.vector_int2(0, 1),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idCGColorCGColoridv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idCGColorCGColoridv2iOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idCGColor_CGColor_id_v2i__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idCGColorCGColoridv2iOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                "color!",
                "color!",
                "hello",
                objc.simd.vector_int2(0, 1),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idCGColorCGColoridv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idCGColorCGColoridv2iOn_(value)
        finally:
            del value.returnInvalid

    def test_idf_v2f_v2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_v2f_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_v2f_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_v2f_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_, 2, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idf_v2f_v2f_

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

    def test_clsidf_v2f_v2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_v2f_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_v2f_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_v2f_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_, 2, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidf_v2f_v2f_

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

    def test_idf_v2f_v2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_v2f_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_v2f_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_v2f_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_, 2, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idf:v2f:v2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

    def test_clsidf_v2f_v2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_v2f_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_v2f_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_v2f_v2f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_, 2, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidf:v2f:v2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

    def test_imp_idf_v2f_v2f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfv2fv2fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfv2fv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfv2fv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idf_v2f_v2f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfv2fv2fOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfv2fv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfv2fv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_idf_v2f_v2f_Class_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_v2f_v2f_Class_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_v2f_v2f_Class_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_v2f_v2f_Class_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_Class_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_Class_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_Class_, 2, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_Class_, 3, b"#")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idf_v2f_v2f_Class_

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
            objc.lookUpClass("NSObject"),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[3], objc.lookUpClass("NSObject"))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                None,
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                None,
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                42,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

    def test_clsidf_v2f_v2f_Class_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_v2f_v2f_Class_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_v2f_v2f_Class_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_v2f_v2f_Class_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_Class_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_Class_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_Class_, 2, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_Class_, 3, b"#")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidf_v2f_v2f_Class_

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
            objc.lookUpClass("NSObject"),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[3], objc.lookUpClass("NSObject"))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                None,
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                None,
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                42,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

    def test_idf_v2f_v2f_Class__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_v2f_v2f_Class_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_v2f_v2f_Class_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_v2f_v2f_Class_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_Class_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_Class_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_Class_, 2, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idf_v2f_v2f_Class_, 3, b"#")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idf:v2f:v2f:Class:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
            objc.lookUpClass("NSObject"),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[3], objc.lookUpClass("NSObject"))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                None,
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                None,
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                42,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

    def test_clsidf_v2f_v2f_Class__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_v2f_v2f_Class_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_v2f_v2f_Class_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_v2f_v2f_Class_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_Class_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_Class_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_Class_, 2, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_v2f_Class_, 3, b"#")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidf:v2f:v2f:Class:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
            objc.lookUpClass("NSObject"),
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
            objc.lookUpClass("NSObject"),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
            objc.lookUpClass("NSObject"),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[3], objc.lookUpClass("NSObject"))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                None,
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                None,
                objc.lookUpClass("NSObject"),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                42,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            )

    def test_imp_idf_v2f_v2f_Class_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfv2fv2fClassOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfv2fv2fClassOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfv2fv2fClassOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idf_v2f_v2f_Class__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfv2fv2fClassOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                objc.lookUpClass("NSObject"),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfv2fv2fClassOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfv2fv2fClassOn_(value)
        finally:
            del value.returnInvalid

    def test_idf_v2f_Q_Q_Q_q_Z_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 2, b"Q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 3, b"Q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 4, b"Q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 5, b"q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 6, b"Z")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 7, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idf_v2f_Q_Q_Q_q_Z_id_

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            35184372088832,
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 8)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], 35184372088832)
        self.assertEqual(stored[3], 35184372088832)
        self.assertEqual(stored[4], 35184372088832)
        self.assertEqual(stored[5], -17592186044416)
        self.assertEqual(stored[6], False)
        self.assertEqual(stored[7], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                None,
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                None,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                None,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                None,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                None,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

    def test_clsidf_v2f_Q_Q_Q_q_Z_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 2, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 3, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 4, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 5, b"q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 6, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 7, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidf_v2f_Q_Q_Q_q_Z_id_

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            35184372088832,
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 8)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], 35184372088832)
        self.assertEqual(stored[3], 35184372088832)
        self.assertEqual(stored[4], 35184372088832)
        self.assertEqual(stored[5], -17592186044416)
        self.assertEqual(stored[6], False)
        self.assertEqual(stored[7], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                None,
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                None,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                None,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                None,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                None,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

    def test_idf_v2f_Q_Q_Q_q_Z_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 2, b"Q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 3, b"Q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 4, b"Q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 5, b"q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 6, b"Z")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_Q_q_Z_id_, 7, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idf:v2f:Q:Q:Q:q:Z:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            35184372088832,
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 8)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], 35184372088832)
        self.assertEqual(stored[3], 35184372088832)
        self.assertEqual(stored[4], 35184372088832)
        self.assertEqual(stored[5], -17592186044416)
        self.assertEqual(stored[6], False)
        self.assertEqual(stored[7], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                None,
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                None,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                None,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                None,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                None,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

    def test_clsidf_v2f_Q_Q_Q_q_Z_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 2, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 3, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 4, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 5, b"q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 6, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_Q_q_Z_id_, 7, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidf:v2f:Q:Q:Q:q:Z:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            35184372088832,
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            35184372088832,
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            35184372088832,
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 8)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], 35184372088832)
        self.assertEqual(stored[3], 35184372088832)
        self.assertEqual(stored[4], 35184372088832)
        self.assertEqual(stored[5], -17592186044416)
        self.assertEqual(stored[6], False)
        self.assertEqual(stored[7], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                None,
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                None,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                None,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                None,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                None,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

    def test_imp_idf_v2f_Q_Q_Q_q_Z_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfv2fQQQqZidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfv2fQQQqZidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfv2fQQQqZidOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idf_v2f_Q_Q_Q_q_Z_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfv2fQQQqZidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfv2fQQQqZidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfv2fQQQqZidOn_(value)
        finally:
            del value.returnInvalid

    def test_idf_v2f_Q_Q_q_Z_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 2, b"Q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 3, b"Q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 5, b"Z")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 6, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idf_v2f_Q_Q_q_Z_id_

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], 35184372088832)
        self.assertEqual(stored[3], 35184372088832)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], False)
        self.assertEqual(stored[6], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                None,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                None,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                None,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                None,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

    def test_clsidf_v2f_Q_Q_q_Z_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 2, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 3, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 5, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 6, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidf_v2f_Q_Q_q_Z_id_

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], 35184372088832)
        self.assertEqual(stored[3], 35184372088832)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], False)
        self.assertEqual(stored[6], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                None,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                None,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                None,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                None,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

    def test_idf_v2f_Q_Q_q_Z_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 2, b"Q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 3, b"Q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 5, b"Z")
        self.assertArgHasType(OC_VectorCall.idf_v2f_Q_Q_q_Z_id_, 6, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idf:v2f:Q:Q:q:Z:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], 35184372088832)
        self.assertEqual(stored[3], 35184372088832)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], False)
        self.assertEqual(stored[6], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                None,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                None,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                None,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                None,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

    def test_clsidf_v2f_Q_Q_q_Z_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 2, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 3, b"Q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 5, b"Z")
        self.assertArgHasType(OC_VectorCall.clsidf_v2f_Q_Q_q_Z_id_, 6, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidf:v2f:Q:Q:q:Z:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            2500000000.0,
            objc.simd.vector_float2(0.0, 1.5),
            35184372088832,
            35184372088832,
            -17592186044416,
            False,
            "hello",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], 35184372088832)
        self.assertEqual(stored[3], 35184372088832)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], False)
        self.assertEqual(stored[6], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                None,
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                None,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                None,
                -17592186044416,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                None,
                False,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                NoBool(),
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            )

    def test_imp_idf_v2f_Q_Q_q_Z_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfv2fQQqZidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfv2fQQqZidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfv2fQQqZidOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idf_v2f_Q_Q_q_Z_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfv2fQQqZidOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                objc.simd.vector_float2(0.0, 1.5),
                35184372088832,
                35184372088832,
                -17592186044416,
                False,
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfv2fQQqZidOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfv2fQQqZidOn_(value)
        finally:
            del value.returnInvalid

    def test_idf_id_v2i_i_q_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_id_v2i_i_q_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_id_v2i_i_q_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, 3, b"i")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, 5, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idf_id_v2i_i_q_Z_

        # Valid call
        rv = caller(
            2500000000.0,
            "hello",
            objc.simd.vector_int2(0, 1),
            -42,
            -17592186044416,
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], -42)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0, "hello", objc.simd.vector_int2(0, 1), -42, -17592186044416
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, "hello", objc.simd.vector_int2(0, 1), -42, -17592186044416, False
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", None, -42, -17592186044416, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                None,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), -42, None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
            )

    def test_clsidf_id_v2i_i_q_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_id_v2i_i_q_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_id_v2i_i_q_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, 3, b"i")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, 5, b"Z")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidf_id_v2i_i_q_Z_

        # Valid call
        rv = caller(
            2500000000.0,
            "hello",
            objc.simd.vector_int2(0, 1),
            -42,
            -17592186044416,
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], -42)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0, "hello", objc.simd.vector_int2(0, 1), -42, -17592186044416
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, "hello", objc.simd.vector_int2(0, 1), -42, -17592186044416, False
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", None, -42, -17592186044416, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                None,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), -42, None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
            )

    def test_idf_id_v2i_i_q_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_id_v2i_i_q_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_id_v2i_i_q_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, 3, b"i")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_Z_, 5, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idf:id:v2i:i:q:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            2500000000.0,
            "hello",
            objc.simd.vector_int2(0, 1),
            -42,
            -17592186044416,
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], -42)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0, "hello", objc.simd.vector_int2(0, 1), -42, -17592186044416
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, "hello", objc.simd.vector_int2(0, 1), -42, -17592186044416, False
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", None, -42, -17592186044416, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                None,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), -42, None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
            )

    def test_clsidf_id_v2i_i_q_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_id_v2i_i_q_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_id_v2i_i_q_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, 3, b"i")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, 4, b"q")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_Z_, 5, b"Z")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidf:id:v2i:i:q:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            2500000000.0,
            "hello",
            objc.simd.vector_int2(0, 1),
            -42,
            -17592186044416,
            False,
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            2500000000.0,
            "hello",
            objc.simd.vector_int2(0, 1),
            -42,
            -17592186044416,
            False,
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            2500000000.0,
            "hello",
            objc.simd.vector_int2(0, 1),
            -42,
            -17592186044416,
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], -42)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0, "hello", objc.simd.vector_int2(0, 1), -42, -17592186044416
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None, "hello", objc.simd.vector_int2(0, 1), -42, -17592186044416, False
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", None, -42, -17592186044416, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                None,
                -17592186044416,
                False,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), -42, None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
            )

    def test_imp_idf_id_v2i_i_q_Z_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfidv2iiqZOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfidv2iiqZOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfidv2iiqZOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idf_id_v2i_i_q_Z__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfidv2iiqZOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfidv2iiqZOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfidv2iiqZOn_(value)
        finally:
            del value.returnInvalid

    def test_idf_id_v2i_i_q_CGColor_CGColor_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 3, b"i")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 4, b"q")
        self.assertArgHasType(
            OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 5, b"^{CGColor=}"
        )
        self.assertArgHasType(
            OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 6, b"^{CGColor=}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idf_id_v2i_i_q_CGColor_CGColor_

        # Valid call
        rv = caller(
            2500000000.0,
            "hello",
            objc.simd.vector_int2(0, 1),
            -42,
            -17592186044416,
            "color!",
            "color!",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], -42)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], "color!")
        self.assertEqual(stored[6], "color!")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0, "hello", None, -42, -17592186044416, "color!", "color!"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                None,
                -17592186044416,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                None,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                NoObjCValueObject,
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

    def test_clsidf_id_v2i_i_q_CGColor_CGColor_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 1, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 2, b"<2i>"
        )
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 3, b"i")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 4, b"q")
        self.assertArgHasType(
            OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 5, b"^{CGColor=}"
        )
        self.assertArgHasType(
            OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 6, b"^{CGColor=}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidf_id_v2i_i_q_CGColor_CGColor_

        # Valid call
        rv = caller(
            2500000000.0,
            "hello",
            objc.simd.vector_int2(0, 1),
            -42,
            -17592186044416,
            "color!",
            "color!",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], -42)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], "color!")
        self.assertEqual(stored[6], "color!")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0, "hello", None, -42, -17592186044416, "color!", "color!"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                None,
                -17592186044416,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                None,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                NoObjCValueObject,
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

    def test_idf_id_v2i_i_q_CGColor_CGColor__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 3, b"i")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 4, b"q")
        self.assertArgHasType(
            OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 5, b"^{CGColor=}"
        )
        self.assertArgHasType(
            OC_VectorCall.idf_id_v2i_i_q_CGColor_CGColor_, 6, b"^{CGColor=}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idf:id:v2i:i:q:CGColor:CGColor:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            2500000000.0,
            "hello",
            objc.simd.vector_int2(0, 1),
            -42,
            -17592186044416,
            "color!",
            "color!",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], -42)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], "color!")
        self.assertEqual(stored[6], "color!")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0, "hello", None, -42, -17592186044416, "color!", "color!"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                None,
                -17592186044416,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                None,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                NoObjCValueObject,
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

    def test_clsidf_id_v2i_i_q_CGColor_CGColor__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 1, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 2, b"<2i>"
        )
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 3, b"i")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 4, b"q")
        self.assertArgHasType(
            OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 5, b"^{CGColor=}"
        )
        self.assertArgHasType(
            OC_VectorCall.clsidf_id_v2i_i_q_CGColor_CGColor_, 6, b"^{CGColor=}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidf:id:v2i:i:q:CGColor:CGColor:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            2500000000.0,
            "hello",
            objc.simd.vector_int2(0, 1),
            -42,
            -17592186044416,
            "color!",
            "color!",
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            2500000000.0,
            "hello",
            objc.simd.vector_int2(0, 1),
            -42,
            -17592186044416,
            "color!",
            "color!",
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            2500000000.0,
            "hello",
            objc.simd.vector_int2(0, 1),
            -42,
            -17592186044416,
            "color!",
            "color!",
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 7)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], -42)
        self.assertEqual(stored[4], -17592186044416)
        self.assertEqual(stored[5], "color!")
        self.assertEqual(stored[6], "color!")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0, "hello", None, -42, -17592186044416, "color!", "color!"
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                None,
                -17592186044416,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                None,
                "color!",
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                NoObjCValueObject,
                "color!",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            )

    def test_imp_idf_id_v2i_i_q_CGColor_CGColor_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfidv2iiqCGColorCGColorOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfidv2iiqCGColorCGColorOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfidv2iiqCGColorCGColorOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idf_id_v2i_i_q_CGColor_CGColor__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfidv2iiqCGColorCGColorOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -42,
                -17592186044416,
                "color!",
                "color!",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfidv2iiqCGColorCGColorOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfidv2iiqCGColorCGColorOn_(value)
        finally:
            del value.returnInvalid

    def test_idf_id_v2i_q_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_id_v2i_q_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_id_v2i_q_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_id_v2i_q_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_q_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_q_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_q_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_q_, 3, b"q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idf_id_v2i_q_

        # Valid call
        rv = caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), -17592186044416)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello", objc.simd.vector_int2(0, 1), -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -17592186044416,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", None, -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), -17592186044416)

    def test_clsidf_id_v2i_q_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_id_v2i_q_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_id_v2i_q_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_id_v2i_q_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_q_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_q_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_q_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_q_, 3, b"q")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidf_id_v2i_q_

        # Valid call
        rv = caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), -17592186044416)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello", objc.simd.vector_int2(0, 1), -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -17592186044416,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", None, -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), -17592186044416)

    def test_idf_id_v2i_q__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_id_v2i_q_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_id_v2i_q_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_id_v2i_q_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_q_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_q_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_q_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.idf_id_v2i_q_, 3, b"q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idf:id:v2i:q:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), -17592186044416)
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello", objc.simd.vector_int2(0, 1), -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -17592186044416,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", None, -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), -17592186044416)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, 2500000000.0, "hello", objc.simd.vector_int2(0, 1), -17592186044416)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
            )

    def test_clsidf_id_v2i_q__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_id_v2i_q_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_id_v2i_q_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_id_v2i_q_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_q_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_q_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_q_, 2, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsidf_id_v2i_q_, 3, b"q")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidf:id:v2i:q:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), -17592186044416)
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst, 2500000000.0, "hello", objc.simd.vector_int2(0, 1), -17592186044416
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            2500000000.0,
            "hello",
            objc.simd.vector_int2(0, 1),
            -17592186044416,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[3], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello", objc.simd.vector_int2(0, 1), -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -17592186044416,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", None, -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(2500000000.0, "hello", objc.simd.vector_int2(0, 1), -17592186044416)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, 2500000000.0, "hello", objc.simd.vector_int2(0, 1), -17592186044416)

    def test_imp_idf_id_v2i_q_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfidv2iqOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfidv2iqOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfidv2iqOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idf_id_v2i_q__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idfidv2iqOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                -17592186044416,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idfidv2iqOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idfidv2iqOn_(value)
        finally:
            del value.returnInvalid

    def test_idf_f_id_v2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_f_id_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_f_id_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_f_id_v2i_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_f_id_v2i_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_f_id_v2i_, 1, b"f")
        self.assertArgHasType(OC_VectorCall.idf_f_id_v2i_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.idf_f_id_v2i_, 3, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idf_f_id_v2i_

        # Valid call
        rv = caller(2500000000.0, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], 2500000000.0)
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, 2500000000.0, "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, None, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, 2500000000.0, "hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(2500000000.0, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))

    def test_clsidf_f_id_v2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_f_id_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_f_id_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_f_id_v2i_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_f_id_v2i_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_f_id_v2i_, 1, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_f_id_v2i_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_f_id_v2i_, 3, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidf_f_id_v2i_

        # Valid call
        rv = caller(2500000000.0, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], 2500000000.0)
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, 2500000000.0, "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, None, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, 2500000000.0, "hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(2500000000.0, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))

    def test_idf_f_id_v2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idf_f_id_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idf_f_id_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idf_f_id_v2i_, b"@")
        self.assertArgHasType(OC_VectorCall.idf_f_id_v2i_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.idf_f_id_v2i_, 1, b"f")
        self.assertArgHasType(OC_VectorCall.idf_f_id_v2i_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.idf_f_id_v2i_, 3, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idf:f:id:v2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(2500000000.0, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], 2500000000.0)
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, 2500000000.0, "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, None, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, 2500000000.0, "hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(2500000000.0, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, 2500000000.0, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                2500000000.0,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
            )

    def test_clsidf_f_id_v2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidf_f_id_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidf_f_id_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidf_f_id_v2i_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_f_id_v2i_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_f_id_v2i_, 1, b"f")
        self.assertArgHasType(OC_VectorCall.clsidf_f_id_v2i_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.clsidf_f_id_v2i_, 3, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidf:f:id:v2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(2500000000.0, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst, 2500000000.0, 2500000000.0, "hello", objc.simd.vector_int2(0, 1)
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc), 2500000000.0, 2500000000.0, "hello", objc.simd.vector_int2(0, 1)
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], 2500000000.0)
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, 2500000000.0, "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                2500000000.0,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, None, "hello", objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(
                2500000000.0,
                2500000000.0,
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, 2500000000.0, "hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(2500000000.0, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, 2500000000.0, 2500000000.0, "hello", objc.simd.vector_int2(0, 1))

    def test_imp_idf_f_id_v2i_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idffidv2iOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idffidv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idffidv2iOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idf_f_id_v2i__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idffidv2iOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                2500000000.0,
                "hello",
                objc.simd.vector_int2(0, 1),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idffidv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idffidv2iOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_idGKBox_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idGKBox_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idGKBox_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idGKBox_, b"@")
        self.assertArgHasType(OC_VectorCall.idGKBox_, 0, b"{GKBox=<3f><3f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idGKBox_

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            )
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                )
            )

    @min_os_level("10.12")
    def test_clsidGKBox_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidGKBox_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidGKBox_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidGKBox_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidGKBox_, 0, b"{GKBox=<3f><3f>}")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidGKBox_

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            )
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                )
            )

    @min_os_level("10.12")
    def test_idGKBox__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idGKBox_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idGKBox_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idGKBox_, b"@")
        self.assertArgHasType(OC_VectorCall.idGKBox_, 0, b"{GKBox=<3f><3f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idGKBox:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            )
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

    @min_os_level("10.12")
    def test_clsidGKBox__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidGKBox_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidGKBox_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidGKBox_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidGKBox_, 0, b"{GKBox=<3f><3f>}")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidGKBox:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            )
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            )

    @min_os_level("10.12")
    def test_imp_idGKBox_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idGKBoxOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idGKBoxOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idGKBoxOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_imp_idGKBox__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idGKBoxOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idGKBoxOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idGKBoxOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_idGKBox_f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idGKBox_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idGKBox_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idGKBox_f_, b"@")
        self.assertArgHasType(OC_VectorCall.idGKBox_f_, 0, b"{GKBox=<3f><3f>}")
        self.assertArgHasType(OC_VectorCall.idGKBox_f_, 1, b"f")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idGKBox_f_

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertEqual(stored[1], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                2500000000.0,
            )

    @min_os_level("10.12")
    def test_clsidGKBox_f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidGKBox_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidGKBox_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidGKBox_f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidGKBox_f_, 0, b"{GKBox=<3f><3f>}")
        self.assertArgHasType(OC_VectorCall.clsidGKBox_f_, 1, b"f")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidGKBox_f_

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertEqual(stored[1], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                2500000000.0,
            )

    @min_os_level("10.12")
    def test_idGKBox_f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idGKBox_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idGKBox_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idGKBox_f_, b"@")
        self.assertArgHasType(OC_VectorCall.idGKBox_f_, 0, b"{GKBox=<3f><3f>}")
        self.assertArgHasType(OC_VectorCall.idGKBox_f_, 1, b"f")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idGKBox:f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertEqual(stored[1], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                2500000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                2500000000.0,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                2500000000.0,
            )

    @min_os_level("10.12")
    def test_clsidGKBox_f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidGKBox_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidGKBox_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidGKBox_f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidGKBox_f_, 0, b"{GKBox=<3f><3f>}")
        self.assertArgHasType(OC_VectorCall.clsidGKBox_f_, 1, b"f")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidGKBox:f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertEqual(stored[1], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                2500000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                2500000000.0,
            )

    @min_os_level("10.12")
    def test_imp_idGKBox_f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idGKBoxfOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                2500000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idGKBoxfOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idGKBoxfOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_imp_idGKBox_f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idGKBoxfOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_float3(1.0, 2.0, 3.0),
                    objc.simd.vector_float3(4.0, 5.0, 6.0),
                ),
                2500000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idGKBoxfOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idGKBoxfOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_idGKQuad_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idGKQuad_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idGKQuad_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idGKQuad_, b"@")
        self.assertArgHasType(OC_VectorCall.idGKQuad_, 0, b"{GKQuad=<2f><2f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idGKQuad_

        # Valid call
        rv = caller(
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0))
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                )
            )

    @min_os_level("10.12")
    def test_clsidGKQuad_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidGKQuad_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidGKQuad_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidGKQuad_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidGKQuad_, 0, b"{GKQuad=<2f><2f>}")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidGKQuad_

        # Valid call
        rv = caller(
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0))
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                )
            )

    @min_os_level("10.12")
    def test_idGKQuad__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idGKQuad_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idGKQuad_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idGKQuad_, b"@")
        self.assertArgHasType(OC_VectorCall.idGKQuad_, 0, b"{GKQuad=<2f><2f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idGKQuad:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0))
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

    @min_os_level("10.12")
    def test_clsidGKQuad__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidGKQuad_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidGKQuad_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidGKQuad_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidGKQuad_, 0, b"{GKQuad=<2f><2f>}")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidGKQuad:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0))
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            )

    @min_os_level("10.12")
    def test_imp_idGKQuad_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idGKQuadOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idGKQuadOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idGKQuadOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_imp_idGKQuad__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idGKQuadOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idGKQuadOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idGKQuadOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_idGKQuad_f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idGKQuad_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idGKQuad_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idGKQuad_f_, b"@")
        self.assertArgHasType(OC_VectorCall.idGKQuad_f_, 0, b"{GKQuad=<2f><2f>}")
        self.assertArgHasType(OC_VectorCall.idGKQuad_f_, 1, b"f")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idGKQuad_f_

        # Valid call
        rv = caller(
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertEqual(stored[1], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                2500000000.0,
            )

    @min_os_level("10.12")
    def test_clsidGKQuad_f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidGKQuad_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidGKQuad_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidGKQuad_f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidGKQuad_f_, 0, b"{GKQuad=<2f><2f>}")
        self.assertArgHasType(OC_VectorCall.clsidGKQuad_f_, 1, b"f")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidGKQuad_f_

        # Valid call
        rv = caller(
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertEqual(stored[1], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                2500000000.0,
            )

    @min_os_level("10.12")
    def test_idGKQuad_f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idGKQuad_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idGKQuad_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idGKQuad_f_, b"@")
        self.assertArgHasType(OC_VectorCall.idGKQuad_f_, 0, b"{GKQuad=<2f><2f>}")
        self.assertArgHasType(OC_VectorCall.idGKQuad_f_, 1, b"f")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idGKQuad:f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertEqual(stored[1], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                2500000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                2500000000.0,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                2500000000.0,
            )

    @min_os_level("10.12")
    def test_clsidGKQuad_f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidGKQuad_f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidGKQuad_f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidGKQuad_f_, b"@")
        self.assertArgHasType(OC_VectorCall.clsidGKQuad_f_, 0, b"{GKQuad=<2f><2f>}")
        self.assertArgHasType(OC_VectorCall.clsidGKQuad_f_, 1, b"f")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidGKQuad:f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
            2500000000.0,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertEqual(stored[1], 2500000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                2500000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, 2500000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                2500000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                2500000000.0,
            )

    @min_os_level("10.12")
    def test_imp_idGKQuad_f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idGKQuadfOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                2500000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idGKQuadfOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idGKQuadfOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_imp_idGKQuad_f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idGKQuadfOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_float2(9.0, 10.0),
                    objc.simd.vector_float2(11.0, 12.0),
                ),
                2500000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idGKQuadfOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idGKQuadfOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_idMDLVoxelIndexExtent_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idMDLVoxelIndexExtent_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idMDLVoxelIndexExtent_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idMDLVoxelIndexExtent_, b"@")
        self.assertArgHasType(
            OC_VectorCall.idMDLVoxelIndexExtent_, 0, b"{MDLVoxelIndexExtent=<4i><4i>}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idMDLVoxelIndexExtent_

        # Valid call
        rv = caller(
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            )
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_int4(100, 101, 102, 103),
                    objc.simd.vector_int4(-20, -21, -22, -23),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_int4(100, 101, 102, 103),
                    objc.simd.vector_int4(-20, -21, -22, -23),
                )
            )

    @min_os_level("10.11")
    def test_clsidMDLVoxelIndexExtent_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidMDLVoxelIndexExtent_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidMDLVoxelIndexExtent_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidMDLVoxelIndexExtent_, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidMDLVoxelIndexExtent_,
            0,
            b"{MDLVoxelIndexExtent=<4i><4i>}",
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidMDLVoxelIndexExtent_

        # Valid call
        rv = caller(
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            )
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_int4(100, 101, 102, 103),
                    objc.simd.vector_int4(-20, -21, -22, -23),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_int4(100, 101, 102, 103),
                    objc.simd.vector_int4(-20, -21, -22, -23),
                )
            )

    @min_os_level("10.11")
    def test_idMDLVoxelIndexExtent__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idMDLVoxelIndexExtent_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idMDLVoxelIndexExtent_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idMDLVoxelIndexExtent_, b"@")
        self.assertArgHasType(
            OC_VectorCall.idMDLVoxelIndexExtent_, 0, b"{MDLVoxelIndexExtent=<4i><4i>}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idMDLVoxelIndexExtent:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            )
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_int4(100, 101, 102, 103),
                    objc.simd.vector_int4(-20, -21, -22, -23),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_int4(100, 101, 102, 103),
                    objc.simd.vector_int4(-20, -21, -22, -23),
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                (
                    objc.simd.vector_int4(100, 101, 102, 103),
                    objc.simd.vector_int4(-20, -21, -22, -23),
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                (
                    objc.simd.vector_int4(100, 101, 102, 103),
                    objc.simd.vector_int4(-20, -21, -22, -23),
                ),
            )

    @min_os_level("10.11")
    def test_clsidMDLVoxelIndexExtent__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidMDLVoxelIndexExtent_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidMDLVoxelIndexExtent_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidMDLVoxelIndexExtent_, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidMDLVoxelIndexExtent_,
            0,
            b"{MDLVoxelIndexExtent=<4i><4i>}",
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidMDLVoxelIndexExtent:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            )
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_int4(100, 101, 102, 103),
                    objc.simd.vector_int4(-20, -21, -22, -23),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_int4(100, 101, 102, 103),
                    objc.simd.vector_int4(-20, -21, -22, -23),
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                (
                    objc.simd.vector_int4(100, 101, 102, 103),
                    objc.simd.vector_int4(-20, -21, -22, -23),
                ),
            )

    @min_os_level("10.11")
    def test_imp_idMDLVoxelIndexExtent_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idMDLVoxelIndexExtentOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_int4(100, 101, 102, 103),
                    objc.simd.vector_int4(-20, -21, -22, -23),
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idMDLVoxelIndexExtentOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idMDLVoxelIndexExtentOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_imp_idMDLVoxelIndexExtent__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idMDLVoxelIndexExtentOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_int4(100, 101, 102, 103),
                    objc.simd.vector_int4(-20, -21, -22, -23),
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idMDLVoxelIndexExtentOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idMDLVoxelIndexExtentOn_(value)
        finally:
            del value.returnInvalid

    def test_idsimdfloat4x4_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idsimdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idsimdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idsimdfloat4x4_, b"@")
        self.assertArgHasType(
            OC_VectorCall.idsimdfloat4x4_, 0, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idsimdfloat4x4_

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            )
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

    def test_clsidsimdfloat4x4_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidsimdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidsimdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidsimdfloat4x4_, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidsimdfloat4x4_, 0, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidsimdfloat4x4_

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            )
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

    def test_idsimdfloat4x4__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idsimdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idsimdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idsimdfloat4x4_, b"@")
        self.assertArgHasType(
            OC_VectorCall.idsimdfloat4x4_, 0, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idsimdfloat4x4:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            )
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_clsidsimdfloat4x4__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidsimdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidsimdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidsimdfloat4x4_, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidsimdfloat4x4_, 0, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidsimdfloat4x4:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            )
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_imp_idsimdfloat4x4_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idsimdfloat4x4On_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idsimdfloat4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idsimdfloat4x4On_(value)
        finally:
            del value.returnInvalid

    def test_imp_idsimdfloat4x4__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idsimdfloat4x4On_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idsimdfloat4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idsimdfloat4x4On_(value)
        finally:
            del value.returnInvalid

    def test_idsimdfloat4x4_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idsimdfloat4x4_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idsimdfloat4x4_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idsimdfloat4x4_Z_, b"@")
        self.assertArgHasType(
            OC_VectorCall.idsimdfloat4x4_Z_, 0, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.idsimdfloat4x4_Z_, 1, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.idsimdfloat4x4_Z_

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                False,
            )

    def test_clsidsimdfloat4x4_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidsimdfloat4x4_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidsimdfloat4x4_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidsimdfloat4x4_Z_, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidsimdfloat4x4_Z_, 0, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.clsidsimdfloat4x4_Z_, 1, b"Z")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsidsimdfloat4x4_Z_

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                False,
            )

    def test_idsimdfloat4x4_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.idsimdfloat4x4_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.idsimdfloat4x4_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.idsimdfloat4x4_Z_, b"@")
        self.assertArgHasType(
            OC_VectorCall.idsimdfloat4x4_Z_, 0, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.idsimdfloat4x4_Z_, 1, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"idsimdfloat4x4:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                False,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                False,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                False,
            )

    def test_clsidsimdfloat4x4_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsidsimdfloat4x4_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsidsimdfloat4x4_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsidsimdfloat4x4_Z_, b"@")
        self.assertArgHasType(
            OC_VectorCall.clsidsimdfloat4x4_Z_, 0, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.clsidsimdfloat4x4_Z_, 1, b"Z")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsidsimdfloat4x4:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            False,
        )
        self.assertEqual(rv, "hello")

        # Valid call through instance
        rv = imp(
            oc_inst,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            False,
        )
        self.assertEqual(rv, "hello")

        # Valid call through meta
        rv = imp(
            type(oc),
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            False,
        )
        self.assertEqual(rv, "hello")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                False,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                False,
            )

    def test_imp_idsimdfloat4x4_Z_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.idsimdfloat4x4ZOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idsimdfloat4x4ZOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idsimdfloat4x4ZOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_idsimdfloat4x4_Z__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.idsimdfloat4x4ZOn_(value)
        self.assertEqual(result, "hello")
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.idsimdfloat4x4ZOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.idsimdfloat4x4ZOn_(value)
        finally:
            del value.returnInvalid

    def test_Zv2i_id_id_id_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.Zv2i_id_id_id_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.Zv2i_id_id_id_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.Zv2i_id_id_id_id_, b"Z")
        self.assertArgHasType(OC_VectorCall.Zv2i_id_id_id_id_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.Zv2i_id_id_id_id_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.Zv2i_id_id_id_id_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.Zv2i_id_id_id_id_, 3, b"@")
        self.assertArgHasType(OC_VectorCall.Zv2i_id_id_id_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.Zv2i_id_id_id_id_

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello")
        self.assertEqual(rv, False)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], "hello")
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), "hello", "hello", "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello", "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello", "hello", "hello", "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                NoObjCValueObject,
                "hello",
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                "hello",
                NoObjCValueObject,
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                "hello",
                "hello",
                NoObjCValueObject,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                "hello",
                "hello",
                "hello",
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello")

    def test_clsZv2i_id_id_id_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsZv2i_id_id_id_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsZv2i_id_id_id_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsZv2i_id_id_id_id_, b"Z")
        self.assertArgHasType(OC_VectorCall.clsZv2i_id_id_id_id_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsZv2i_id_id_id_id_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.clsZv2i_id_id_id_id_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.clsZv2i_id_id_id_id_, 3, b"@")
        self.assertArgHasType(OC_VectorCall.clsZv2i_id_id_id_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsZv2i_id_id_id_id_

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello")
        self.assertEqual(rv, False)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], "hello")
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), "hello", "hello", "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello", "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello", "hello", "hello", "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                NoObjCValueObject,
                "hello",
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                "hello",
                NoObjCValueObject,
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                "hello",
                "hello",
                NoObjCValueObject,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                "hello",
                "hello",
                "hello",
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello")

    def test_Zv2i_id_id_id_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.Zv2i_id_id_id_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.Zv2i_id_id_id_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.Zv2i_id_id_id_id_, b"Z")
        self.assertArgHasType(OC_VectorCall.Zv2i_id_id_id_id_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.Zv2i_id_id_id_id_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.Zv2i_id_id_id_id_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.Zv2i_id_id_id_id_, 3, b"@")
        self.assertArgHasType(OC_VectorCall.Zv2i_id_id_id_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"Zv2i:id:id:id:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello")
        self.assertEqual(rv, False)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], "hello")
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), "hello", "hello", "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello", "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello", "hello", "hello", "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                NoObjCValueObject,
                "hello",
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                "hello",
                NoObjCValueObject,
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                "hello",
                "hello",
                NoObjCValueObject,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                "hello",
                "hello",
                "hello",
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello")

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello")

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                "hello",
                "hello",
                "hello",
                "hello",
            )

    def test_clsZv2i_id_id_id_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsZv2i_id_id_id_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsZv2i_id_id_id_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsZv2i_id_id_id_id_, b"Z")
        self.assertArgHasType(OC_VectorCall.clsZv2i_id_id_id_id_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsZv2i_id_id_id_id_, 1, b"@")
        self.assertArgHasType(OC_VectorCall.clsZv2i_id_id_id_id_, 2, b"@")
        self.assertArgHasType(OC_VectorCall.clsZv2i_id_id_id_id_, 3, b"@")
        self.assertArgHasType(OC_VectorCall.clsZv2i_id_id_id_id_, 4, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsZv2i:id:id:id:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello")
        self.assertEqual(rv, False)

        # Valid call through instance
        rv = imp(
            oc_inst, objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello"
        )
        self.assertEqual(rv, False)

        # Valid call through meta
        rv = imp(
            type(oc), objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello"
        )
        self.assertEqual(rv, False)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], "hello")
        self.assertEqual(stored[2], "hello")
        self.assertEqual(stored[3], "hello")
        self.assertEqual(stored[4], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), "hello", "hello", "hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello", "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello", "hello", "hello", "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                NoObjCValueObject,
                "hello",
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                "hello",
                NoObjCValueObject,
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                "hello",
                "hello",
                NoObjCValueObject,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                "hello",
                "hello",
                "hello",
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello")

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_int2(0, 1), "hello", "hello", "hello", "hello")

    def test_imp_Zv2i_id_id_id_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.Zv2iididididOn_(value)
        self.assertEqual(result, False)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_int2(0, 1),
                "hello",
                "hello",
                "hello",
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.Zv2iididididOn_(value)
        finally:
            del value.shouldRaise

    def test_imp_Zv2i_id_id_id_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.Zv2iididididOn_(value)
        self.assertEqual(result, False)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_int2(0, 1),
                "hello",
                "hello",
                "hello",
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.Zv2iididididOn_(value)
        finally:
            del value.shouldRaise

    def test_Zv2i_q_f_id_id_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.Zv2i_q_f_id_id_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.Zv2i_q_f_id_id_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, b"Z")
        self.assertArgHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, 1, b"q")
        self.assertArgHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, 2, b"f")
        self.assertArgHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, 3, b"@")
        self.assertArgHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, 4, b"@")
        self.assertArgHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, 5, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.Zv2i_q_f_id_id_id_

        # Valid call
        rv = caller(
            objc.simd.vector_int2(0, 1),
            -17592186044416,
            2500000000.0,
            "hello",
            "hello",
            "hello",
        )
        self.assertEqual(rv, False)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], -17592186044416)
        self.assertEqual(stored[2], 2500000000.0)
        self.assertEqual(stored[3], "hello")
        self.assertEqual(stored[4], "hello")
        self.assertEqual(stored[5], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -17592186044416, 2500000000.0, "hello", "hello", "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                None,
                2500000000.0,
                "hello",
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                None,
                "hello",
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                NoObjCValueObject,
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                NoObjCValueObject,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                "hello",
            )

    def test_clsZv2i_q_f_id_id_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsZv2i_q_f_id_id_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsZv2i_q_f_id_id_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, b"Z")
        self.assertArgHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, 1, b"q")
        self.assertArgHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, 2, b"f")
        self.assertArgHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, 3, b"@")
        self.assertArgHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, 4, b"@")
        self.assertArgHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, 5, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsZv2i_q_f_id_id_id_

        # Valid call
        rv = caller(
            objc.simd.vector_int2(0, 1),
            -17592186044416,
            2500000000.0,
            "hello",
            "hello",
            "hello",
        )
        self.assertEqual(rv, False)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], -17592186044416)
        self.assertEqual(stored[2], 2500000000.0)
        self.assertEqual(stored[3], "hello")
        self.assertEqual(stored[4], "hello")
        self.assertEqual(stored[5], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -17592186044416, 2500000000.0, "hello", "hello", "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                None,
                2500000000.0,
                "hello",
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                None,
                "hello",
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                NoObjCValueObject,
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                NoObjCValueObject,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                "hello",
            )

    def test_Zv2i_q_f_id_id_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.Zv2i_q_f_id_id_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.Zv2i_q_f_id_id_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, b"Z")
        self.assertArgHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, 1, b"q")
        self.assertArgHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, 2, b"f")
        self.assertArgHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, 3, b"@")
        self.assertArgHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, 4, b"@")
        self.assertArgHasType(OC_VectorCall.Zv2i_q_f_id_id_id_, 5, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"Zv2i:q:f:id:id:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_int2(0, 1),
            -17592186044416,
            2500000000.0,
            "hello",
            "hello",
            "hello",
        )
        self.assertEqual(rv, False)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], -17592186044416)
        self.assertEqual(stored[2], 2500000000.0)
        self.assertEqual(stored[3], "hello")
        self.assertEqual(stored[4], "hello")
        self.assertEqual(stored[5], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -17592186044416, 2500000000.0, "hello", "hello", "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                None,
                2500000000.0,
                "hello",
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                None,
                "hello",
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                NoObjCValueObject,
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                NoObjCValueObject,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                "hello",
            )

    def test_clsZv2i_q_f_id_id_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsZv2i_q_f_id_id_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsZv2i_q_f_id_id_id_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, b"Z")
        self.assertArgHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, 0, b"<2i>")
        self.assertArgHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, 1, b"q")
        self.assertArgHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, 2, b"f")
        self.assertArgHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, 3, b"@")
        self.assertArgHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, 4, b"@")
        self.assertArgHasType(OC_VectorCall.clsZv2i_q_f_id_id_id_, 5, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsZv2i:q:f:id:id:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_int2(0, 1),
            -17592186044416,
            2500000000.0,
            "hello",
            "hello",
            "hello",
        )
        self.assertEqual(rv, False)

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_int2(0, 1),
            -17592186044416,
            2500000000.0,
            "hello",
            "hello",
            "hello",
        )
        self.assertEqual(rv, False)

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_int2(0, 1),
            -17592186044416,
            2500000000.0,
            "hello",
            "hello",
            "hello",
        )
        self.assertEqual(rv, False)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 6)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))
        self.assertEqual(stored[1], -17592186044416)
        self.assertEqual(stored[2], 2500000000.0)
        self.assertEqual(stored[3], "hello")
        self.assertEqual(stored[4], "hello")
        self.assertEqual(stored[5], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -17592186044416, 2500000000.0, "hello", "hello", "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                None,
                2500000000.0,
                "hello",
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                None,
                "hello",
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                NoObjCValueObject,
                "hello",
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                NoObjCValueObject,
                "hello",
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                "hello",
            )

    def test_imp_Zv2i_q_f_id_id_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.Zv2iqfidididOn_(value)
        self.assertEqual(result, False)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.Zv2iqfidididOn_(value)
        finally:
            del value.shouldRaise

    def test_imp_Zv2i_q_f_id_id_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.Zv2iqfidididOn_(value)
        self.assertEqual(result, False)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_int2(0, 1),
                -17592186044416,
                2500000000.0,
                "hello",
                "hello",
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.Zv2iqfidididOn_(value)
        finally:
            del value.shouldRaise

    def test_Zv4i_Z_Z_Z_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.Zv4i_Z_Z_Z_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.Zv4i_Z_Z_Z_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.Zv4i_Z_Z_Z_Z_, b"Z")
        self.assertArgHasType(OC_VectorCall.Zv4i_Z_Z_Z_Z_, 0, b"<4i>")
        self.assertArgHasType(OC_VectorCall.Zv4i_Z_Z_Z_Z_, 1, b"Z")
        self.assertArgHasType(OC_VectorCall.Zv4i_Z_Z_Z_Z_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.Zv4i_Z_Z_Z_Z_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.Zv4i_Z_Z_Z_Z_, 4, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.Zv4i_Z_Z_Z_Z_

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False)
        self.assertEqual(rv, False)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(stored[1], False)
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False, "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False, False, False, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), NoBool(), False, False, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, NoBool(), False, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, NoBool(), False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False, NoBool())

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False)

    def test_clsZv4i_Z_Z_Z_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsZv4i_Z_Z_Z_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsZv4i_Z_Z_Z_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsZv4i_Z_Z_Z_Z_, b"Z")
        self.assertArgHasType(OC_VectorCall.clsZv4i_Z_Z_Z_Z_, 0, b"<4i>")
        self.assertArgHasType(OC_VectorCall.clsZv4i_Z_Z_Z_Z_, 1, b"Z")
        self.assertArgHasType(OC_VectorCall.clsZv4i_Z_Z_Z_Z_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.clsZv4i_Z_Z_Z_Z_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.clsZv4i_Z_Z_Z_Z_, 4, b"Z")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsZv4i_Z_Z_Z_Z_

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False)
        self.assertEqual(rv, False)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(stored[1], False)
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False, "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False, False, False, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), NoBool(), False, False, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, NoBool(), False, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, NoBool(), False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False, NoBool())

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False)

    def test_Zv4i_Z_Z_Z_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.Zv4i_Z_Z_Z_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.Zv4i_Z_Z_Z_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.Zv4i_Z_Z_Z_Z_, b"Z")
        self.assertArgHasType(OC_VectorCall.Zv4i_Z_Z_Z_Z_, 0, b"<4i>")
        self.assertArgHasType(OC_VectorCall.Zv4i_Z_Z_Z_Z_, 1, b"Z")
        self.assertArgHasType(OC_VectorCall.Zv4i_Z_Z_Z_Z_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.Zv4i_Z_Z_Z_Z_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.Zv4i_Z_Z_Z_Z_, 4, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"Zv4i:Z:Z:Z:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False)
        self.assertEqual(rv, False)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(stored[1], False)
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False, "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False, False, False, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), NoBool(), False, False, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, NoBool(), False, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, NoBool(), False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False, NoBool())

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_int4(0, 1, 2, 3),
                False,
                False,
                False,
                False,
            )

    def test_clsZv4i_Z_Z_Z_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsZv4i_Z_Z_Z_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsZv4i_Z_Z_Z_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsZv4i_Z_Z_Z_Z_, b"Z")
        self.assertArgHasType(OC_VectorCall.clsZv4i_Z_Z_Z_Z_, 0, b"<4i>")
        self.assertArgHasType(OC_VectorCall.clsZv4i_Z_Z_Z_Z_, 1, b"Z")
        self.assertArgHasType(OC_VectorCall.clsZv4i_Z_Z_Z_Z_, 2, b"Z")
        self.assertArgHasType(OC_VectorCall.clsZv4i_Z_Z_Z_Z_, 3, b"Z")
        self.assertArgHasType(OC_VectorCall.clsZv4i_Z_Z_Z_Z_, 4, b"Z")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsZv4i:Z:Z:Z:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False)
        self.assertEqual(rv, False)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False)
        self.assertEqual(rv, False)

        # Valid call through meta
        rv = imp(
            type(oc), objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False
        )
        self.assertEqual(rv, False)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 5)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(stored[1], False)
        self.assertEqual(stored[2], False)
        self.assertEqual(stored[3], False)
        self.assertEqual(stored[4], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False, "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False, False, False, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), NoBool(), False, False, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, NoBool(), False, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, NoBool(), False)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False, NoBool())

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_int4(0, 1, 2, 3), False, False, False, False)

    def test_imp_Zv4i_Z_Z_Z_Z_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.Zv4iZZZZOn_(value)
        self.assertEqual(result, False)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_int4(0, 1, 2, 3),
                False,
                False,
                False,
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.Zv4iZZZZOn_(value)
        finally:
            del value.shouldRaise

    def test_imp_Zv4i_Z_Z_Z_Z__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.Zv4iZZZZOn_(value)
        self.assertEqual(result, False)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_int4(0, 1, 2, 3),
                False,
                False,
                False,
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.Zv4iZZZZOn_(value)
        finally:
            del value.shouldRaise

    def test_CGColorv3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.CGColorv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.CGColorv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.CGColorv3f_, b"^{CGColor=}")
        self.assertArgHasType(OC_VectorCall.CGColorv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.CGColorv3f_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "color!")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_clsCGColorv3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsCGColorv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsCGColorv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsCGColorv3f_, b"^{CGColor=}")
        self.assertArgHasType(OC_VectorCall.clsCGColorv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsCGColorv3f_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "color!")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_CGColorv3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.CGColorv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.CGColorv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.CGColorv3f_, b"^{CGColor=}")
        self.assertArgHasType(OC_VectorCall.CGColorv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"CGColorv3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "color!")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_clsCGColorv3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsCGColorv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsCGColorv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsCGColorv3f_, b"^{CGColor=}")
        self.assertArgHasType(OC_VectorCall.clsCGColorv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsCGColorv3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "color!")

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "color!")

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(rv, "color!")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_imp_CGColorv3f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.CGColorv3fOn_(value)
        self.assertEqual(result, "color!")
        self.assertEqual(value.argvalues, (objc.simd.vector_float3(0.0, 1.5, 3.0),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.CGColorv3fOn_(value)
        finally:
            del value.shouldRaise

    def test_imp_CGColorv3f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.CGColorv3fOn_(value)
        self.assertEqual(result, "color!")
        self.assertEqual(value.argvalues, (objc.simd.vector_float3(0.0, 1.5, 3.0),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.CGColorv3fOn_(value)
        finally:
            del value.shouldRaise

    def test_CGColorv3f_CGColorSpace_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.CGColorv3f_CGColorSpace_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.CGColorv3f_CGColorSpace_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.CGColorv3f_CGColorSpace_, b"^{CGColor=}")
        self.assertArgHasType(OC_VectorCall.CGColorv3f_CGColorSpace_, 0, b"<3f>")
        self.assertArgHasType(
            OC_VectorCall.CGColorv3f_CGColorSpace_, 1, b"^{CGColorSpace=}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.CGColorv3f_CGColorSpace_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!")
        self.assertEqual(rv, "color!")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], "colorspace!")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!", "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "colorspace!")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), NoObjCValueObject)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!")

    def test_clsCGColorv3f_CGColorSpace_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsCGColorv3f_CGColorSpace_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsCGColorv3f_CGColorSpace_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsCGColorv3f_CGColorSpace_, b"^{CGColor=}"
        )
        self.assertArgHasType(OC_VectorCall.clsCGColorv3f_CGColorSpace_, 0, b"<3f>")
        self.assertArgHasType(
            OC_VectorCall.clsCGColorv3f_CGColorSpace_, 1, b"^{CGColorSpace=}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsCGColorv3f_CGColorSpace_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!")
        self.assertEqual(rv, "color!")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], "colorspace!")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!", "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "colorspace!")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), NoObjCValueObject)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!")

    def test_CGColorv3f_CGColorSpace__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.CGColorv3f_CGColorSpace_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.CGColorv3f_CGColorSpace_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.CGColorv3f_CGColorSpace_, b"^{CGColor=}")
        self.assertArgHasType(OC_VectorCall.CGColorv3f_CGColorSpace_, 0, b"<3f>")
        self.assertArgHasType(
            OC_VectorCall.CGColorv3f_CGColorSpace_, 1, b"^{CGColorSpace=}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"CGColorv3f:CGColorSpace:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!")
        self.assertEqual(rv, "color!")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], "colorspace!")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!", "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "colorspace!")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), NoObjCValueObject)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!")

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!")

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject, objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!"
            )

    def test_clsCGColorv3f_CGColorSpace__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsCGColorv3f_CGColorSpace_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsCGColorv3f_CGColorSpace_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsCGColorv3f_CGColorSpace_, b"^{CGColor=}"
        )
        self.assertArgHasType(OC_VectorCall.clsCGColorv3f_CGColorSpace_, 0, b"<3f>")
        self.assertArgHasType(
            OC_VectorCall.clsCGColorv3f_CGColorSpace_, 1, b"^{CGColorSpace=}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsCGColorv3f:CGColorSpace:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!")
        self.assertEqual(rv, "color!")

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!")
        self.assertEqual(rv, "color!")

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!")
        self.assertEqual(rv, "color!")

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], "colorspace!")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!", "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "colorspace!")

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), NoObjCValueObject)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!")

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0), "colorspace!")

    def test_imp_CGColorv3f_CGColorSpace_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.CGColorv3fCGColorSpaceOn_(value)
        self.assertEqual(result, "color!")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "colorspace!",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.CGColorv3fCGColorSpaceOn_(value)
        finally:
            del value.shouldRaise

    def test_imp_CGColorv3f_CGColorSpace__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.CGColorv3fCGColorSpaceOn_(value)
        self.assertEqual(result, "color!")
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "colorspace!",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.CGColorv3fCGColorSpaceOn_(value)
        finally:
            del value.shouldRaise

    def test_fv2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.fv2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.fv2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.fv2f_, b"f")
        self.assertArgHasType(OC_VectorCall.fv2f_, 0, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.fv2f_

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, 2500000000.0)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5))

    def test_clsfv2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsfv2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsfv2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsfv2f_, b"f")
        self.assertArgHasType(OC_VectorCall.clsfv2f_, 0, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsfv2f_

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, 2500000000.0)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5))

    def test_fv2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.fv2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.fv2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.fv2f_, b"f")
        self.assertArgHasType(OC_VectorCall.fv2f_, 0, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"fv2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, 2500000000.0)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_float2(0.0, 1.5))

    def test_clsfv2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsfv2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsfv2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsfv2f_, b"f")
        self.assertArgHasType(OC_VectorCall.clsfv2f_, 0, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsfv2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, 2500000000.0)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, 2500000000.0)

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(rv, 2500000000.0)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float2(0.0, 1.5))

    def test_imp_fv2f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.fv2fOn_(value)
        self.assertEqual(result, 2500000000.0)
        self.assertEqual(value.argvalues, (objc.simd.vector_float2(0.0, 1.5),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.fv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.fv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_fv2f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.fv2fOn_(value)
        self.assertEqual(result, 2500000000.0)
        self.assertEqual(value.argvalues, (objc.simd.vector_float2(0.0, 1.5),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.fv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.fv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_fv2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.fv2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.fv2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.fv2i_, b"f")
        self.assertArgHasType(OC_VectorCall.fv2i_, 0, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.fv2i_

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, 2500000000.0)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1))

    def test_clsfv2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsfv2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsfv2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsfv2i_, b"f")
        self.assertArgHasType(OC_VectorCall.clsfv2i_, 0, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsfv2i_

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, 2500000000.0)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1))

    def test_fv2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.fv2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.fv2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.fv2i_, b"f")
        self.assertArgHasType(OC_VectorCall.fv2i_, 0, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"fv2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, 2500000000.0)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_int2(0, 1))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_int2(0, 1))

    def test_clsfv2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsfv2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsfv2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsfv2i_, b"f")
        self.assertArgHasType(OC_VectorCall.clsfv2i_, 0, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsfv2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, 2500000000.0)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, 2500000000.0)

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_int2(0, 1))
        self.assertEqual(rv, 2500000000.0)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_int2(0, 1))

    def test_imp_fv2i_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.fv2iOn_(value)
        self.assertEqual(result, 2500000000.0)
        self.assertEqual(value.argvalues, (objc.simd.vector_int2(0, 1),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.fv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.fv2iOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_fv2i__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.fv2iOn_(value)
        self.assertEqual(result, 2500000000.0)
        self.assertEqual(value.argvalues, (objc.simd.vector_int2(0, 1),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.fv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.fv2iOn_(value)
        finally:
            del value.returnInvalid

    def test_vv2d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv2d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv2d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv2d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv2d_, 0, b"<2d>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv2d_

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5))

    def test_clsvv2d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv2d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv2d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv2d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv2d_, 0, b"<2d>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv2d_

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5))

    def test_vv2d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv2d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv2d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv2d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv2d_, 0, b"<2d>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv2d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_double2(0.0, 1.5))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_double2(0.0, 1.5))

    def test_clsvv2d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv2d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv2d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv2d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv2d_, 0, b"<2d>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv2d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5))
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_double2(0.0, 1.5))
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_double2(0.0, 1.5))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_double2(0.0, 1.5))

    def test_imp_vv2d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv2dOn_(value)
        self.assertIs(result, None)
        self.assertEqual(value.argvalues, (objc.simd.vector_double2(0.0, 1.5),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv2dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv2dOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv2d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv2dOn_(value)
        self.assertIs(result, None)
        self.assertEqual(value.argvalues, (objc.simd.vector_double2(0.0, 1.5),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv2dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv2dOn_(value)
        finally:
            del value.returnInvalid

    def test_vv2d_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv2d_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv2d_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv2d_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv2d_d_, 0, b"<2d>")
        self.assertArgHasType(OC_VectorCall.vv2d_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv2d_d_

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5), -557000000000.0)

    def test_clsvv2d_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv2d_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv2d_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv2d_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv2d_d_, 0, b"<2d>")
        self.assertArgHasType(OC_VectorCall.clsvv2d_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv2d_d_

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5), -557000000000.0)

    def test_vv2d_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv2d_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv2d_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv2d_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv2d_d_, 0, b"<2d>")
        self.assertArgHasType(OC_VectorCall.vv2d_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv2d:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5), -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_double2(0.0, 1.5), -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_double2(0.0, 1.5), -557000000000.0)

    def test_clsvv2d_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv2d_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv2d_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv2d_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv2d_d_, 0, b"<2d>")
        self.assertArgHasType(OC_VectorCall.clsvv2d_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv2d:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double2(0.0, 1.5), -557000000000.0)
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_double2(0.0, 1.5), -557000000000.0)
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_double2(0.0, 1.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double2(0.0, 1.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double2(0.0, 1.5), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double2(0.0, 1.5), -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_double2(0.0, 1.5), -557000000000.0)

    def test_imp_vv2d_d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv2ddOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_double2(0.0, 1.5),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv2ddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv2ddOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv2d_d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv2ddOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_double2(0.0, 1.5),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv2ddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv2ddOn_(value)
        finally:
            del value.returnInvalid

    def test_vv2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv2f_, b"v")
        self.assertArgHasType(OC_VectorCall.vv2f_, 0, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv2f_

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5))

    def test_clsvv2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv2f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv2f_, 0, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv2f_

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5))

    def test_vv2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv2f_, b"v")
        self.assertArgHasType(OC_VectorCall.vv2f_, 0, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_float2(0.0, 1.5))

    def test_clsvv2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv2f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv2f_, 0, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5))
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float2(0.0, 1.5))
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float2(0.0, 1.5))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float2(0.0, 1.5))

    def test_imp_vv2f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv2fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(value.argvalues, (objc.simd.vector_float2(0.0, 1.5),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv2f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv2fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(value.argvalues, (objc.simd.vector_float2(0.0, 1.5),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_vv2f_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv2f_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv2f_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv2f_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv2f_d_, 0, b"<2f>")
        self.assertArgHasType(OC_VectorCall.vv2f_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv2f_d_

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5), -557000000000.0)

    def test_clsvv2f_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv2f_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv2f_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv2f_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv2f_d_, 0, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsvv2f_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv2f_d_

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5), -557000000000.0)

    def test_vv2f_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv2f_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv2f_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv2f_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv2f_d_, 0, b"<2f>")
        self.assertArgHasType(OC_VectorCall.vv2f_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv2f:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5), -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float2(0.0, 1.5), -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_float2(0.0, 1.5), -557000000000.0)

    def test_clsvv2f_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv2f_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv2f_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv2f_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv2f_d_, 0, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsvv2f_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv2f:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float2(0.0, 1.5), -557000000000.0)
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float2(0.0, 1.5), -557000000000.0)
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float2(0.0, 1.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float2(0.0, 1.5), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float2(0.0, 1.5), -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float2(0.0, 1.5), -557000000000.0)

    def test_imp_vv2f_d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv2fdOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float2(0.0, 1.5),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv2fdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv2fdOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv2f_d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv2fdOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float2(0.0, 1.5),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv2fdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv2fdOn_(value)
        finally:
            del value.returnInvalid

    def test_vv3d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv3d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv3d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv3d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv3d_, 0, b"<3d>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv3d_

        # Valid call
        rv = caller(objc.simd.vector_double3(0.0, 1.5, 3.0))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_double3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0))

    def test_clsvv3d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv3d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv3d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv3d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv3d_, 0, b"<3d>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv3d_

        # Valid call
        rv = caller(objc.simd.vector_double3(0.0, 1.5, 3.0))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_double3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0))

    def test_vv3d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv3d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv3d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv3d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv3d_, 0, b"<3d>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv3d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double3(0.0, 1.5, 3.0))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_double3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_double3(0.0, 1.5, 3.0))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_double3(0.0, 1.5, 3.0))

    def test_clsvv3d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv3d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv3d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv3d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv3d_, 0, b"<3d>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv3d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double3(0.0, 1.5, 3.0))
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_double3(0.0, 1.5, 3.0))
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_double3(0.0, 1.5, 3.0))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_double3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_double3(0.0, 1.5, 3.0))

    def test_imp_vv3d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv3dOn_(value)
        self.assertIs(result, None)
        self.assertEqual(value.argvalues, (objc.simd.vector_double3(0.0, 1.5, 3.0),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv3dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv3dOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv3d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv3dOn_(value)
        self.assertIs(result, None)
        self.assertEqual(value.argvalues, (objc.simd.vector_double3(0.0, 1.5, 3.0),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv3dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv3dOn_(value)
        finally:
            del value.returnInvalid

    def test_vv3d_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv3d_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv3d_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv3d_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv3d_d_, 0, b"<3d>")
        self.assertArgHasType(OC_VectorCall.vv3d_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv3d_d_

        # Valid call
        rv = caller(objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0)

    def test_clsvv3d_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv3d_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv3d_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv3d_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv3d_d_, 0, b"<3d>")
        self.assertArgHasType(OC_VectorCall.clsvv3d_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv3d_d_

        # Valid call
        rv = caller(objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0)

    def test_vv3d_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv3d_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv3d_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv3d_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv3d_d_, 0, b"<3d>")
        self.assertArgHasType(OC_VectorCall.vv3d_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv3d:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_double3(0.0, 1.5, 3.0),
                -557000000000.0,
            )

    def test_clsvv3d_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv3d_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv3d_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv3d_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv3d_d_, 0, b"<3d>")
        self.assertArgHasType(OC_VectorCall.clsvv3d_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv3d:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0)
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0)
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_double3(0.0, 1.5, 3.0), -557000000000.0)

    def test_imp_vv3d_d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv3ddOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_double3(0.0, 1.5, 3.0),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv3ddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv3ddOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv3d_d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv3ddOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_double3(0.0, 1.5, 3.0),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv3ddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv3ddOn_(value)
        finally:
            del value.returnInvalid

    def test_vv3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv3f_, b"v")
        self.assertArgHasType(OC_VectorCall.vv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv3f_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_clsvv3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv3f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv3f_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_vv3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv3f_, b"v")
        self.assertArgHasType(OC_VectorCall.vv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_clsvv3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv3f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv3f_, 0, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0))

    def test_imp_vv3f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv3fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(value.argvalues, (objc.simd.vector_float3(0.0, 1.5, 3.0),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv3f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv3fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(value.argvalues, (objc.simd.vector_float3(0.0, 1.5, 3.0),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_vv3f_v3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv3f_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv3f_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv3f_v3f_, b"v")
        self.assertArgHasType(OC_VectorCall.vv3f_v3f_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.vv3f_v3f_, 1, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv3f_v3f_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

    def test_clsvv3f_v3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv3f_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv3f_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv3f_v3f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv3f_v3f_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsvv3f_v3f_, 1, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv3f_v3f_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

    def test_vv3f_v3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv3f_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv3f_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv3f_v3f_, b"v")
        self.assertArgHasType(OC_VectorCall.vv3f_v3f_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.vv3f_v3f_, 1, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv3f:v3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

    def test_clsvv3f_v3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv3f_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv3f_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv3f_v3f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv3f_v3f_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsvv3f_v3f_, 1, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv3f:v3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

    def test_imp_vv3f_v3f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv3fv3fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv3fv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv3fv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv3f_v3f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv3fv3fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv3fv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv3fv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_vv3f_v3f_v3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv3f_v3f_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv3f_v3f_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv3f_v3f_v3f_, b"v")
        self.assertArgHasType(OC_VectorCall.vv3f_v3f_v3f_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.vv3f_v3f_v3f_, 1, b"<3f>")
        self.assertArgHasType(OC_VectorCall.vv3f_v3f_v3f_, 2, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv3f_v3f_v3f_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[2], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

    def test_clsvv3f_v3f_v3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv3f_v3f_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv3f_v3f_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv3f_v3f_v3f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv3f_v3f_v3f_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsvv3f_v3f_v3f_, 1, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsvv3f_v3f_v3f_, 2, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv3f_v3f_v3f_

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[2], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

    def test_vv3f_v3f_v3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv3f_v3f_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv3f_v3f_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv3f_v3f_v3f_, b"v")
        self.assertArgHasType(OC_VectorCall.vv3f_v3f_v3f_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.vv3f_v3f_v3f_, 1, b"<3f>")
        self.assertArgHasType(OC_VectorCall.vv3f_v3f_v3f_, 2, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv3f:v3f:v3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[2], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

    def test_clsvv3f_v3f_v3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv3f_v3f_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv3f_v3f_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv3f_v3f_v3f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv3f_v3f_v3f_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsvv3f_v3f_v3f_, 1, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsvv3f_v3f_v3f_, 2, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv3f:v3f:v3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[2], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                None,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

    def test_imp_vv3f_v3f_v3f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv3fv3fv3fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv3fv3fv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv3fv3fv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv3f_v3f_v3f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv3fv3fv3fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv3fv3fv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv3fv3fv3fOn_(value)
        finally:
            del value.returnInvalid

    def test_vv3f_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv3f_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv3f_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv3f_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv3f_d_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.vv3f_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv3f_d_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0)

    def test_clsvv3f_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv3f_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv3f_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv3f_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv3f_d_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsvv3f_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv3f_d_

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0)

    def test_vv3f_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv3f_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv3f_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv3f_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv3f_d_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.vv3f_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv3f:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                -557000000000.0,
            )

    def test_clsvv3f_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv3f_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv3f_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv3f_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv3f_d_, 0, b"<3f>")
        self.assertArgHasType(OC_VectorCall.clsvv3f_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv3f:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0)
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0)
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float3(0.0, 1.5, 3.0))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float3(0.0, 1.5, 3.0), -557000000000.0)

    def test_imp_vv3f_d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv3fdOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv3fdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv3fdOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv3f_d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv3fdOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv3fdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv3fdOn_(value)
        finally:
            del value.returnInvalid

    def test_vv4d_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv4d_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv4d_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv4d_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv4d_d_, 0, b"<4d>")
        self.assertArgHasType(OC_VectorCall.vv4d_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv4d_d_

        # Valid call
        rv = caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0, "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0)

    def test_clsvv4d_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv4d_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv4d_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv4d_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv4d_d_, 0, b"<4d>")
        self.assertArgHasType(OC_VectorCall.clsvv4d_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv4d_d_

        # Valid call
        rv = caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0, "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0)

    def test_vv4d_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv4d_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv4d_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv4d_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv4d_d_, 0, b"<4d>")
        self.assertArgHasType(OC_VectorCall.vv4d_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv4d:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0, "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                -557000000000.0,
            )

    def test_clsvv4d_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv4d_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv4d_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv4d_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv4d_d_, 0, b"<4d>")
        self.assertArgHasType(OC_VectorCall.clsvv4d_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv4d:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0)
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0)
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc), objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0, "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5), -557000000000.0)

    def test_imp_vv4d_d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv4ddOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv4ddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv4ddOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv4d_d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv4ddOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv4ddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv4ddOn_(value)
        finally:
            del value.returnInvalid

    def test_vv4f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv4f_, b"v")
        self.assertArgHasType(OC_VectorCall.vv4f_, 0, b"<4f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv4f_

        # Valid call
        rv = caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_clsvv4f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv4f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv4f_, 0, b"<4f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv4f_

        # Valid call
        rv = caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_vv4f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv4f_, b"v")
        self.assertArgHasType(OC_VectorCall.vv4f_, 0, b"<4f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv4f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_clsvv4f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv4f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv4f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv4f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv4f_, 0, b"<4f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv4f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

    def test_imp_vv4f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv4fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues, (objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),)
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv4fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv4fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv4f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv4fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues, (objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),)
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv4fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv4fOn_(value)
        finally:
            del value.returnInvalid

    def test_vv4f_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv4f_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv4f_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv4f_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv4f_d_, 0, b"<4f>")
        self.assertArgHasType(OC_VectorCall.vv4f_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv4f_d_

        # Valid call
        rv = caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0, "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0)

    def test_clsvv4f_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv4f_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv4f_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv4f_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv4f_d_, 0, b"<4f>")
        self.assertArgHasType(OC_VectorCall.clsvv4f_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv4f_d_

        # Valid call
        rv = caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0, "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0)

    def test_vv4f_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv4f_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv4f_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv4f_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vv4f_d_, 0, b"<4f>")
        self.assertArgHasType(OC_VectorCall.vv4f_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv4f:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0, "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                -557000000000.0,
            )

    def test_clsvv4f_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv4f_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv4f_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv4f_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv4f_d_, 0, b"<4f>")
        self.assertArgHasType(OC_VectorCall.clsvv4f_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv4f:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0)
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0)
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0)
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0, "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5), -557000000000.0)

    def test_imp_vv4f_d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv4fdOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv4fdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv4fdOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv4f_d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv4fdOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv4fdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv4fdOn_(value)
        finally:
            del value.returnInvalid

    def test_vv4i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv4i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv4i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv4i_, b"v")
        self.assertArgHasType(OC_VectorCall.vv4i_, 0, b"<4i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vv4i_

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3))

    def test_clsvv4i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv4i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv4i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv4i_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv4i_, 0, b"<4i>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvv4i_

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3))

    def test_vv4i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vv4i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vv4i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vv4i_, b"v")
        self.assertArgHasType(OC_VectorCall.vv4i_, 0, b"<4i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vv4i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_int4(0, 1, 2, 3))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_int4(0, 1, 2, 3))

    def test_clsvv4i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvv4i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvv4i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvv4i_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvv4i_, 0, b"<4i>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvv4i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3))
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_int4(0, 1, 2, 3))
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_int4(0, 1, 2, 3))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_int4(0, 1, 2, 3))

    def test_imp_vv4i_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv4iOn_(value)
        self.assertIs(result, None)
        self.assertEqual(value.argvalues, (objc.simd.vector_int4(0, 1, 2, 3),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv4iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv4iOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vv4i__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vv4iOn_(value)
        self.assertIs(result, None)
        self.assertEqual(value.argvalues, (objc.simd.vector_int4(0, 1, 2, 3),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vv4iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vv4iOn_(value)
        finally:
            del value.returnInvalid

    def test_vid_v2f_v2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vid_v2f_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vid_v2f_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vid_v2f_v2f_, b"v")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_, 2, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vid_v2f_v2f_

        # Valid call
        rv = caller(
            "hello",
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

    def test_clsvid_v2f_v2f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvid_v2f_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvid_v2f_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvid_v2f_v2f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_, 2, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvid_v2f_v2f_

        # Valid call
        rv = caller(
            "hello",
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

    def test_vid_v2f_v2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vid_v2f_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vid_v2f_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vid_v2f_v2f_, b"v")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_, 2, b"<2f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vid:v2f:v2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

    def test_clsvid_v2f_v2f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvid_v2f_v2f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvid_v2f_v2f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvid_v2f_v2f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_, 2, b"<2f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvid:v2f:v2f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 3)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", objc.simd.vector_float2(0.0, 1.5))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float2(0.0, 1.5))

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", objc.simd.vector_float2(0.0, 1.5), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

    def test_imp_vid_v2f_v2f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vidv2fv2fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vidv2fv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vidv2fv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vid_v2f_v2f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vidv2fv2fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vidv2fv2fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vidv2fv2fOn_(value)
        finally:
            del value.returnInvalid

    def test_vid_v2f_v2f_q_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vid_v2f_v2f_q_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vid_v2f_v2f_q_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vid_v2f_v2f_q_, b"v")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_q_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_q_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_q_, 2, b"<2f>")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_q_, 3, b"q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vid_v2f_v2f_q_

        # Valid call
        rv = caller(
            "hello",
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
            -17592186044416,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[3], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float2(0.0, 1.5), -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", objc.simd.vector_float2(0.0, 1.5), None, -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
            )

    def test_clsvid_v2f_v2f_q_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvid_v2f_v2f_q_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvid_v2f_v2f_q_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvid_v2f_v2f_q_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_q_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_q_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_q_, 2, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_q_, 3, b"q")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvid_v2f_v2f_q_

        # Valid call
        rv = caller(
            "hello",
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
            -17592186044416,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[3], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float2(0.0, 1.5), -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", objc.simd.vector_float2(0.0, 1.5), None, -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
            )

    def test_vid_v2f_v2f_q__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vid_v2f_v2f_q_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vid_v2f_v2f_q_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vid_v2f_v2f_q_, b"v")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_q_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_q_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_q_, 2, b"<2f>")
        self.assertArgHasType(OC_VectorCall.vid_v2f_v2f_q_, 3, b"q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vid:v2f:v2f:q:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
            -17592186044416,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[3], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float2(0.0, 1.5), -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", objc.simd.vector_float2(0.0, 1.5), None, -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
            )

    def test_clsvid_v2f_v2f_q__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvid_v2f_v2f_q_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvid_v2f_v2f_q_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvid_v2f_v2f_q_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_q_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_q_, 1, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_q_, 2, b"<2f>")
        self.assertArgHasType(OC_VectorCall.clsvid_v2f_v2f_q_, 3, b"q")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvid:v2f:v2f:q:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            "hello",
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
            -17592186044416,
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            "hello",
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
            -17592186044416,
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            "hello",
            objc.simd.vector_float2(0.0, 1.5),
            objc.simd.vector_float2(0.0, 1.5),
            -17592186044416,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 4)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[2], objc.simd.vector_float2(0.0, 1.5))
        self.assertEqual(stored[3], -17592186044416)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(
                NoObjCValueObject,
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
            )

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None, objc.simd.vector_float2(0.0, 1.5), -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", objc.simd.vector_float2(0.0, 1.5), None, -17592186044416)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
            )

    def test_imp_vid_v2f_v2f_q_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vidv2fv2fqOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vidv2fv2fqOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vidv2fv2fqOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vid_v2f_v2f_q__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vidv2fv2fqOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                objc.simd.vector_float2(0.0, 1.5),
                objc.simd.vector_float2(0.0, 1.5),
                -17592186044416,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vidv2fv2fqOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vidv2fv2fqOn_(value)
        finally:
            del value.returnInvalid

    def test_vf_v2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vf_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vf_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vf_v2i_, b"v")
        self.assertArgHasType(OC_VectorCall.vf_v2i_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.vf_v2i_, 1, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vf_v2i_

        # Valid call
        rv = caller(2500000000.0, objc.simd.vector_int2(0, 1))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(2500000000.0, objc.simd.vector_int2(0, 1))

    def test_clsvf_v2i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvf_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvf_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvf_v2i_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvf_v2i_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsvf_v2i_, 1, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvf_v2i_

        # Valid call
        rv = caller(2500000000.0, objc.simd.vector_int2(0, 1))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(2500000000.0, objc.simd.vector_int2(0, 1))

    def test_vf_v2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vf_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vf_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vf_v2i_, b"v")
        self.assertArgHasType(OC_VectorCall.vf_v2i_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.vf_v2i_, 1, b"<2i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vf:v2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(2500000000.0, objc.simd.vector_int2(0, 1))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(2500000000.0, objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, 2500000000.0, objc.simd.vector_int2(0, 1))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, 2500000000.0, objc.simd.vector_int2(0, 1))

    def test_clsvf_v2i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvf_v2i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvf_v2i_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvf_v2i_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvf_v2i_, 0, b"f")
        self.assertArgHasType(OC_VectorCall.clsvf_v2i_, 1, b"<2i>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvf:v2i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(2500000000.0, objc.simd.vector_int2(0, 1))
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, 2500000000.0, objc.simd.vector_int2(0, 1))
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(type(oc), 2500000000.0, objc.simd.vector_int2(0, 1))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], 2500000000.0)
        self.assertEqual(stored[1], objc.simd.vector_int2(0, 1))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(2500000000.0, objc.simd.vector_int2(0, 1), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_int2(0, 1))

        with self.assertRaises((TypeError, ValueError)):
            caller(2500000000.0, None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(2500000000.0, objc.simd.vector_int2(0, 1))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, 2500000000.0, objc.simd.vector_int2(0, 1))

    def test_imp_vf_v2i_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vfv2iOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                objc.simd.vector_int2(0, 1),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vfv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vfv2iOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vf_v2i__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vfv2iOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                2500000000.0,
                objc.simd.vector_int2(0, 1),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vfv2iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vfv2iOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_vMDLAxisAlignedBoundingBox_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vMDLAxisAlignedBoundingBox_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vMDLAxisAlignedBoundingBox_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vMDLAxisAlignedBoundingBox_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vMDLAxisAlignedBoundingBox_,
            0,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vMDLAxisAlignedBoundingBox_

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                )
            )

    @min_os_level("10.11")
    def test_clsvMDLAxisAlignedBoundingBox_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvMDLAxisAlignedBoundingBox_,
            0,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvMDLAxisAlignedBoundingBox_

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                )
            )

    @min_os_level("10.11")
    def test_vMDLAxisAlignedBoundingBox__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vMDLAxisAlignedBoundingBox_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vMDLAxisAlignedBoundingBox_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vMDLAxisAlignedBoundingBox_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vMDLAxisAlignedBoundingBox_,
            0,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vMDLAxisAlignedBoundingBox:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
            )

    @min_os_level("10.11")
    def test_clsvMDLAxisAlignedBoundingBox__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvMDLAxisAlignedBoundingBox_,
            0,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvMDLAxisAlignedBoundingBox:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            )
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
            )

    @min_os_level("10.11")
    def test_imp_vMDLAxisAlignedBoundingBox_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vMDLAxisAlignedBoundingBoxOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vMDLAxisAlignedBoundingBoxOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vMDLAxisAlignedBoundingBoxOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_imp_vMDLAxisAlignedBoundingBox__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vMDLAxisAlignedBoundingBoxOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vMDLAxisAlignedBoundingBoxOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vMDLAxisAlignedBoundingBoxOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_vMDLAxisAlignedBoundingBox_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vMDLAxisAlignedBoundingBox_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vMDLAxisAlignedBoundingBox_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vMDLAxisAlignedBoundingBox_Z_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vMDLAxisAlignedBoundingBox_Z_,
            0,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(OC_VectorCall.vMDLAxisAlignedBoundingBox_Z_, 1, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vMDLAxisAlignedBoundingBox_Z_

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
            False,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertEqual(stored[1], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                False,
            )

    @min_os_level("10.11")
    def test_clsvMDLAxisAlignedBoundingBox_Z_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_Z_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvMDLAxisAlignedBoundingBox_Z_,
            0,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_Z_, 1, b"Z")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvMDLAxisAlignedBoundingBox_Z_

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
            False,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertEqual(stored[1], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                False,
            )

    @min_os_level("10.11")
    def test_vMDLAxisAlignedBoundingBox_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vMDLAxisAlignedBoundingBox_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vMDLAxisAlignedBoundingBox_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vMDLAxisAlignedBoundingBox_Z_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vMDLAxisAlignedBoundingBox_Z_,
            0,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(OC_VectorCall.vMDLAxisAlignedBoundingBox_Z_, 1, b"Z")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vMDLAxisAlignedBoundingBox:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
            False,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertEqual(stored[1], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                False,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                False,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                False,
            )

    @min_os_level("10.11")
    def test_clsvMDLAxisAlignedBoundingBox_Z__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_Z_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_Z_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_Z_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvMDLAxisAlignedBoundingBox_Z_,
            0,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(OC_VectorCall.clsvMDLAxisAlignedBoundingBox_Z_, 1, b"Z")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvMDLAxisAlignedBoundingBox:Z:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
            False,
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
            False,
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
            False,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertEqual(stored[1], False)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                False,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, False)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                NoBool(),
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                False,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                False,
            )

    @min_os_level("10.11")
    def test_imp_vMDLAxisAlignedBoundingBox_Z_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vMDLAxisAlignedBoundingBoxZOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vMDLAxisAlignedBoundingBoxZOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vMDLAxisAlignedBoundingBoxZOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_imp_vMDLAxisAlignedBoundingBox_Z__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vMDLAxisAlignedBoundingBoxZOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                (
                    objc.simd.vector_float3(-8.0, -9.0, -10.0),
                    objc.simd.vector_float3(-11.0, -12.0, -13.0),
                ),
                False,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vMDLAxisAlignedBoundingBoxZOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vMDLAxisAlignedBoundingBoxZOn_(value)
        finally:
            del value.returnInvalid

    def test_vsimddouble4x4_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimddouble4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimddouble4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimddouble4x4_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vsimddouble4x4_, 0, b"{simd_double4x4=[4<4d>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vsimddouble4x4_

        # Valid call
        rv = caller(
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

    def test_clsvsimddouble4x4_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimddouble4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimddouble4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimddouble4x4_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvsimddouble4x4_, 0, b"{simd_double4x4=[4<4d>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvsimddouble4x4_

        # Valid call
        rv = caller(
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

    def test_vsimddouble4x4__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimddouble4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimddouble4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimddouble4x4_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vsimddouble4x4_, 0, b"{simd_double4x4=[4<4d>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vsimddouble4x4:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_clsvsimddouble4x4__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimddouble4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimddouble4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimddouble4x4_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvsimddouble4x4_, 0, b"{simd_double4x4=[4<4d>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvsimddouble4x4:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            )
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_imp_vsimddouble4x4_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimddouble4x4On_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimddouble4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimddouble4x4On_(value)
        finally:
            del value.returnInvalid

    def test_imp_vsimddouble4x4__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimddouble4x4On_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimddouble4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimddouble4x4On_(value)
        finally:
            del value.returnInvalid

    def test_vsimddouble4x4_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimddouble4x4_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimddouble4x4_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimddouble4x4_d_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vsimddouble4x4_d_, 0, b"{simd_double4x4=[4<4d>]}"
        )
        self.assertArgHasType(OC_VectorCall.vsimddouble4x4_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vsimddouble4x4_d_

        # Valid call
        rv = caller(
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

    def test_clsvsimddouble4x4_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimddouble4x4_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimddouble4x4_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimddouble4x4_d_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvsimddouble4x4_d_, 0, b"{simd_double4x4=[4<4d>]}"
        )
        self.assertArgHasType(OC_VectorCall.clsvsimddouble4x4_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvsimddouble4x4_d_

        # Valid call
        rv = caller(
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

    def test_vsimddouble4x4_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimddouble4x4_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimddouble4x4_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimddouble4x4_d_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vsimddouble4x4_d_, 0, b"{simd_double4x4=[4<4d>]}"
        )
        self.assertArgHasType(OC_VectorCall.vsimddouble4x4_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vsimddouble4x4:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

    def test_clsvsimddouble4x4_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimddouble4x4_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimddouble4x4_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimddouble4x4_d_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvsimddouble4x4_d_, 0, b"{simd_double4x4=[4<4d>]}"
        )
        self.assertArgHasType(OC_VectorCall.clsvsimddouble4x4_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvsimddouble4x4:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

    def test_imp_vsimddouble4x4_d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimddouble4x4dOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimddouble4x4dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimddouble4x4dOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vsimddouble4x4_d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimddouble4x4dOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_double4x4(
                    (
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimddouble4x4dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimddouble4x4dOn_(value)
        finally:
            del value.returnInvalid

    def test_vsimdfloat2x2_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdfloat2x2_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdfloat2x2_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdfloat2x2_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vsimdfloat2x2_, 0, b"{simd_float2x2=[2<2f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vsimdfloat2x2_

        # Valid call
        rv = caller(
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                )
            )

    def test_clsvsimdfloat2x2_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdfloat2x2_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdfloat2x2_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdfloat2x2_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvsimdfloat2x2_, 0, b"{simd_float2x2=[2<2f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvsimdfloat2x2_

        # Valid call
        rv = caller(
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                )
            )

    def test_vsimdfloat2x2__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdfloat2x2_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdfloat2x2_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdfloat2x2_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vsimdfloat2x2_, 0, b"{simd_float2x2=[2<2f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vsimdfloat2x2:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

    def test_clsvsimdfloat2x2__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdfloat2x2_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdfloat2x2_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdfloat2x2_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvsimdfloat2x2_, 0, b"{simd_float2x2=[2<2f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvsimdfloat2x2:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            )
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            )

    def test_imp_vsimdfloat2x2_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdfloat2x2On_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdfloat2x2On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdfloat2x2On_(value)
        finally:
            del value.returnInvalid

    def test_imp_vsimdfloat2x2__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdfloat2x2On_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float2x2(
                    (
                        objc.simd.vector_float2(0.0, 1.5),
                        objc.simd.vector_float2(0.0, 1.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdfloat2x2On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdfloat2x2On_(value)
        finally:
            del value.returnInvalid

    def test_vsimdfloat3x3_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdfloat3x3_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdfloat3x3_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdfloat3x3_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vsimdfloat3x3_, 0, b"{simd_float3x3=[3<3f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vsimdfloat3x3_

        # Valid call
        rv = caller(
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                )
            )

    def test_clsvsimdfloat3x3_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdfloat3x3_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdfloat3x3_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdfloat3x3_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvsimdfloat3x3_, 0, b"{simd_float3x3=[3<3f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvsimdfloat3x3_

        # Valid call
        rv = caller(
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                )
            )

    def test_vsimdfloat3x3__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdfloat3x3_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdfloat3x3_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdfloat3x3_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vsimdfloat3x3_, 0, b"{simd_float3x3=[3<3f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vsimdfloat3x3:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

    def test_clsvsimdfloat3x3__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdfloat3x3_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdfloat3x3_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdfloat3x3_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvsimdfloat3x3_, 0, b"{simd_float3x3=[3<3f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvsimdfloat3x3:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            )
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            )

    def test_imp_vsimdfloat3x3_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdfloat3x3On_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdfloat3x3On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdfloat3x3On_(value)
        finally:
            del value.returnInvalid

    def test_imp_vsimdfloat3x3__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdfloat3x3On_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float3x3(
                    (
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                        objc.simd.vector_float3(0.0, 1.5, 3.0),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdfloat3x3On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdfloat3x3On_(value)
        finally:
            del value.returnInvalid

    def test_vsimdfloat4x4_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdfloat4x4_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vsimdfloat4x4_, 0, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vsimdfloat4x4_

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

    def test_clsvsimdfloat4x4_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdfloat4x4_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvsimdfloat4x4_, 0, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvsimdfloat4x4_

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

    def test_vsimdfloat4x4__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdfloat4x4_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vsimdfloat4x4_, 0, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vsimdfloat4x4:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            )
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_clsvsimdfloat4x4__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdfloat4x4_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdfloat4x4_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdfloat4x4_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvsimdfloat4x4_, 0, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvsimdfloat4x4:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            )
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            )

    def test_imp_vsimdfloat4x4_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdfloat4x4On_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdfloat4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdfloat4x4On_(value)
        finally:
            del value.returnInvalid

    def test_imp_vsimdfloat4x4__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdfloat4x4On_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdfloat4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdfloat4x4On_(value)
        finally:
            del value.returnInvalid

    def test_vsimdfloat4x4_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdfloat4x4_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdfloat4x4_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdfloat4x4_d_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vsimdfloat4x4_d_, 0, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.vsimdfloat4x4_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vsimdfloat4x4_d_

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

    def test_clsvsimdfloat4x4_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdfloat4x4_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdfloat4x4_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdfloat4x4_d_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvsimdfloat4x4_d_, 0, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.clsvsimdfloat4x4_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvsimdfloat4x4_d_

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

    def test_vsimdfloat4x4_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdfloat4x4_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdfloat4x4_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdfloat4x4_d_, b"v")
        self.assertArgHasType(
            OC_VectorCall.vsimdfloat4x4_d_, 0, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.vsimdfloat4x4_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vsimdfloat4x4:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

    def test_clsvsimdfloat4x4_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdfloat4x4_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdfloat4x4_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdfloat4x4_d_, b"v")
        self.assertArgHasType(
            OC_VectorCall.clsvsimdfloat4x4_d_, 0, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.clsvsimdfloat4x4_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvsimdfloat4x4:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                None,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            )

    def test_imp_vsimdfloat4x4_d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdfloat4x4dOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdfloat4x4dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdfloat4x4dOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_vsimdfloat4x4_d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdfloat4x4dOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdfloat4x4dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdfloat4x4dOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_vsimdquatd_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdquatd_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdquatd_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdquatd_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vsimdquatd_d_, 0, b"{simd_quatd=<4d>}")
        self.assertArgHasType(OC_VectorCall.vsimdquatd_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vsimdquatd_d_

        # Valid call
        rv = caller(
            simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0], simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

    @min_os_level("10.13")
    def test_clsvsimdquatd_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdquatd_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdquatd_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdquatd_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatd_d_, 0, b"{simd_quatd=<4d>}")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatd_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvsimdquatd_d_

        # Valid call
        rv = caller(
            simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0], simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

    @min_os_level("10.13")
    def test_vsimdquatd_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdquatd_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdquatd_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdquatd_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vsimdquatd_d_, 0, b"{simd_quatd=<4d>}")
        self.assertArgHasType(OC_VectorCall.vsimdquatd_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vsimdquatd:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0], simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

    @min_os_level("10.13")
    def test_clsvsimdquatd_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdquatd_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdquatd_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdquatd_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatd_d_, 0, b"{simd_quatd=<4d>}")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatd_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvsimdquatd:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0], simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

    @min_os_level("10.13")
    def test_imp_vsimdquatd_d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdquatddOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdquatddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdquatddOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_imp_vsimdquatd_d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdquatddOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdquatddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdquatddOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_vsimdquatf_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdquatf_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdquatf_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdquatf_, b"v")
        self.assertArgHasType(OC_VectorCall.vsimdquatf_, 0, b"{simd_quatf=<4f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vsimdquatf_

        # Valid call
        rv = caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)), "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

    @min_os_level("10.13")
    def test_clsvsimdquatf_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdquatf_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdquatf_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdquatf_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatf_, 0, b"{simd_quatf=<4f>}")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvsimdquatf_

        # Valid call
        rv = caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)), "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

    @min_os_level("10.13")
    def test_vsimdquatf__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdquatf_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdquatf_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdquatf_, b"v")
        self.assertArgHasType(OC_VectorCall.vsimdquatf_, 0, b"{simd_quatf=<4f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vsimdquatf:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)), "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            )

    @min_os_level("10.13")
    def test_clsvsimdquatf__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdquatf_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdquatf_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdquatf_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatf_, 0, b"{simd_quatf=<4f>}")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvsimdquatf:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(oc_inst, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(type(oc), simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(
            stored[0], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)), "hello"
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

    @min_os_level("10.13")
    def test_imp_vsimdquatf_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdquatfOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdquatfOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdquatfOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_imp_vsimdquatf__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdquatfOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdquatfOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdquatfOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_vsimdquatf_v3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdquatf_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdquatf_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdquatf_v3f_, b"v")
        self.assertArgHasType(OC_VectorCall.vsimdquatf_v3f_, 0, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.vsimdquatf_v3f_, 1, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vsimdquatf_v3f_

        # Valid call
        rv = caller(
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

    @min_os_level("10.13")
    def test_clsvsimdquatf_v3f_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdquatf_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdquatf_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdquatf_v3f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatf_v3f_, 0, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatf_v3f_, 1, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvsimdquatf_v3f_

        # Valid call
        rv = caller(
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

    @min_os_level("10.13")
    def test_vsimdquatf_v3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdquatf_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdquatf_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdquatf_v3f_, b"v")
        self.assertArgHasType(OC_VectorCall.vsimdquatf_v3f_, 0, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.vsimdquatf_v3f_, 1, b"<3f>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vsimdquatf:v3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

    @min_os_level("10.13")
    def test_clsvsimdquatf_v3f__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdquatf_v3f_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdquatf_v3f_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdquatf_v3f_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatf_v3f_, 0, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatf_v3f_, 1, b"<3f>")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvsimdquatf:v3f:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            objc.simd.vector_float3(0.0, 1.5, 3.0),
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[1], objc.simd.vector_float3(0.0, 1.5, 3.0))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, objc.simd.vector_float3(0.0, 1.5, 3.0))

        with self.assertRaises((TypeError, ValueError)):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            )

    @min_os_level("10.13")
    def test_imp_vsimdquatf_v3f_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdquatfv3fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdquatfv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdquatfv3fOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_imp_vsimdquatf_v3f__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdquatfv3fOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                objc.simd.vector_float3(0.0, 1.5, 3.0),
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdquatfv3fOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdquatfv3fOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_vsimdquatf_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdquatf_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdquatf_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdquatf_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vsimdquatf_d_, 0, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.vsimdquatf_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.vsimdquatf_d_

        # Valid call
        rv = caller(
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

    @min_os_level("10.13")
    def test_clsvsimdquatf_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdquatf_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdquatf_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdquatf_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatf_d_, 0, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatf_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsvsimdquatf_d_

        # Valid call
        rv = caller(
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

    @min_os_level("10.13")
    def test_vsimdquatf_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.vsimdquatf_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.vsimdquatf_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.vsimdquatf_d_, b"v")
        self.assertArgHasType(OC_VectorCall.vsimdquatf_d_, 0, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.vsimdquatf_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"vsimdquatf:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

    @min_os_level("10.13")
    def test_clsvsimdquatf_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsvsimdquatf_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsvsimdquatf_d_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsvsimdquatf_d_, b"v")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatf_d_, 0, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.clsvsimdquatf_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsvsimdquatf:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        # Valid call through instance
        rv = imp(
            oc_inst,
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        # Valid call through meta
        rv = imp(
            type(oc),
            simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
            -557000000000.0,
        )
        self.assertIs(rv, None)

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0], simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)))

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller(simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)), None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            )

    @min_os_level("10.13")
    def test_imp_vsimdquatf_d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdquatfdOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdquatfdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdquatfdOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_imp_vsimdquatf_d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.vsimdquatfdOn_(value)
        self.assertIs(result, None)
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5)),
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.vsimdquatfdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.vsimdquatfdOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_GKBox(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.GKBox.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.GKBox)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.GKBox, b"{GKBox=<3f><3f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.GKBox

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.12")
    def test_clsGKBox(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsGKBox.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsGKBox)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsGKBox, b"{GKBox=<3f><3f>}")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsGKBox

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.12")
    def test_GKBox_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.GKBox.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.GKBox)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.GKBox, b"{GKBox=<3f><3f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"GKBox")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    @min_os_level("10.12")
    def test_clsGKBox_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsGKBox.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsGKBox)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsGKBox, b"{GKBox=<3f><3f>}")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsGKBox")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    @min_os_level("10.12")
    def test_imp_GKBox(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.GKBoxOn_(value)
        self.assertEqual(
            result,
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.GKBoxOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.GKBoxOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_imp_GKBox_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.GKBoxOn_(value)
        self.assertEqual(
            result,
            (
                objc.simd.vector_float3(1.0, 2.0, 3.0),
                objc.simd.vector_float3(4.0, 5.0, 6.0),
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.GKBoxOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.GKBoxOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_GKQuad(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.GKQuad.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.GKQuad)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.GKQuad, b"{GKQuad=<2f><2f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.GKQuad

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.12")
    def test_clsGKQuad(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsGKQuad.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsGKQuad)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsGKQuad, b"{GKQuad=<2f><2f>}")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsGKQuad

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.12")
    def test_GKQuad_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.GKQuad.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.GKQuad)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.GKQuad, b"{GKQuad=<2f><2f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"GKQuad")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    @min_os_level("10.12")
    def test_clsGKQuad_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsGKQuad.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsGKQuad)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsGKQuad, b"{GKQuad=<2f><2f>}")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsGKQuad")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(
            rv,
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(
            rv,
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    @min_os_level("10.12")
    def test_imp_GKQuad(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.GKQuadOn_(value)
        self.assertEqual(
            result,
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.GKQuadOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.GKQuadOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_imp_GKQuad_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.GKQuadOn_(value)
        self.assertEqual(
            result,
            (objc.simd.vector_float2(9.0, 10.0), objc.simd.vector_float2(11.0, 12.0)),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.GKQuadOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.GKQuadOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_GKTriangleQ_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.GKTriangleQ_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.GKTriangleQ_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.GKTriangleQ_, b"{GKTriangle=[3<3f>]}")
        self.assertArgHasType(OC_VectorCall.GKTriangleQ_, 0, b"Q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.GKTriangleQ_

        # Valid call
        rv = caller(35184372088832)
        self.assertEqual(
            rv,
            (
                (
                    objc.simd.vector_float3(-18.5, -19.5, -110.5),
                    objc.simd.vector_float3(-111.5, -112.5, -113.5),
                    objc.simd.vector_float3(-17.5, 11.5, 122.5),
                ),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], 35184372088832)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(35184372088832, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(35184372088832)

    @min_os_level("10.12")
    def test_clsGKTriangleQ_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsGKTriangleQ_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsGKTriangleQ_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsGKTriangleQ_, b"{GKTriangle=[3<3f>]}")
        self.assertArgHasType(OC_VectorCall.clsGKTriangleQ_, 0, b"Q")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsGKTriangleQ_

        # Valid call
        rv = caller(35184372088832)
        self.assertEqual(
            rv,
            (
                (
                    objc.simd.vector_float3(-18.5, -19.5, -110.5),
                    objc.simd.vector_float3(-111.5, -112.5, -113.5),
                    objc.simd.vector_float3(-17.5, 11.5, 122.5),
                ),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], 35184372088832)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(35184372088832, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(35184372088832)

    @min_os_level("10.12")
    def test_GKTriangleQ__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.GKTriangleQ_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.GKTriangleQ_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.GKTriangleQ_, b"{GKTriangle=[3<3f>]}")
        self.assertArgHasType(OC_VectorCall.GKTriangleQ_, 0, b"Q")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"GKTriangleQ:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(35184372088832)
        self.assertEqual(
            rv,
            (
                (
                    objc.simd.vector_float3(-18.5, -19.5, -110.5),
                    objc.simd.vector_float3(-111.5, -112.5, -113.5),
                    objc.simd.vector_float3(-17.5, 11.5, 122.5),
                ),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], 35184372088832)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(35184372088832, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(35184372088832)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, 35184372088832)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, 35184372088832)

    @min_os_level("10.12")
    def test_clsGKTriangleQ__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsGKTriangleQ_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsGKTriangleQ_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clsGKTriangleQ_, b"{GKTriangle=[3<3f>]}")
        self.assertArgHasType(OC_VectorCall.clsGKTriangleQ_, 0, b"Q")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsGKTriangleQ:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(35184372088832)
        self.assertEqual(
            rv,
            (
                (
                    objc.simd.vector_float3(-18.5, -19.5, -110.5),
                    objc.simd.vector_float3(-111.5, -112.5, -113.5),
                    objc.simd.vector_float3(-17.5, 11.5, 122.5),
                ),
            ),
        )

        # Valid call through instance
        rv = imp(oc_inst, 35184372088832)
        self.assertEqual(
            rv,
            (
                (
                    objc.simd.vector_float3(-18.5, -19.5, -110.5),
                    objc.simd.vector_float3(-111.5, -112.5, -113.5),
                    objc.simd.vector_float3(-17.5, 11.5, 122.5),
                ),
            ),
        )

        # Valid call through meta
        rv = imp(type(oc), 35184372088832)
        self.assertEqual(
            rv,
            (
                (
                    objc.simd.vector_float3(-18.5, -19.5, -110.5),
                    objc.simd.vector_float3(-111.5, -112.5, -113.5),
                    objc.simd.vector_float3(-17.5, 11.5, 122.5),
                ),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], 35184372088832)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(35184372088832, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(35184372088832)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, 35184372088832)

    @min_os_level("10.12")
    def test_imp_GKTriangleQ_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.GKTriangleQOn_(value)
        self.assertEqual(
            result,
            (
                (
                    objc.simd.vector_float3(-18.5, -19.5, -110.5),
                    objc.simd.vector_float3(-111.5, -112.5, -113.5),
                    objc.simd.vector_float3(-17.5, 11.5, 122.5),
                ),
            ),
        )
        self.assertEqual(value.argvalues, (35184372088832,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.GKTriangleQOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.GKTriangleQOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.12")
    def test_imp_GKTriangleQ__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.GKTriangleQOn_(value)
        self.assertEqual(
            result,
            (
                (
                    objc.simd.vector_float3(-18.5, -19.5, -110.5),
                    objc.simd.vector_float3(-111.5, -112.5, -113.5),
                    objc.simd.vector_float3(-17.5, 11.5, 122.5),
                ),
            ),
        )
        self.assertEqual(value.argvalues, (35184372088832,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.GKTriangleQOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.GKTriangleQOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_MDLAxisAlignedBoundingBox(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.MDLAxisAlignedBoundingBox.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.MDLAxisAlignedBoundingBox)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.MDLAxisAlignedBoundingBox,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.MDLAxisAlignedBoundingBox

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.11")
    def test_clsMDLAxisAlignedBoundingBox(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsMDLAxisAlignedBoundingBox.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsMDLAxisAlignedBoundingBox)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsMDLAxisAlignedBoundingBox,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsMDLAxisAlignedBoundingBox

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.11")
    def test_MDLAxisAlignedBoundingBox_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.MDLAxisAlignedBoundingBox.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.MDLAxisAlignedBoundingBox)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.MDLAxisAlignedBoundingBox,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"MDLAxisAlignedBoundingBox")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    @min_os_level("10.11")
    def test_clsMDLAxisAlignedBoundingBox_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsMDLAxisAlignedBoundingBox.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsMDLAxisAlignedBoundingBox)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsMDLAxisAlignedBoundingBox,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsMDLAxisAlignedBoundingBox")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    @min_os_level("10.11")
    def test_imp_MDLAxisAlignedBoundingBox(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxOn_(value)
        self.assertEqual(
            result,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_imp_MDLAxisAlignedBoundingBox_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxOn_(value)
        self.assertEqual(
            result,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_MDLAxisAlignedBoundingBoxv4i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.MDLAxisAlignedBoundingBoxv4i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.MDLAxisAlignedBoundingBoxv4i_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.MDLAxisAlignedBoundingBoxv4i_,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(OC_VectorCall.MDLAxisAlignedBoundingBoxv4i_, 0, b"<4i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.MDLAxisAlignedBoundingBoxv4i_

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3))

    @min_os_level("10.11")
    def test_clsMDLAxisAlignedBoundingBoxv4i_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsMDLAxisAlignedBoundingBoxv4i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsMDLAxisAlignedBoundingBoxv4i_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsMDLAxisAlignedBoundingBoxv4i_,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(
            OC_VectorCall.clsMDLAxisAlignedBoundingBoxv4i_, 0, b"<4i>"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsMDLAxisAlignedBoundingBoxv4i_

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3))

    @min_os_level("10.11")
    def test_MDLAxisAlignedBoundingBoxv4i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.MDLAxisAlignedBoundingBoxv4i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.MDLAxisAlignedBoundingBoxv4i_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.MDLAxisAlignedBoundingBoxv4i_,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(OC_VectorCall.MDLAxisAlignedBoundingBoxv4i_, 0, b"<4i>")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"MDLAxisAlignedBoundingBoxv4i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3))

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, objc.simd.vector_int4(0, 1, 2, 3))

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, objc.simd.vector_int4(0, 1, 2, 3))

    @min_os_level("10.11")
    def test_clsMDLAxisAlignedBoundingBoxv4i__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsMDLAxisAlignedBoundingBoxv4i_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsMDLAxisAlignedBoundingBoxv4i_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsMDLAxisAlignedBoundingBoxv4i_,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(
            OC_VectorCall.clsMDLAxisAlignedBoundingBoxv4i_, 0, b"<4i>"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsMDLAxisAlignedBoundingBoxv4i:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        # Valid call through instance
        rv = imp(oc_inst, objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        # Valid call through meta
        rv = imp(type(oc), objc.simd.vector_int4(0, 1, 2, 3))
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], objc.simd.vector_int4(0, 1, 2, 3))

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(objc.simd.vector_int4(0, 1, 2, 3), "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(objc.simd.vector_int4(0, 1, 2, 3))

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, objc.simd.vector_int4(0, 1, 2, 3))

    @min_os_level("10.11")
    def test_imp_MDLAxisAlignedBoundingBoxv4i_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxv4iOn_(value)
        self.assertEqual(
            result,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertEqual(value.argvalues, (objc.simd.vector_int4(0, 1, 2, 3),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxv4iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxv4iOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_imp_MDLAxisAlignedBoundingBoxv4i__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxv4iOn_(value)
        self.assertEqual(
            result,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertEqual(value.argvalues, (objc.simd.vector_int4(0, 1, 2, 3),))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxv4iOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxv4iOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_MDLAxisAlignedBoundingBoxd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.MDLAxisAlignedBoundingBoxd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.MDLAxisAlignedBoundingBoxd_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.MDLAxisAlignedBoundingBoxd_,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(OC_VectorCall.MDLAxisAlignedBoundingBoxd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.MDLAxisAlignedBoundingBoxd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    @min_os_level("10.11")
    def test_clsMDLAxisAlignedBoundingBoxd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsMDLAxisAlignedBoundingBoxd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsMDLAxisAlignedBoundingBoxd_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsMDLAxisAlignedBoundingBoxd_,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(OC_VectorCall.clsMDLAxisAlignedBoundingBoxd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsMDLAxisAlignedBoundingBoxd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    @min_os_level("10.11")
    def test_MDLAxisAlignedBoundingBoxd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.MDLAxisAlignedBoundingBoxd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.MDLAxisAlignedBoundingBoxd_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.MDLAxisAlignedBoundingBoxd_,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(OC_VectorCall.MDLAxisAlignedBoundingBoxd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"MDLAxisAlignedBoundingBoxd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, -557000000000.0)

    @min_os_level("10.11")
    def test_clsMDLAxisAlignedBoundingBoxd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsMDLAxisAlignedBoundingBoxd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsMDLAxisAlignedBoundingBoxd_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsMDLAxisAlignedBoundingBoxd_,
            b"{MDLAxisAlignedBoundingBox=<3f><3f>}",
        )
        self.assertArgHasType(OC_VectorCall.clsMDLAxisAlignedBoundingBoxd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsMDLAxisAlignedBoundingBoxd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        # Valid call through instance
        rv = imp(oc_inst, -557000000000.0)
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        # Valid call through meta
        rv = imp(type(oc), -557000000000.0)
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, -557000000000.0)

    @min_os_level("10.11")
    def test_imp_MDLAxisAlignedBoundingBoxd_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxdOn_(value)
        self.assertEqual(
            result,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxdOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_imp_MDLAxisAlignedBoundingBoxd__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxdOn_(value)
        self.assertEqual(
            result,
            (
                objc.simd.vector_float3(-8.0, -9.0, -10.0),
                objc.simd.vector_float3(-11.0, -12.0, -13.0),
            ),
        )
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.MDLAxisAlignedBoundingBoxdOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_MDLVoxelIndexExtent(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.MDLVoxelIndexExtent.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.MDLVoxelIndexExtent)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.MDLVoxelIndexExtent, b"{MDLVoxelIndexExtent=<4i><4i>}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.MDLVoxelIndexExtent

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.11")
    def test_clsMDLVoxelIndexExtent(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsMDLVoxelIndexExtent.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsMDLVoxelIndexExtent)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsMDLVoxelIndexExtent, b"{MDLVoxelIndexExtent=<4i><4i>}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsMDLVoxelIndexExtent

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.11")
    def test_MDLVoxelIndexExtent_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.MDLVoxelIndexExtent.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.MDLVoxelIndexExtent)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.MDLVoxelIndexExtent, b"{MDLVoxelIndexExtent=<4i><4i>}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"MDLVoxelIndexExtent")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    @min_os_level("10.11")
    def test_clsMDLVoxelIndexExtent_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsMDLVoxelIndexExtent.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsMDLVoxelIndexExtent)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsMDLVoxelIndexExtent, b"{MDLVoxelIndexExtent=<4i><4i>}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsMDLVoxelIndexExtent")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(
            rv,
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(
            rv,
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    @min_os_level("10.11")
    def test_imp_MDLVoxelIndexExtent(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.MDLVoxelIndexExtentOn_(value)
        self.assertEqual(
            result,
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.MDLVoxelIndexExtentOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.MDLVoxelIndexExtentOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.11")
    def test_imp_MDLVoxelIndexExtent_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.MDLVoxelIndexExtentOn_(value)
        self.assertEqual(
            result,
            (
                objc.simd.vector_int4(100, 101, 102, 103),
                objc.simd.vector_int4(-20, -21, -22, -23),
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.MDLVoxelIndexExtentOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.MDLVoxelIndexExtentOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_MPSImageHistogramInfo(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.MPSImageHistogramInfo.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.MPSImageHistogramInfo)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.MPSImageHistogramInfo, b"{MPSImageHistogramInfo=QZ<4f><4f>}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.MPSImageHistogramInfo

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                4398046511104,
                True,
                objc.simd.vector_float4(1.0, 2.0, 3.0, 4.0),
                objc.simd.vector_float4(-1.0, -2.0, -3.0, -4.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.13")
    def test_clsMPSImageHistogramInfo(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsMPSImageHistogramInfo.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsMPSImageHistogramInfo)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsMPSImageHistogramInfo,
            b"{MPSImageHistogramInfo=QZ<4f><4f>}",
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsMPSImageHistogramInfo

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                4398046511104,
                True,
                objc.simd.vector_float4(1.0, 2.0, 3.0, 4.0),
                objc.simd.vector_float4(-1.0, -2.0, -3.0, -4.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.13")
    def test_MPSImageHistogramInfo_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.MPSImageHistogramInfo.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.MPSImageHistogramInfo)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.MPSImageHistogramInfo, b"{MPSImageHistogramInfo=QZ<4f><4f>}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"MPSImageHistogramInfo")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                4398046511104,
                True,
                objc.simd.vector_float4(1.0, 2.0, 3.0, 4.0),
                objc.simd.vector_float4(-1.0, -2.0, -3.0, -4.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    @min_os_level("10.13")
    def test_clsMPSImageHistogramInfo_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsMPSImageHistogramInfo.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsMPSImageHistogramInfo)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsMPSImageHistogramInfo,
            b"{MPSImageHistogramInfo=QZ<4f><4f>}",
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsMPSImageHistogramInfo")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                4398046511104,
                True,
                objc.simd.vector_float4(1.0, 2.0, 3.0, 4.0),
                objc.simd.vector_float4(-1.0, -2.0, -3.0, -4.0),
            ),
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(
            rv,
            (
                4398046511104,
                True,
                objc.simd.vector_float4(1.0, 2.0, 3.0, 4.0),
                objc.simd.vector_float4(-1.0, -2.0, -3.0, -4.0),
            ),
        )

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(
            rv,
            (
                4398046511104,
                True,
                objc.simd.vector_float4(1.0, 2.0, 3.0, 4.0),
                objc.simd.vector_float4(-1.0, -2.0, -3.0, -4.0),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    @min_os_level("10.13")
    def test_imp_MPSImageHistogramInfo(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.MPSImageHistogramInfoOn_(value)
        self.assertEqual(
            result,
            (
                4398046511104,
                True,
                objc.simd.vector_float4(1.0, 2.0, 3.0, 4.0),
                objc.simd.vector_float4(-1.0, -2.0, -3.0, -4.0),
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.MPSImageHistogramInfoOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.MPSImageHistogramInfoOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_imp_MPSImageHistogramInfo_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.MPSImageHistogramInfoOn_(value)
        self.assertEqual(
            result,
            (
                4398046511104,
                True,
                objc.simd.vector_float4(1.0, 2.0, 3.0, 4.0),
                objc.simd.vector_float4(-1.0, -2.0, -3.0, -4.0),
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.MPSImageHistogramInfoOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.MPSImageHistogramInfoOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.14")
    def test_MPSAxisAlignedBoundingBox(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.MPSAxisAlignedBoundingBox.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.MPSAxisAlignedBoundingBox)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.MPSAxisAlignedBoundingBox,
            b"{_MPSAxisAlignedBoundingBox=<3f><3f>}",
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.MPSAxisAlignedBoundingBox

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(1.5, 2.5, 3.5),
                objc.simd.vector_float3(4.5, 5.5, 6.5),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.14")
    def test_clsMPSAxisAlignedBoundingBox(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsMPSAxisAlignedBoundingBox.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsMPSAxisAlignedBoundingBox)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsMPSAxisAlignedBoundingBox,
            b"{_MPSAxisAlignedBoundingBox=<3f><3f>}",
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clsMPSAxisAlignedBoundingBox

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(1.5, 2.5, 3.5),
                objc.simd.vector_float3(4.5, 5.5, 6.5),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.14")
    def test_MPSAxisAlignedBoundingBox_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.MPSAxisAlignedBoundingBox.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.MPSAxisAlignedBoundingBox)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.MPSAxisAlignedBoundingBox,
            b"{_MPSAxisAlignedBoundingBox=<3f><3f>}",
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"MPSAxisAlignedBoundingBox")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(1.5, 2.5, 3.5),
                objc.simd.vector_float3(4.5, 5.5, 6.5),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    @min_os_level("10.14")
    def test_clsMPSAxisAlignedBoundingBox_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clsMPSAxisAlignedBoundingBox.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clsMPSAxisAlignedBoundingBox)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clsMPSAxisAlignedBoundingBox,
            b"{_MPSAxisAlignedBoundingBox=<3f><3f>}",
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clsMPSAxisAlignedBoundingBox")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(1.5, 2.5, 3.5),
                objc.simd.vector_float3(4.5, 5.5, 6.5),
            ),
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(1.5, 2.5, 3.5),
                objc.simd.vector_float3(4.5, 5.5, 6.5),
            ),
        )

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(
            rv,
            (
                objc.simd.vector_float3(1.5, 2.5, 3.5),
                objc.simd.vector_float3(4.5, 5.5, 6.5),
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    @min_os_level("10.14")
    def test_imp_MPSAxisAlignedBoundingBox(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.MPSAxisAlignedBoundingBoxOn_(value)
        self.assertEqual(
            result,
            (
                objc.simd.vector_float3(1.5, 2.5, 3.5),
                objc.simd.vector_float3(4.5, 5.5, 6.5),
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.MPSAxisAlignedBoundingBoxOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.MPSAxisAlignedBoundingBoxOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.14")
    def test_imp_MPSAxisAlignedBoundingBox_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.MPSAxisAlignedBoundingBoxOn_(value)
        self.assertEqual(
            result,
            (
                objc.simd.vector_float3(1.5, 2.5, 3.5),
                objc.simd.vector_float3(4.5, 5.5, 6.5),
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.MPSAxisAlignedBoundingBoxOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.MPSAxisAlignedBoundingBoxOn_(value)
        finally:
            del value.returnInvalid

    def test_simddouble4x4(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simddouble4x4.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simddouble4x4)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.simddouble4x4, b"{simd_double4x4=[4<4d>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.simddouble4x4

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_clssimddouble4x4(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimddouble4x4.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimddouble4x4)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimddouble4x4, b"{simd_double4x4=[4<4d>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clssimddouble4x4

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_simddouble4x4_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simddouble4x4.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simddouble4x4)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.simddouble4x4, b"{simd_double4x4=[4<4d>]}"
        )

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"simddouble4x4")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    def test_clssimddouble4x4_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimddouble4x4.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimddouble4x4)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimddouble4x4, b"{simd_double4x4=[4<4d>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clssimddouble4x4")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(
            rv,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(
            rv,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    def test_imp_simddouble4x4(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.simddouble4x4On_(value)
        self.assertEqual(
            result,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simddouble4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simddouble4x4On_(value)
        finally:
            del value.returnInvalid

    def test_imp_simddouble4x4_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.simddouble4x4On_(value)
        self.assertEqual(
            result,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simddouble4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simddouble4x4On_(value)
        finally:
            del value.returnInvalid

    def test_simddouble4x4d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simddouble4x4d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simddouble4x4d_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.simddouble4x4d_, b"{simd_double4x4=[4<4d>]}"
        )
        self.assertArgHasType(OC_VectorCall.simddouble4x4d_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.simddouble4x4d_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_clssimddouble4x4d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimddouble4x4d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimddouble4x4d_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimddouble4x4d_, b"{simd_double4x4=[4<4d>]}"
        )
        self.assertArgHasType(OC_VectorCall.clssimddouble4x4d_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clssimddouble4x4d_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_simddouble4x4d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simddouble4x4d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simddouble4x4d_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.simddouble4x4d_, b"{simd_double4x4=[4<4d>]}"
        )
        self.assertArgHasType(OC_VectorCall.simddouble4x4d_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"simddouble4x4d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, -557000000000.0)

    def test_clssimddouble4x4d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimddouble4x4d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimddouble4x4d_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimddouble4x4d_, b"{simd_double4x4=[4<4d>]}"
        )
        self.assertArgHasType(OC_VectorCall.clssimddouble4x4d_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clssimddouble4x4d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Valid call through instance
        rv = imp(oc_inst, -557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Valid call through meta
        rv = imp(type(oc), -557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, -557000000000.0)

    def test_imp_simddouble4x4d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.simddouble4x4dOn_(value)
        self.assertEqual(
            result,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simddouble4x4dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simddouble4x4dOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_simddouble4x4d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.simddouble4x4dOn_(value)
        self.assertEqual(
            result,
            simd.simd_double4x4(
                (
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simddouble4x4dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simddouble4x4dOn_(value)
        finally:
            del value.returnInvalid

    def test_simdfloat2x2(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat2x2.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat2x2)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdfloat2x2, b"{simd_float2x2=[2<2f>]}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.simdfloat2x2

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_clssimdfloat2x2(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat2x2.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat2x2)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat2x2, b"{simd_float2x2=[2<2f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clssimdfloat2x2

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_simdfloat2x2_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat2x2.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat2x2)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdfloat2x2, b"{simd_float2x2=[2<2f>]}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"simdfloat2x2")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    def test_clssimdfloat2x2_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat2x2.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat2x2)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat2x2, b"{simd_float2x2=[2<2f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clssimdfloat2x2")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(
            rv,
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(
            rv,
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    def test_imp_simdfloat2x2(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat2x2On_(value)
        self.assertEqual(
            result,
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat2x2On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat2x2On_(value)
        finally:
            del value.returnInvalid

    def test_imp_simdfloat2x2_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat2x2On_(value)
        self.assertEqual(
            result,
            simd.simd_float2x2(
                (objc.simd.vector_float2(0.0, 1.5), objc.simd.vector_float2(0.0, 1.5))
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat2x2On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat2x2On_(value)
        finally:
            del value.returnInvalid

    def test_simdfloat3x3(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat3x3.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat3x3)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdfloat3x3, b"{simd_float3x3=[3<3f>]}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.simdfloat3x3

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_clssimdfloat3x3(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat3x3.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat3x3)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat3x3, b"{simd_float3x3=[3<3f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clssimdfloat3x3

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_simdfloat3x3_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat3x3.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat3x3)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdfloat3x3, b"{simd_float3x3=[3<3f>]}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"simdfloat3x3")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    def test_clssimdfloat3x3_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat3x3.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat3x3)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat3x3, b"{simd_float3x3=[3<3f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clssimdfloat3x3")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(
            rv,
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(
            rv,
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    def test_imp_simdfloat3x3(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat3x3On_(value)
        self.assertEqual(
            result,
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat3x3On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat3x3On_(value)
        finally:
            del value.returnInvalid

    def test_imp_simdfloat3x3_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat3x3On_(value)
        self.assertEqual(
            result,
            simd.simd_float3x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat3x3On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat3x3On_(value)
        finally:
            del value.returnInvalid

    def test_simdfloat4x3(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat4x3.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat4x3)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdfloat4x3, b"{simd_float4x3=[4<3f>]}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.simdfloat4x3

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float4x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_clssimdfloat4x3(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat4x3.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat4x3)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat4x3, b"{simd_float4x3=[4<3f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clssimdfloat4x3

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float4x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_simdfloat4x3_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat4x3.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat4x3)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdfloat4x3, b"{simd_float4x3=[4<3f>]}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"simdfloat4x3")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float4x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    def test_clssimdfloat4x3_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat4x3.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat4x3)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat4x3, b"{simd_float4x3=[4<3f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clssimdfloat4x3")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float4x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(
            rv,
            simd.simd_float4x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(
            rv,
            simd.simd_float4x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    def test_imp_simdfloat4x3(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat4x3On_(value)
        self.assertEqual(
            result,
            simd.simd_float4x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat4x3On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat4x3On_(value)
        finally:
            del value.returnInvalid

    def test_imp_simdfloat4x3_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat4x3On_(value)
        self.assertEqual(
            result,
            simd.simd_float4x3(
                (
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                    objc.simd.vector_float3(0.0, 1.5, 3.0),
                )
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat4x3On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat4x3On_(value)
        finally:
            del value.returnInvalid

    def test_simdfloat4x4(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat4x4.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat4x4)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdfloat4x4, b"{simd_float4x4=[4<4f>]}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.simdfloat4x4

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_clssimdfloat4x4(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat4x4.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat4x4)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat4x4, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clssimdfloat4x4

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    def test_simdfloat4x4_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat4x4.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat4x4)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdfloat4x4, b"{simd_float4x4=[4<4f>]}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"simdfloat4x4")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    def test_clssimdfloat4x4_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat4x4.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat4x4)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat4x4, b"{simd_float4x4=[4<4f>]}"
        )

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clssimdfloat4x4")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    def test_imp_simdfloat4x4(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat4x4On_(value)
        self.assertEqual(
            result,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat4x4On_(value)
        finally:
            del value.returnInvalid

    def test_imp_simdfloat4x4_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat4x4On_(value)
        self.assertEqual(
            result,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat4x4On_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat4x4On_(value)
        finally:
            del value.returnInvalid

    def test_simdfloat4x4id_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat4x4id_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat4x4id_d_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.simdfloat4x4id_d_, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.simdfloat4x4id_d_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.simdfloat4x4id_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.simdfloat4x4id_d_

        # Valid call
        rv = caller("hello", -557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", -557000000000.0)

    def test_clssimdfloat4x4id_d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat4x4id_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat4x4id_d_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat4x4id_d_, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.clssimdfloat4x4id_d_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clssimdfloat4x4id_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clssimdfloat4x4id_d_

        # Valid call
        rv = caller("hello", -557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", -557000000000.0)

    def test_simdfloat4x4id_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat4x4id_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat4x4id_d_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.simdfloat4x4id_d_, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.simdfloat4x4id_d_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.simdfloat4x4id_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"simdfloat4x4id:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", -557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, "hello", -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, "hello", -557000000000.0)

    def test_clssimdfloat4x4id_d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat4x4id_d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat4x4id_d_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat4x4id_d_, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.clssimdfloat4x4id_d_, 0, b"@")
        self.assertArgHasType(OC_VectorCall.clssimdfloat4x4id_d_, 1, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clssimdfloat4x4id:d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller("hello", -557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Valid call through instance
        rv = imp(oc_inst, "hello", -557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Valid call through meta
        rv = imp(type(oc), "hello", -557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(stored[0], "hello")
        self.assertEqual(stored[1], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello", -557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(NoObjCValueObject, -557000000000.0)

        with self.assertRaises((TypeError, ValueError)):
            caller("hello", None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller("hello", -557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, "hello", -557000000000.0)

    def test_imp_simdfloat4x4id_d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat4x4iddOn_(value)
        self.assertEqual(
            result,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat4x4iddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat4x4iddOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_simdfloat4x4id_d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat4x4iddOn_(value)
        self.assertEqual(
            result,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(
            value.argvalues,
            (
                "hello",
                -557000000000.0,
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat4x4iddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat4x4iddOn_(value)
        finally:
            del value.returnInvalid

    def test_simdfloat4x4d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat4x4d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat4x4d_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.simdfloat4x4d_, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.simdfloat4x4d_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.simdfloat4x4d_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_clssimdfloat4x4d_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat4x4d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat4x4d_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat4x4d_, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.clssimdfloat4x4d_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clssimdfloat4x4d_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    def test_simdfloat4x4d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat4x4d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat4x4d_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.simdfloat4x4d_, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.simdfloat4x4d_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"simdfloat4x4d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, -557000000000.0)

    def test_clssimdfloat4x4d__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat4x4d_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat4x4d_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat4x4d_, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.clssimdfloat4x4d_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clssimdfloat4x4d:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Valid call through instance
        rv = imp(oc_inst, -557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Valid call through meta
        rv = imp(type(oc), -557000000000.0)
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, -557000000000.0)

    def test_imp_simdfloat4x4d_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat4x4dOn_(value)
        self.assertEqual(
            result,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat4x4dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat4x4dOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_simdfloat4x4d__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat4x4dOn_(value)
        self.assertEqual(
            result,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat4x4dOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat4x4dOn_(value)
        finally:
            del value.returnInvalid

    def test_simdfloat4x4simdfloat4x4_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat4x4simdfloat4x4_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat4x4simdfloat4x4_id_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.simdfloat4x4simdfloat4x4_id_, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(
            OC_VectorCall.simdfloat4x4simdfloat4x4_id_, 0, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.simdfloat4x4simdfloat4x4_id_, 1, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.simdfloat4x4simdfloat4x4_id_

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            "hello",
        )
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

    def test_clssimdfloat4x4simdfloat4x4_id_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat4x4simdfloat4x4_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat4x4simdfloat4x4_id_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat4x4simdfloat4x4_id_, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(
            OC_VectorCall.clssimdfloat4x4simdfloat4x4_id_, 0, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.clssimdfloat4x4simdfloat4x4_id_, 1, b"@")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clssimdfloat4x4simdfloat4x4_id_

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            "hello",
        )
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

    def test_simdfloat4x4simdfloat4x4_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdfloat4x4simdfloat4x4_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdfloat4x4simdfloat4x4_id_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.simdfloat4x4simdfloat4x4_id_, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(
            OC_VectorCall.simdfloat4x4simdfloat4x4_id_, 0, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.simdfloat4x4simdfloat4x4_id_, 1, b"@")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"simdfloat4x4simdfloat4x4:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            "hello",
        )
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

    def test_clssimdfloat4x4simdfloat4x4_id__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdfloat4x4simdfloat4x4_id_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdfloat4x4simdfloat4x4_id_)
        # Check that the signature is as expected
        self.assertResultHasType(
            OC_VectorCall.clssimdfloat4x4simdfloat4x4_id_, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(
            OC_VectorCall.clssimdfloat4x4simdfloat4x4_id_, 0, b"{simd_float4x4=[4<4f>]}"
        )
        self.assertArgHasType(OC_VectorCall.clssimdfloat4x4simdfloat4x4_id_, 1, b"@")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clssimdfloat4x4simdfloat4x4:id:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            "hello",
        )
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            "hello",
        )
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        # Valid call through meta
        rv = imp(
            type(oc),
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
            "hello",
        )
        self.assertEqual(
            rv,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 2)
        self.assertEqual(
            stored[0],
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(stored[1], "hello")

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                )
            )

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
                "hello",
            )

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None, "hello")

        with self.assertRaises((TypeError, ValueError)):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                NoObjCValueObject,
            )

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            )

    def test_imp_simdfloat4x4simdfloat4x4_id_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat4x4simdfloat4x4idOn_(value)
        self.assertEqual(
            result,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat4x4simdfloat4x4idOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat4x4simdfloat4x4idOn_(value)
        finally:
            del value.returnInvalid

    def test_imp_simdfloat4x4simdfloat4x4_id__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdfloat4x4simdfloat4x4idOn_(value)
        self.assertEqual(
            result,
            simd.simd_float4x4(
                (
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                )
            ),
        )
        self.assertEqual(
            value.argvalues,
            (
                simd.simd_float4x4(
                    (
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                        objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5),
                    )
                ),
                "hello",
            ),
        )

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdfloat4x4simdfloat4x4idOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdfloat4x4simdfloat4x4idOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_simdquatdd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdquatdd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdquatdd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdquatdd_, b"{simd_quatd=<4d>}")
        self.assertArgHasType(OC_VectorCall.simdquatdd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.simdquatdd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv, simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    @min_os_level("10.13")
    def test_clssimdquatdd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdquatdd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdquatdd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clssimdquatdd_, b"{simd_quatd=<4d>}")
        self.assertArgHasType(OC_VectorCall.clssimdquatdd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clssimdquatdd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv, simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    @min_os_level("10.13")
    def test_simdquatdd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdquatdd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdquatdd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdquatdd_, b"{simd_quatd=<4d>}")
        self.assertArgHasType(OC_VectorCall.simdquatdd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"simdquatdd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv, simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, -557000000000.0)

    @min_os_level("10.13")
    def test_clssimdquatdd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdquatdd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdquatdd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clssimdquatdd_, b"{simd_quatd=<4d>}")
        self.assertArgHasType(OC_VectorCall.clssimdquatdd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clssimdquatdd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv, simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        )

        # Valid call through instance
        rv = imp(oc_inst, -557000000000.0)
        self.assertEqual(
            rv, simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        )

        # Valid call through meta
        rv = imp(type(oc), -557000000000.0)
        self.assertEqual(
            rv, simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, -557000000000.0)

    @min_os_level("10.13")
    def test_imp_simdquatdd_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdquatddOn_(value)
        self.assertEqual(
            result, simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdquatddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdquatddOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_imp_simdquatdd__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdquatddOn_(value)
        self.assertEqual(
            result, simd.simd_quatd(objc.simd.vector_double4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdquatddOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdquatddOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_simdquatf(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdquatf.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdquatf)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdquatf, b"{simd_quatf=<4f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.simdquatf

        # Valid call
        rv = caller()
        self.assertEqual(
            rv, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.13")
    def test_clssimdquatf(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdquatf.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdquatf)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clssimdquatf, b"{simd_quatf=<4f>}")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clssimdquatf

        # Valid call
        rv = caller()
        self.assertEqual(
            rv, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

    @min_os_level("10.13")
    def test_simdquatf_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdquatf.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdquatf)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdquatf, b"{simd_quatf=<4f>}")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"simdquatf")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(
                42,
            )

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(
                NoObjCValueObject,
            )

    @min_os_level("10.13")
    def test_clssimdquatf_imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdquatf.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdquatf)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clssimdquatf, b"{simd_quatf=<4f>}")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clssimdquatf")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller()
        self.assertEqual(
            rv, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        # Valid call through instance
        rv = imp(
            oc_inst,
        )
        self.assertEqual(
            rv, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        # Valid call through meta
        rv = imp(
            type(oc),
        )
        self.assertEqual(
            rv, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 0)

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller("hello")

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller()

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(
                42,
            )

    @min_os_level("10.13")
    def test_imp_simdquatf(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdquatfOn_(value)
        self.assertEqual(
            result, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdquatfOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdquatfOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_imp_simdquatf_cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdquatfOn_(value)
        self.assertEqual(
            result, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertIs(value.argvalues, None)

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdquatfOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdquatfOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_simdquatfd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdquatfd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdquatfd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdquatfd_, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.simdquatfd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.simdquatfd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    @min_os_level("10.13")
    def test_clssimdquatfd_(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdquatfd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdquatfd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clssimdquatfd_, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.clssimdquatfd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        caller = oc.clssimdquatfd_

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

    @min_os_level("10.13")
    def test_simdquatfd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertFalse(OC_VectorCall.simdquatfd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.simdquatfd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.simdquatfd_, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.simdquatfd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"simdquatfd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(ValueError, "unrecognized selector"):
            imp(42, -557000000000.0)

        with self.assertRaisesRegex(TypeError, "Cannot proxy"):
            imp(NoObjCValueObject, -557000000000.0)

    @min_os_level("10.13")
    def test_clssimdquatfd__imp(self):
        OC_VectorCall.clearRaise()
        # Verify method type
        self.assertTrue(OC_VectorCall.clssimdquatfd_.isClassMethod)
        # Verify that method is not an initializer
        self.assertIsNotInitializer(OC_VectorCall.clssimdquatfd_)
        # Check that the signature is as expected
        self.assertResultHasType(OC_VectorCall.clssimdquatfd_, b"{simd_quatf=<4f>}")
        self.assertArgHasType(OC_VectorCall.clssimdquatfd_, 0, b"d")

        # Create test object
        oc = OC_VectorCall
        oc_inst = OC_VectorCall.alloc().init()
        self.assertIsNot(oc, None)

        # Set caller to the selector/IMP to call (With bound self)
        imp = oc.methodForSelector_(b"clssimdquatfd:")
        self.assertIsInstance(imp, objc.IMP)
        caller = partial(imp, oc)

        # Valid call
        rv = caller(-557000000000.0)
        self.assertEqual(
            rv, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        # Valid call through instance
        rv = imp(oc_inst, -557000000000.0)
        self.assertEqual(
            rv, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        # Valid call through meta
        rv = imp(type(oc), -557000000000.0)
        self.assertEqual(
            rv, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )

        stored = oc.storedvalue()
        self.assertIsInstance(stored, (list, tuple))
        self.assertEqual(len(stored), 1)
        self.assertEqual(stored[0], -557000000000.0)

        # Too few arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller()

        # Too many arguments call
        with self.assertRaisesRegex(TypeError, "expected.*arguments.*got"):
            caller(-557000000000.0, "hello")

        # Bad value for arguments
        with self.assertRaises((TypeError, ValueError)):
            caller(None)

        # Exception handling
        OC_VectorCall.setRaise()
        with self.assertRaisesRegex(objc.error, "SimpleException"):
            caller(-557000000000.0)

        # Call with invalid type for self
        with self.assertRaisesRegex(
            TypeError, "Need Objective-C object or class as self"
        ):
            imp(42, -557000000000.0)

    @min_os_level("10.13")
    def test_imp_simdquatfd_(self):
        value = OC_VectorCallInstance.alloc().init()
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdquatfdOn_(value)
        self.assertEqual(
            result, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdquatfdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdquatfdOn_(value)
        finally:
            del value.returnInvalid

    @min_os_level("10.13")
    def test_imp_simdquatfd__cls(self):
        value = OC_VectorCallClass
        value.argvalues = 1
        result = OC_VectorCallInvoke.simdquatfdOn_(value)
        self.assertEqual(
            result, simd.simd_quatf(objc.simd.vector_float4(0.0, 1.5, 3.0, 4.5))
        )
        self.assertEqual(value.argvalues, (-557000000000.0,))

        # Test raising an exception
        value.shouldRaise = True
        try:
            with self.assertRaisesRegex(RuntimeError, "failure"):
                OC_VectorCallInvoke.simdquatfdOn_(value)
        finally:
            del value.shouldRaise

        value.returnInvalid = True
        try:
            with self.assertRaises((ValueError, TypeError)):
                OC_VectorCallInvoke.simdquatfdOn_(value)
        finally:
            del value.returnInvalid
