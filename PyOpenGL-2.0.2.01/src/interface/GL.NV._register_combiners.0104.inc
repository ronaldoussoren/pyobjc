/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.23
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON

#ifndef SWIG_TEMPLATE_DISAMBIGUATOR
#  if defined(__SUNPRO_CC) 
#    define SWIG_TEMPLATE_DISAMBIGUATOR template
#  else
#    define SWIG_TEMPLATE_DISAMBIGUATOR 
#  endif
#endif


#include <Python.h>

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  if !defined(STATIC_LINKED)
#    define SWIGEXPORT(a) __declspec(dllexport) a
#  else
#    define SWIGEXPORT(a) a
#  endif
#else
#  define SWIGEXPORT(a) a
#endif

#define SWIGRUNTIME(x) static x

#ifndef SWIGINLINE
#if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#  define SWIGINLINE inline
#else
#  define SWIGINLINE
#endif
#endif


/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "1"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
#define SWIG_QUOTE_STRING(x) #x
#define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
#define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
#define SWIG_TYPE_TABLE_NAME
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

static swig_type_info *swig_type_list = 0;
static swig_type_info **swig_type_list_handle = &swig_type_list;

/* 
   Compare two type names skipping the space characters, therefore
   "char*" == "char *" and "Class<int>" == "Class<int >", etc.

   Return 0 when the two name types are equivalent, as in
   strncmp, but skipping ' '.
*/
static int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return *f1 - *f2;
  }
  return (l1 - f1) - (l2 - f2);
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
*/
static int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te) == 0;
    if (*ne) ++ne;
  }
  return equiv;
}
  

/* Register a type mapping with the type-checking */
static swig_type_info *
SWIG_TypeRegister(swig_type_info *ti) {
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = *swig_type_list_handle;
  while (tc) {
    /* check simple type equivalence */
    int typeequiv = (strcmp(tc->name, ti->name) == 0);   
    /* check full type equivalence, resolving typedefs */
    if (!typeequiv) {
      /* only if tc is not a typedef (no '|' on it) */
      if (tc->str && ti->str && !strstr(tc->str,"|")) {
	typeequiv = SWIG_TypeEquiv(ti->str,tc->str);
      }
    }
    if (typeequiv) {
      /* Already exists in the table.  Just add additional types to the list */
      if (ti->clientdata) tc->clientdata = ti->clientdata;
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = *swig_type_list_handle;
  *swig_type_list_handle = ti;

  /* Build linked lists */
  l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;
  head->next = next;

  return ret;
}

/* Check the typename */
static swig_type_info *
SWIG_TypeCheck(char *c, swig_type_info *ty) {
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
        s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
static SWIGINLINE void *
SWIG_TypeCast(swig_type_info *ty, void *ptr) {
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
static swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/* Return the name associated with this type */
static SWIGINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/* Return the pretty name associated with this type,
   that is an unmangled type name in a form presentable to the user.
*/
static const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* Search for a swig_type_info structure */
static swig_type_info *
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = *swig_type_list_handle;
  while (ty) {
    if (ty->str && (SWIG_TypeEquiv(ty->str,name))) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
static void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata) return;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = *swig_type_list_handle;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0))
          SWIG_TypeClientData(tc,clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* Pack binary data into a string */
static char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static char hex[17] = "0123456789abcdef";
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  register unsigned char uu;
  for (; u != eu; ++u) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
static char *
SWIG_UnpackData(char *c, void *ptr, size_t sz) {
  register unsigned char uu = 0;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
static void
SWIG_PropagateClientData(swig_type_info *type) {
  swig_type_info *equiv = type->next;
  swig_type_info *tc;
  if (!type->clientdata) return;
  while (equiv) {
    if (!equiv->converter) {
      tc = *swig_type_list_handle;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0) && !tc->clientdata)
          SWIG_TypeClientData(tc, type->clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * SWIG API. Portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * for internal method declarations
 * ----------------------------------------------------------------------------- */

#ifndef SWIGINTERN
#define SWIGINTERN static 
#endif

#ifndef SWIGINTERNSHORT
#ifdef __cplusplus
#define SWIGINTERNSHORT static inline 
#else /* C case */
#define SWIGINTERNSHORT static 
#endif /* __cplusplus */
#endif

    
/* Common SWIG API */
#define SWIG_ConvertPtr(obj, pp, type, flags)    SWIG_Python_ConvertPtr(obj, pp, type, flags)
#define SWIG_NewPointerObj(p, type, flags)       SWIG_Python_NewPointerObj(p, type, flags)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)
 
/* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags)   SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type)              SWIG_Python_NewPackedObj(ptr, sz, type)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)

/*
  Exception handling in wrappers
*/
#define SWIG_fail                goto fail
#define SWIG_arg_fail(arg)       SWIG_Python_ArgFail(arg)
#define SWIG_append_errmsg(msg)   SWIG_Python_AddErrMesg(msg,0)
#define SWIG_preppend_errmsg(msg) SWIG_Python_AddErrMesg(msg,1)
#define SWIG_type_error(type,obj) SWIG_Python_TypeError(type,obj)
#define SWIG_null_ref(type)       SWIG_Python_NullRef(type)

/*
  Contract support
*/
#define SWIG_contract_assert(expr, msg) \
 if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */
/*
  Use SWIG_NO_COBJECT_TYPES to force the use of strings to represent
  C/C++ pointers in the python side. Very useful for debugging, but
  not always safe.
*/
#if !defined(SWIG_NO_COBJECT_TYPES) && !defined(SWIG_COBJECT_TYPES)
#  define SWIG_COBJECT_TYPES
#endif

/* Flags for pointer conversion */
#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

/* -----------------------------------------------------------------------------
 * Alloc. memory flags
 * ----------------------------------------------------------------------------- */
#define SWIG_OLDOBJ  1
#define SWIG_NEWOBJ  SWIG_OLDOBJ + 1
#define SWIG_PYSTR   SWIG_NEWOBJ + 1

#ifdef __cplusplus
}
#endif


/***********************************************************************
 * pyrun.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)();           /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

static PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,                                  /* Number of items in variable part (ob_size) */
  (char *)"swigvarlink",              /* Type name (tp_name) */
  sizeof(swig_varlinkobject),         /* Basic size (tp_basicsize) */
  0,                                  /* Itemsize (tp_itemsize) */
  0,                                  /* Deallocator (tp_dealloc) */ 
  (printfunc) swig_varlink_print,     /* Print (tp_print) */
  (getattrfunc) swig_varlink_getattr, /* get attr (tp_getattr) */
  (setattrfunc) swig_varlink_setattr, /* Set attr (tp_setattr) */
  0,                                  /* tp_compare */
  (reprfunc) swig_varlink_repr,       /* tp_repr */
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_sequence */
  0,                                  /* tp_as_mapping */
  0,                                  /* tp_hash */
  0,                                  /* tp_call */
  0,                                  /* tp_str */
  0,                                  /* tp_getattro */
  0,                                  /* tp_setattro */
  0,                                  /* tp_as_buffer */
  0,                                  /* tp_flags */
  0,                                  /* tp_doc */
  0,                                  /* tp_traverse */
  0,                                  /* tp_clear */
  0,                                  /* tp_richcompare */
  0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
  0,                                  /* tp_iter */
  0,                                  /* tp_iternext */
  0,                                  /* tp_methods */
  0,                                  /* tp_members */
  0,                                  /* tp_getset */
  0,                                  /* tp_base */
  0,                                  /* tp_dict */
  0,                                  /* tp_descr_get */
  0,                                  /* tp_descr_set */
  0,                                  /* tp_dictoffset */
  0,                                  /* tp_init */
  0,                                  /* tp_alloc */
  0,                                  /* tp_new */
  0,                                  /* tp_free */
  0,                                  /* tp_is_gc */
  0,                                  /* tp_bases */
  0,                                  /* tp_mro */
  0,                                  /* tp_cache */
  0,                                  /* tp_subclasses */
  0,                                  /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
  0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
  /* these must be last */
  0,                                  /* tp_alloc */
  0,                                  /* tp_free */
  0,                                  /* tp_maxalloc */
  0,                                  /*  tp_next */
#endif
};

/* Create a variable linking object for use later */
static PyObject *
SWIG_Python_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

static void
SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}

/* -----------------------------------------------------------------------------
 * errors manipulation
 * ----------------------------------------------------------------------------- */

static void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
    if (!PyCObject_Check(obj)) {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? PyString_AsString(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_DECREF(str);
	return;
      }
    } else {
      const char *otype = (char *) PyCObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'PyCObject(%s)' is received",
		     type, otype);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);

  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}

static SWIGINLINE void
SWIG_Python_NullRef(const char *type)
{
  if (type) {
    PyErr_Format(PyExc_TypeError, "null reference of type '%s' was received",type);
  } else {
    PyErr_Format(PyExc_TypeError, "null reference was received");
  }
}

static int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      PyObject *old_str = PyObject_Str(value);
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, PyString_AsString(old_str));
      } else {
	PyErr_Format(type, "%s %s", PyString_AsString(old_str), mesg);
      }
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}

static int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    sprintf(mesg, "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}


/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

/* Convert a pointer value */
static int
SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c = 0;
  static PyObject *SWIG_this = 0;
  int    newref = 0;
  PyObject  *pyobj = 0;
  void *vptr;
  
  if (!obj) return 0;
  if (obj == Py_None) {
    *ptr = 0;
    return 0;
  }

#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  }  
  vptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto type_check;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AS_STRING(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      if (newref) { Py_DECREF(obj); }
      *ptr = (void *) 0;
      return 0;
    } else {
      if (newref) { Py_DECREF(obj); }
      goto type_error;
    }
  }
  c++;
  c = SWIG_UnpackData(c,&vptr,sizeof(void *));
  if (newref) { Py_DECREF(obj); }
#endif

type_check:

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,vptr);
  }

  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {
    PyObject_SetAttrString(pyobj,(char*)"thisown",Py_False);
  }
  return 0;

type_error:
  PyErr_Clear();
  if (pyobj && !obj) {    
    obj = pyobj;
    if (PyCFunction_Check(obj)) {
      /* here we get the method pointer for callbacks */
      char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
      c = doc ? strstr(doc, "swig_ptr: ") : 0;
      if (c) {
	c += 10;
	if (*c == '_') {
	  c++;
	  c = SWIG_UnpackData(c,&vptr,sizeof(void *));
	  goto type_check;
	}
      }
    }
  }
  if (flags & SWIG_POINTER_EXCEPTION) {
    if (ty) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
    } else {
      SWIG_Python_TypeError("C/C++ pointer", obj);
    }
  }
  return -1;
}

/* Convert a pointer value, signal an exception on a type mismatch */
static void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
    if (flags & SWIG_POINTER_EXCEPTION) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
  }
  return result;
}

/* Convert a packed value value */
static int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c = 0;

  if ((!obj) || (!PyString_Check(obj))) goto type_error;
  c = PyString_AS_STRING(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return 0;

type_error:
  PyErr_Clear();
  if (flags & SWIG_POINTER_EXCEPTION) {
    if (ty) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
    } else {
      SWIG_Python_TypeError("C/C++ packed data", obj);
    }
  }
  return -1;
}

/* Create a new pointer string */
static char *
SWIG_Python_PointerStr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}
  

/* Create a new pointer object */
static PyObject *
SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);
#else
  {
    char result[1024];
    SWIG_Python_PointerStr(result, ptr, type->name, 1024);
    robj = PyString_FromString(result);
  }
#endif
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyObject *inst;
    PyObject *args = Py_BuildValue((char*)"(O)", robj);
    Py_DECREF(robj);
    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
    Py_DECREF(args);
    if (inst) {
      if (own) {
        PyObject_SetAttrString(inst,(char*)"thisown",Py_True);
      }
      robj = inst;
    }
  }
  return robj;
}

static PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 2 + strlen(type->name)) > 1024) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return PyString_FromString(result);
}


/* -----------------------------------------------------------------------------
 * constants/methods manipulation
 * ----------------------------------------------------------------------------- */

/* Install Constants */
static void
SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      if (constants[i].pvalue) {
	obj = PyString_FromString((char *) constants[i].pvalue);
      } else {
	Py_INCREF(Py_None);
	obj = Py_None;
      }
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

/* Fix SwigMethods to carry the callback ptrs when needed */
static void
SWIG_Python_FixMethods(PyMethodDef *methods,
		       swig_const_info *const_table,
		       swig_type_info **types,
		       swig_type_info **types_initial) {
  int i;
  for (i = 0; methods[i].ml_name; ++i) {
    char *c = methods[i].ml_doc;
    if (c && (c = strstr(c, "swig_ptr: "))) {
      int j;
      swig_const_info *ci = 0;
      char *name = c + 10;
      for (j = 0; const_table[j].type; j++) {
	if (strncmp(const_table[j].name, name, 
		    strlen(const_table[j].name)) == 0) {
	  ci = &(const_table[j]);
	  break;
	}
      }
      if (ci) {
	size_t shift = (ci->ptype) - types;
	swig_type_info *ty = types_initial[shift];
	size_t ldoc = (c - methods[i].ml_doc);
	size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
	char *ndoc = (char*)malloc(ldoc + lptr + 10);
	char *buff = ndoc;
	void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue: (void *)(ci->lvalue);
	strncpy(buff, methods[i].ml_doc, ldoc);
	buff += ldoc;
	strncpy(buff, "swig_ptr: ", 10);
	buff += 10;
	SWIG_Python_PointerStr(buff, ptr, ty->name, lptr);
	methods[i].ml_doc = ndoc;
      }
    }
  }
}


/* -----------------------------------------------------------------------------
 * Lookup type pointer 
 * ----------------------------------------------------------------------------- */
#if PY_MAJOR_VERSION < 2
/* PyModule_AddObject function was introduced in Python 2.0.  The following function
is copied out of Python/modsupport.c in python version 2.3.4 */
static int
PyModule_AddObject(PyObject *m, char *name, PyObject *o)
{
	PyObject *dict;
	if (!PyModule_Check(m)) {
		PyErr_SetString(PyExc_TypeError,
			    "PyModule_AddObject() needs module as first arg");
		return -1;
	}
	if (!o) {
		PyErr_SetString(PyExc_TypeError,
				"PyModule_AddObject() needs non-NULL value");
		return -1;
	}

	dict = PyModule_GetDict(m);
	if (dict == NULL) {
		/* Internal error -- modules must have a dict! */
		PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
			     PyModule_GetName(m));
		return -1;
	}
	if (PyDict_SetItemString(dict, name, o))
		return -1;
	Py_DECREF(o);
	return 0;
}
#endif
static PyMethodDef swig_empty_runtime_method_table[] = {
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

static void
SWIG_Python_LookupTypePointer(swig_type_info ***type_list_handle) {
  PyObject *module, *pointer;
  void *type_pointer;

  /* first check if module already created */
  type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
  if (type_pointer) {
    *type_list_handle = (swig_type_info **) type_pointer;
  } else {
    PyErr_Clear();
    /* create a new module and variable */
    module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
    pointer = PyCObject_FromVoidPtr((void *) (*type_list_handle), NULL);
    if (pointer && module) {
      PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
    }
  }
}

#ifdef __cplusplus
}
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_GLsizei swig_types[0] 
#define  SWIGTYPE_p_GLshort swig_types[1] 
#define  SWIGTYPE_p_GLboolean swig_types[2] 
#define  SWIGTYPE_size_t swig_types[3] 
#define  SWIGTYPE_p_GLushort swig_types[4] 
#define  SWIGTYPE_p_GLenum swig_types[5] 
#define  SWIGTYPE_p_GLvoid swig_types[6] 
#define  SWIGTYPE_p_GLint swig_types[7] 
#define  SWIGTYPE_p_char swig_types[8] 
#define  SWIGTYPE_p_GLclampd swig_types[9] 
#define  SWIGTYPE_p_GLclampf swig_types[10] 
#define  SWIGTYPE_p_GLuint swig_types[11] 
#define  SWIGTYPE_ptrdiff_t swig_types[12] 
#define  SWIGTYPE_p_GLbyte swig_types[13] 
#define  SWIGTYPE_p_GLbitfield swig_types[14] 
#define  SWIGTYPE_p_GLfloat swig_types[15] 
#define  SWIGTYPE_p_GLubyte swig_types[16] 
#define  SWIGTYPE_p_GLdouble swig_types[17] 
static swig_type_info *swig_types[19];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= _register_combiners.so
  ------------------------------------------------*/
#define SWIG_init    init_register_combiners

#define SWIG_name    "_register_combiners"

SWIGINTERN PyObject *
SWIG_FromCharPtr(const char* cptr)
{ 
  if (cptr) {
    size_t size = strlen(cptr);
    if (size > INT_MAX) {
      return SWIG_NewPointerObj((char*)(cptr), 
				SWIG_TypeQuery("char *"), 0);
    } else {
      if (size != 0) {
	return PyString_FromStringAndSize(cptr, size);
      } else {
	return PyString_FromString(cptr);
      }
    }
  }
  Py_INCREF(Py_None);
  return Py_None;
}


  /*@C:\\bin\\SWIG-1.3.23\\Lib\\python\\pymacros.swg,66,SWIG_define@*/
#define SWIG_From_int PyInt_FromLong
/*@@*/


/**
 *
 * GL.NV.register_combiners Module for PyOpenGL
 * 
 * Date: May 2001
 *
 * Authors: Tarn Weisner Burton <twburton@users.sourceforge.net>
 * 
***/


GLint PyOpenGL_round(double x) {
  if (x >= 0) {
    return (GLint) (x+0.5);
	} else {
    return (GLint) (x-0.5);
	}
}




int __PyObject_AsArray_Size(PyObject* x);

#ifdef NUMERIC

#define _PyObject_AsArray_Size(x) ((x == Py_None) ? 0 : ((PyArray_Check(x)) ? PyArray_Size(x) : __PyObject_AsArray_Size(x)))

#else /* NUMERIC */

#define _PyObject_AsArray_Size(x) ((x == Py_None) ? 0 : __PyObject_AsArray_Size(x))

#endif /* NUMERIC */


#define _PyObject_As(NAME, BASE) BASE* _PyObject_As##NAME(PyObject* source, PyObject** temp, int* len);

#define _PyObject_AsArray_Cleanup(target, temp) if (temp) Py_XDECREF(temp); else PyMem_Del(target)

_PyObject_As(FloatArray, float)

_PyObject_As(DoubleArray, double)

_PyObject_As(CharArray, signed char)

_PyObject_As(UnsignedCharArray, unsigned char)

_PyObject_As(ShortArray, short)

_PyObject_As(UnsignedShortArray, unsigned short)

_PyObject_As(IntArray, int)

_PyObject_As(UnsignedIntArray, unsigned int)

void* _PyObject_AsArray(GLenum type, PyObject* source, PyObject** temp, int* len);




#define PyErr_XPrint() if (PyErr_Occurred()) PyErr_Print()


#if HAS_DYNAMIC_EXT

#define DECLARE_EXT(PROC_NAME, RET, ERROR_RET, PROTO, CALL)\
RET PROC_NAME PROTO\
{\
	typedef RET (APIENTRY *proc_##PROC_NAME) PROTO;\
	proc_##PROC_NAME proc = (proc_##PROC_NAME)GL_GetProcAddress(#PROC_NAME);\
	if (proc) return proc CALL;\
	PyErr_SetGLErrorMessage( GL_INVALID_OPERATION, "Dynamic function loading not implemented/supported on this platform" );\
	return ERROR_RET;\
}

#define DECLARE_VOID_EXT(PROC_NAME, PROTO, CALL)\
void PROC_NAME PROTO\
{\
	typedef void (APIENTRY *proc_##PROC_NAME) PROTO;\
	proc_##PROC_NAME proc = (proc_##PROC_NAME)GL_GetProcAddress(#PROC_NAME);\
	if (proc) proc CALL;\
	else {\
		PyErr_SetGLErrorMessage( GL_INVALID_OPERATION, "Dynamic function loading not implemented/supported on this platform" );\
	}\
}

#else

#define DECLARE_EXT(PROC_NAME, RET, ERROR_RET, PROTO, CALL)\
RET PROC_NAME PROTO\
{\
	PyErr_SetGLErrorMessage( GL_INVALID_OPERATION, "Dynamic function loading not implemented/supported on this platform" );\
	return ERROR_RET;\
}


#define DECLARE_VOID_EXT(PROC_NAME, PROTO, CALL)\
void PROC_NAME PROTO\
{\
	PyErr_SetGLErrorMessage( GL_INVALID_OPERATION, "Dynamic function loading not implemented/supported on this platform" );\
}

#endif


#define _PyTuple_From(NAME, BASE) PyObject* _PyTuple_From##NAME(int len, BASE* data);

_PyTuple_From(UnsignedCharArray, unsigned char)

_PyTuple_From(CharArray, signed char)

_PyTuple_From(UnsignedShortArray, unsigned short)

_PyTuple_From(ShortArray, short)

_PyTuple_From(UnsignedIntArray, unsigned int)

_PyTuple_From(IntArray, int)

_PyTuple_From(FloatArray, float)

_PyTuple_From(DoubleArray, double)


#define _PyObject_From(NAME, BASE) PyObject* _PyObject_From##NAME(int nd, int* dims, BASE* data, int own);

_PyObject_From(UnsignedCharArray, unsigned char)

_PyObject_From(CharArray, signed char)

_PyObject_From(UnsignedShortArray, unsigned short)

_PyObject_From(ShortArray, short)

_PyObject_From(UnsignedIntArray, unsigned int)

_PyObject_From(IntArray, int)

_PyObject_From(FloatArray, float)

_PyObject_From(DoubleArray, double)


PyObject* _PyObject_FromArray(GLenum type, int nd, int *dims, void* data, int own);

void* SetupPixelRead(int rank, GLenum format, GLenum type, int *dims);

void SetupPixelWrite(int rank);

void* SetupRawPixelRead(GLenum format, GLenum type, int n, const int *dims, int* size);

void* _PyObject_AsPointer(PyObject* x);

/* The following line causes a warning on linux and cygwin

	The function is defined in interface_utils.c, which is
	linked to each extension module.  For some reason, though,
	this declaration doesn't get recognised as a declaration
	prototype for that function.
*/
void init_util();

typedef void *PTR;

typedef struct
{
	void (*_decrement)(void* pointer);
	void (*_decrementPointer)(GLenum pname);
	int (*_incrementLock)(void *pointer);
	int (*_incrementPointerLock)(GLenum pname);
	void (*_acquire)(void* pointer);
	void (*_acquirePointer)(GLenum pname);
#if HAS_DYNAMIC_EXT
	PTR (*GL_GetProcAddress)(const char* name);
#endif
	int (*InitExtension)(const char *name, const char** procs);
	PyObject *_GLerror;
	PyObject *_GLUerror;
}  util_API;



static util_API *_util_API = NULL;

#define decrementLock(x) (*_util_API)._decrement(x)
#define decrementPointerLock(x) (*_util_API)._decrementPointer(x)
#define incrementLock(x) (*_util_API)._incrementLock(x)
#define incrementPointerLock(x) (*_util_API)._incrementPointerLock(x)
#define acquire(x) (*_util_API)._acquire(x)
#define acquirePointer(x) (*_util_API)._acquirePointer(x)
#define GLerror (*_util_API)._GLerror
#define GLUerror (*_util_API)._GLUerror
#if HAS_DYNAMIC_EXT
#define GL_GetProcAddress(x) (*_util_API).GL_GetProcAddress(x)
#endif
#define InitExtension(x, y) (*_util_API).InitExtension(x, (const char**)y)



#define PyErr_SetGLerror(code) PyErr_SetObject(GLerror, Py_BuildValue("is", code, gluErrorString(code)));
#define PyErr_SetGLUerror(code) PyErr_SetObject(GLUerror, Py_BuildValue("is", code, gluErrorString(code)));

int _PyObject_Dimension(PyObject* x, int rank);

#define ERROR_MSG_SEP ", "
#define ERROR_MSG_SEP_LEN 2

int GLErrOccurred()
{
	if (PyErr_Occurred()) return 1;

	if (CurrentContextIsValid())
	{
		GLenum error, *errors = NULL;
		char *msg = NULL;
		const char *this_msg;
		int count = 0;
	
		error = glGetError();

		while (error != GL_NO_ERROR)
		{
			this_msg = gluErrorString(error);
			if (count)
			{
				msg = realloc(msg, (strlen(msg) + strlen(this_msg) + ERROR_MSG_SEP_LEN + 1)*sizeof(char));
				strcat(msg, ERROR_MSG_SEP);
				strcat(msg, this_msg);
				
				errors = realloc(errors, (count + 1)*sizeof(GLenum));
			}
			else
			{
				msg = malloc((strlen(this_msg) + 1)*sizeof(char));
				strcpy(msg, this_msg);
				
				errors = malloc(sizeof(GLenum));
			}
			
			errors[count++] = error;
			error = glGetError();
		}
		
		if (count)
		{
			PyErr_SetObject(GLerror, Py_BuildValue("Os", _PyTuple_FromIntArray(count, (int*)errors), msg));
			free(errors);
			free(msg);
			return 1;
		}
	}

	return 0;
}

void PyErr_SetGLErrorMessage( int id, char * message ) {
	/* set a GLerror with an ID and string message
	
	This tries pretty hard to look just like a regular
	error as produced by GLErrOccurred()'s formatter,
	save that there's only the single error being reported.

	Using id 0 is probably best for any future use where 
	there isn't a good match for the exception description
	in the error-enumeration set.
	 */
	PyObject * args = NULL;
	args = Py_BuildValue( "(i)s", id, message );
	if (args) {
		PyErr_SetObject( GLerror, args );
		Py_XDECREF( args );
	} else {
		PyErr_SetGLerror(id);
	}
}




#if !EXT_DEFINES_PROTO || !defined(GL_NV_register_combiners)
DECLARE_VOID_EXT(glCombinerParameterfvNV, (GLenum pname, const GLfloat *params), (pname, params))
DECLARE_VOID_EXT(glCombinerParameterivNV, (GLenum pname, const GLint *params), (pname, params))
DECLARE_VOID_EXT(glCombinerParameterfNV, (GLenum pname, GLfloat param), (pname, param))
DECLARE_VOID_EXT(glCombinerParameteriNV, (GLenum pname, GLint param), (pname, param))
DECLARE_VOID_EXT(glCombinerInputNV,\
	(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage),\
	(stage, portion, variable, input, mapping, componentUsage))
DECLARE_VOID_EXT(glCombinerOutputNV,\
	(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum),\
	(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum))
DECLARE_VOID_EXT(glFinalCombinerInputNV,\
	(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage),\
	(variable, input, mapping, componentUsage))
DECLARE_VOID_EXT(glGetCombinerInputParameterfvNV,\
	(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params),\
	(stage, portion, variable, pname, params))
DECLARE_VOID_EXT(glGetCombinerInputParameterivNV,\
	(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params),\
	(stage, portion, variable, pname, params))
DECLARE_VOID_EXT(glGetCombinerOutputParameterfvNV,\
	(GLenum stage, GLenum portion, GLenum pname, GLfloat *params),\
	(stage, portion, pname, params))
DECLARE_VOID_EXT(glGetCombinerOutputParameterivNV,\
	(GLenum stage, GLenum portion, GLenum pname, GLint *params),\
	(stage, portion, pname, params))
DECLARE_VOID_EXT(glGetFinalCombinerInputParameterfvNV,\
	(GLenum variable, GLenum pname, GLfloat *params),\
	(variable, pname, params))
DECLARE_VOID_EXT(glGetFinalCombinerInputParameterivNV,\
	(GLenum variable, GLenum pname, GLint *params),\
	(variable, pname, params))
#endif


#include <limits.h>


SWIGINTERNSHORT int
  SWIG_CheckUnsignedLongInRange(unsigned long value,
				unsigned long max_value,
				const char *errmsg) 
{
  if (value > max_value) {
    if (errmsg) {
      PyErr_Format(PyExc_OverflowError,
		   "value %lu is greater than '%s' minimum %lu",
		   value, errmsg, max_value);
    }
    return 0;
  }
  return 1;
 }


SWIGINTERN int
  SWIG_AsVal_unsigned_SS_long(PyObject *obj, unsigned long *val) 
{
  if (PyInt_Check(obj)) {
    long v = PyInt_AS_LONG(obj);
    if (v >= 0) {
      if (val) *val = v;
      return 1;
    }   
  }
  if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return 1;
    } else {
      if (!val) PyErr_Clear();
      return 0;
    }
  } 
  if (val) {
    SWIG_type_error("unsigned long", obj);
  }
  return 0;
}


#if UINT_MAX != ULONG_MAX
SWIGINTERN int
  SWIG_AsVal_unsigned_SS_int(PyObject *obj, unsigned int *val)
{ 
  const char* errmsg = val ? "unsigned int" : (char*)0;
  unsigned long v;
  if (SWIG_AsVal_unsigned_SS_long(obj, &v)) {
    if (SWIG_CheckUnsignedLongInRange(v, INT_MAX, errmsg)) {
      if (val) *val = (unsigned int)(v);
      return 1;
    }
  } else {
    PyErr_Clear();
  }
  if (val) {
    SWIG_type_error(errmsg, obj);
  }
  return 0;    
}
#else
SWIGINTERNSHORT unsigned int
  SWIG_AsVal_unsigned_SS_int(PyObject *obj, unsigned int *val)
{
  return SWIG_AsVal_unsigned_SS_long(obj,(unsigned long *)val);
}
#endif


SWIGINTERNSHORT unsigned int
SWIG_As_unsigned_SS_int(PyObject* obj)
{
  unsigned int v;
  if (!SWIG_AsVal_unsigned_SS_int(obj, &v)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(unsigned int));
  }
  return v;
}

  
SWIGINTERNSHORT int
SWIG_Check_unsigned_SS_int(PyObject* obj)
{
  return SWIG_AsVal_unsigned_SS_int(obj, (unsigned int*)0);
}

 static char _doc_glCombinerParameterfvNV[] = "glCombinerParameterfvNV(pname, params) -> None"; 
 static char _doc_glCombinerParameterivNV[] = "glCombinerParameterivNV(pname, params) -> None"; 

#include <float.h>
SWIGINTERN int
  SWIG_CheckDoubleInRange(double value, double min_value, 
			  double max_value, const char* errmsg)
{
  if (value < min_value) {
    if (errmsg) {
      PyErr_Format(PyExc_OverflowError, 
		   "value %g is less than %s minimum %g", 
		   value, errmsg, min_value);
    }
    return 0;
  } else if (value > max_value) {
    if (errmsg) {
      PyErr_Format(PyExc_OverflowError, 
		   "value %g is greater than %s maximum %g", 
		   value, errmsg, max_value);
    }
    return 0;
  }
  return 1;
}


SWIGINTERN int
  SWIG_AsVal_double(PyObject *obj, double *val)
{
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AS_DOUBLE(obj);
    return 1;
  }  
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AS_LONG(obj);
    return 1;
  }
  if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return 1;
    } else {
      if (!val) PyErr_Clear();
      return 0;
    }
  }
  if (val) {
    SWIG_type_error("double", obj);
  }
  return 0;
}


SWIGINTERN int
  SWIG_AsVal_float(PyObject *obj, float *val)
{
  const char* errmsg = val ? "float" : (char*)0;
  double v;
  if (SWIG_AsVal_double(obj, &v)) {
    if (SWIG_CheckDoubleInRange(v, -FLT_MAX, FLT_MAX, errmsg)) {
      if (val) *val = (float)(v);
      return 1;
    } else {
      return 0;
    }
  } else {
    PyErr_Clear();
  }
  if (val) {
    SWIG_type_error(errmsg, obj);
  }
  return 0;
}


SWIGINTERNSHORT float
SWIG_As_float(PyObject* obj)
{
  float v;
  if (!SWIG_AsVal_float(obj, &v)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(float));
  }
  return v;
}

  
SWIGINTERNSHORT int
SWIG_Check_float(PyObject* obj)
{
  return SWIG_AsVal_float(obj, (float*)0);
}

 static char _doc_glCombinerParameterfNV[] = "glCombinerParameterfNV(pname, param) -> None"; 

SWIGINTERN int
  SWIG_CheckLongInRange(long value, long min_value, long max_value,
			const char *errmsg)
{
  if (value < min_value) {
    if (errmsg) {
      PyErr_Format(PyExc_OverflowError, 
		   "value %ld is less than '%s' minimum %ld", 
		   value, errmsg, min_value);
    }
    return 0;    
  } else if (value > max_value) {
    if (errmsg) {
      PyErr_Format(PyExc_OverflowError,
		   "value %ld is greater than '%s' maximum %ld", 
		   value, errmsg, max_value);
    }
    return 0;
  }
  return 1;
}


SWIGINTERN int
  SWIG_AsVal_long(PyObject * obj, long* val)
{
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AS_LONG(obj);
    return 1;
  }
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return 1;
    } else {
      if (!val) PyErr_Clear();
      return 0;
    }
  }
  if (val) {
    SWIG_type_error("long", obj);
  }
  return 0;
 }


#if INT_MAX != LONG_MAX
SWIGINTERN int
  SWIG_AsVal_int(PyObject *obj, int *val)
{ 
  const char* errmsg = val ? "int" : (char*)0;
  long v;
  if (SWIG_AsVal_long(obj, &v)) {
    if (SWIG_CheckLongInRange(v, INT_MIN,INT_MAX, errmsg)) {
      if (val) *val = (int)(v);
      return 1;
    } else {
      return 0;
    }
  } else {
    PyErr_Clear();
  }
  if (val) {
    SWIG_type_error(errmsg, obj);
  }
  return 0;    
}
#else
SWIGINTERNSHORT int
  SWIG_AsVal_int(PyObject *obj, int *val)
{
  return SWIG_AsVal_long(obj,(long*)val);
}
#endif


SWIGINTERNSHORT int
SWIG_As_int(PyObject* obj)
{
  int v;
  if (!SWIG_AsVal_int(obj, &v)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(int));
  }
  return v;
}

  
SWIGINTERNSHORT int
SWIG_Check_int(PyObject* obj)
{
  return SWIG_AsVal_int(obj, (int*)0);
}

 static char _doc_glCombinerParameteriNV[] = "glCombinerParameteriNV(pname, param) -> None"; 
 static char _doc_glCombinerInputNV[] = "glCombinerInputNV(stage, portion, variable, input, mapping, componentUsage) -> None"; 

SWIGINTERN int
  SWIG_AsVal_unsigned_SS_char(PyObject *obj, unsigned char *val)
{ 
  const char* errmsg = val ? "unsigned char" : (char*)0;
  unsigned long v;
  if (SWIG_AsVal_unsigned_SS_long(obj, &v)) {
    if (SWIG_CheckUnsignedLongInRange(v, UCHAR_MAX,errmsg)) {
      if (val) *val = (unsigned char)(v);
      return 1;
    } else {
      return 0;
    }
  } else {
    PyErr_Clear();
  }
  if (val) {
    SWIG_type_error(errmsg, obj);
  }
  return 0;
}

  
SWIGINTERNSHORT int
SWIG_Check_unsigned_SS_char(PyObject* obj)
{
  return SWIG_AsVal_unsigned_SS_char(obj, (unsigned char*)0);
}

 static char _doc_glCombinerOutputNV[] = "glCombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum) -> None"; 
 static char _doc_glFinalCombinerInputNV[] = "glFinalCombinerInputNV(variable, input, mapping, componentUsage) -> None"; 
 static char _doc_glGetCombinerInputParameterfvNV[] = "glGetCombinerInputParameterfvNV(stage, portion, variable, pname) -> params"; 
 static char _doc_glGetCombinerInputParameterivNV[] = "glGetCombinerInputParameterivNV(stage, portion, variable, pname) -> params"; 
 static char _doc_glGetCombinerOutputParameterfvNV[] = "glGetCombinerOutputParameterfvNV(stage, portion, pname) -> params"; 
 static char _doc_glGetCombinerOutputParameterivNV[] = "glGetCombinerOutputParameterivNV(stage, portion, pname) -> params"; 
 static char _doc_glGetFinalCombinerInputParameterfvNV[] = "glGetFinalCombinerInputParameterfvNV(variable, pname) -> params"; 
 static char _doc_glGetFinalCombinerInputParameterivNV[] = "glGetFinalCombinerInputParameterivNV(variable, pname) -> params"; 

static char *proc_names[] =
{
#if !EXT_DEFINES_PROTO || !defined(GL_NV_register_combiners)
	"glCombinerParameterfvNV",
	"glCombinerParameterivNV",
	"glCombinerParameterfNV",
	"glCombinerParameteriNV",
	"glCombinerInputNV",
	"glCombinerOutputNV",
	"glFinalCombinerInputNV",
	"glGetCombinerInputParameterfvNV",
	"glGetCombinerInputParameterivNV",
	"glGetCombinerOutputParameterfvNV",
	"glGetCombinerOutputParameterivNV",
	"glGetFinalCombinerInputParameterfvNV",
	"glGetFinalCombinerInputParameterivNV",
#endif
	NULL
};

#define glInitRegisterCombinersNV() InitExtension("GL_NV_register_combiners", proc_names)

 static char _doc_glInitRegisterCombinersNV[] = "glInitRegisterCombinersNV() -> bool"; 

#ifndef GL_NV_register_combiners
#define GL_MAX_GENERAL_COMBINERS_NV           0x854D
#endif

PyObject *__info()
{
	if (glInitRegisterCombinersNV())
	{
		PyObject *info = PyList_New(0);
		PyList_Append(info, Py_BuildValue("sis", "GL_MAX_GENERAL_COMBINERS_NV", GL_MAX_GENERAL_COMBINERS_NV, "i"));
		return info;
	}
	
	Py_INCREF(Py_None);
	return Py_None;
}

#ifdef __cplusplus
extern "C" {
#endif
static PyObject *_wrap_glCombinerParameterfvNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    GLenum arg1 ;
    GLfloat *arg2 = (GLfloat *) 0 ;
    PyObject *temp_2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:glCombinerParameterfvNV",&obj0,&obj1)) goto fail;
    {
        arg1 = (GLenum)(SWIG_As_unsigned_SS_int(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = _PyObject_AsFloatArray(obj1, &temp_2, NULL); 
    }
    {
        glCombinerParameterfvNV(arg1,(GLfloat const *)arg2);
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        _PyObject_AsArray_Cleanup(arg2, temp_2); 
    }
    return resultobj;
    fail:
    {
        _PyObject_AsArray_Cleanup(arg2, temp_2); 
    }
    return NULL;
}


static PyObject *_wrap_glCombinerParameterivNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    GLenum arg1 ;
    GLint *arg2 = (GLint *) 0 ;
    PyObject *temp_2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:glCombinerParameterivNV",&obj0,&obj1)) goto fail;
    {
        arg1 = (GLenum)(SWIG_As_unsigned_SS_int(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = _PyObject_AsIntArray(obj1, &temp_2, NULL); 
    }
    {
        glCombinerParameterivNV(arg1,(GLint const *)arg2);
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        _PyObject_AsArray_Cleanup(arg2, temp_2); 
    }
    return resultobj;
    fail:
    {
        _PyObject_AsArray_Cleanup(arg2, temp_2); 
    }
    return NULL;
}


static PyObject *_wrap_glCombinerParameterfNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    GLenum arg1 ;
    GLfloat arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:glCombinerParameterfNV",&obj0,&obj1)) goto fail;
    {
        arg1 = (GLenum)(SWIG_As_unsigned_SS_int(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (GLfloat)(SWIG_As_float(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        glCombinerParameterfNV(arg1,arg2);
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_glCombinerParameteriNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    GLenum arg1 ;
    GLint arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:glCombinerParameteriNV",&obj0,&obj1)) goto fail;
    {
        arg1 = (GLenum)(SWIG_As_unsigned_SS_int(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (GLint)(SWIG_As_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        glCombinerParameteriNV(arg1,arg2);
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_glCombinerInputNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    GLenum arg1 ;
    GLenum arg2 ;
    GLenum arg3 ;
    GLenum arg4 ;
    GLenum arg5 ;
    GLenum arg6 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOOO:glCombinerInputNV",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) goto fail;
    {
        arg1 = (GLenum)(SWIG_As_unsigned_SS_int(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (GLenum)(SWIG_As_unsigned_SS_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (GLenum)(SWIG_As_unsigned_SS_int(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        arg4 = (GLenum)(SWIG_As_unsigned_SS_int(obj3)); 
        if (SWIG_arg_fail(4)) SWIG_fail;
    }
    {
        arg5 = (GLenum)(SWIG_As_unsigned_SS_int(obj4)); 
        if (SWIG_arg_fail(5)) SWIG_fail;
    }
    {
        arg6 = (GLenum)(SWIG_As_unsigned_SS_int(obj5)); 
        if (SWIG_arg_fail(6)) SWIG_fail;
    }
    {
        glCombinerInputNV(arg1,arg2,arg3,arg4,arg5,arg6);
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_glCombinerOutputNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    GLenum arg1 ;
    GLenum arg2 ;
    GLenum arg3 ;
    GLenum arg4 ;
    GLenum arg5 ;
    GLenum arg6 ;
    GLenum arg7 ;
    GLboolean arg8 ;
    GLboolean arg9 ;
    GLboolean arg10 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    PyObject * obj9 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOOOOOOO:glCombinerOutputNV",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) goto fail;
    {
        arg1 = (GLenum)(SWIG_As_unsigned_SS_int(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (GLenum)(SWIG_As_unsigned_SS_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (GLenum)(SWIG_As_unsigned_SS_int(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        arg4 = (GLenum)(SWIG_As_unsigned_SS_int(obj3)); 
        if (SWIG_arg_fail(4)) SWIG_fail;
    }
    {
        arg5 = (GLenum)(SWIG_As_unsigned_SS_int(obj4)); 
        if (SWIG_arg_fail(5)) SWIG_fail;
    }
    {
        arg6 = (GLenum)(SWIG_As_unsigned_SS_int(obj5)); 
        if (SWIG_arg_fail(6)) SWIG_fail;
    }
    {
        arg7 = (GLenum)(SWIG_As_unsigned_SS_int(obj6)); 
        if (SWIG_arg_fail(7)) SWIG_fail;
    }
    {
        arg8= (PyObject_IsTrue(obj7)) ? GL_TRUE : GL_FALSE;
    }
    {
        arg9= (PyObject_IsTrue(obj8)) ? GL_TRUE : GL_FALSE;
    }
    {
        arg10= (PyObject_IsTrue(obj9)) ? GL_TRUE : GL_FALSE;
    }
    {
        glCombinerOutputNV(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_glFinalCombinerInputNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    GLenum arg1 ;
    GLenum arg2 ;
    GLenum arg3 ;
    GLenum arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:glFinalCombinerInputNV",&obj0,&obj1,&obj2,&obj3)) goto fail;
    {
        arg1 = (GLenum)(SWIG_As_unsigned_SS_int(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (GLenum)(SWIG_As_unsigned_SS_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (GLenum)(SWIG_As_unsigned_SS_int(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        arg4 = (GLenum)(SWIG_As_unsigned_SS_int(obj3)); 
        if (SWIG_arg_fail(4)) SWIG_fail;
    }
    {
        glFinalCombinerInputNV(arg1,arg2,arg3,arg4);
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_glGetCombinerInputParameterfvNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    GLenum arg1 ;
    GLenum arg2 ;
    GLenum arg3 ;
    GLenum arg4 ;
    GLfloat *arg5 ;
    float temp_5[4] ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    {
        int i; 	arg5 = temp_5; 	for (i = 0; i < 4; i++) arg5[i] = -FLT_MAX; 
    }
    if(!PyArg_ParseTuple(args,(char *)"OOOO:glGetCombinerInputParameterfvNV",&obj0,&obj1,&obj2,&obj3)) goto fail;
    {
        arg1 = (GLenum)(SWIG_As_unsigned_SS_int(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (GLenum)(SWIG_As_unsigned_SS_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (GLenum)(SWIG_As_unsigned_SS_int(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        arg4 = (GLenum)(SWIG_As_unsigned_SS_int(obj3)); 
        if (SWIG_arg_fail(4)) SWIG_fail;
    }
    {
        glGetCombinerInputParameterfvNV(arg1,arg2,arg3,arg4,arg5);
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        int n, dims[2]; 	Py_XDECREF(resultobj); 	 	for (n = 0; n < 4 && arg5[n] != -FLT_MAX; n++); 	switch (n) 	{
            case 0: 		Py_INCREF(Py_None); 		resultobj = Py_None; 		break; 	case 1: 		resultobj = PyFloat_FromDouble(arg5[0]); 		break; 	case 16: 		dims[0] = 4; 		dims[1] = 4; 		resultobj = _PyObject_FromFloatArray(2, dims, arg5, 0); 		break; 	default: 		resultobj = _PyTuple_FromFloatArray(n, arg5); 	
        } 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_glGetCombinerInputParameterivNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    GLenum arg1 ;
    GLenum arg2 ;
    GLenum arg3 ;
    GLenum arg4 ;
    GLint *arg5 ;
    int temp_5[4] ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    {
        int i; 	arg5 = temp_5; 	for (i = 0; i < 4; i++) arg5[i] = INT_MIN; 
    }
    if(!PyArg_ParseTuple(args,(char *)"OOOO:glGetCombinerInputParameterivNV",&obj0,&obj1,&obj2,&obj3)) goto fail;
    {
        arg1 = (GLenum)(SWIG_As_unsigned_SS_int(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (GLenum)(SWIG_As_unsigned_SS_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (GLenum)(SWIG_As_unsigned_SS_int(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        arg4 = (GLenum)(SWIG_As_unsigned_SS_int(obj3)); 
        if (SWIG_arg_fail(4)) SWIG_fail;
    }
    {
        glGetCombinerInputParameterivNV(arg1,arg2,arg3,arg4,arg5);
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        int n, dims[2]; 	Py_XDECREF(resultobj); 	 	for (n = 0; n < 4 && arg5[n] != INT_MIN; n++); 	switch (n) 	{
            case 0: 		Py_INCREF(Py_None); 		resultobj = Py_None; 		break; 	case 1: 		resultobj = PyInt_FromLong(arg5[0]); 		break; 	case 16: 		dims[0] = 4; 		dims[1] = 4; 		resultobj = _PyObject_FromIntArray(2, dims, arg5, 0); 		break; 	default: 		resultobj = _PyTuple_FromIntArray(n, arg5); 	
        } 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_glGetCombinerOutputParameterfvNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    GLenum arg1 ;
    GLenum arg2 ;
    GLenum arg3 ;
    GLfloat *arg4 ;
    float temp_4[4] ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    {
        int i; 	arg4 = temp_4; 	for (i = 0; i < 4; i++) arg4[i] = -FLT_MAX; 
    }
    if(!PyArg_ParseTuple(args,(char *)"OOO:glGetCombinerOutputParameterfvNV",&obj0,&obj1,&obj2)) goto fail;
    {
        arg1 = (GLenum)(SWIG_As_unsigned_SS_int(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (GLenum)(SWIG_As_unsigned_SS_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (GLenum)(SWIG_As_unsigned_SS_int(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        glGetCombinerOutputParameterfvNV(arg1,arg2,arg3,arg4);
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        int n, dims[2]; 	Py_XDECREF(resultobj); 	 	for (n = 0; n < 4 && arg4[n] != -FLT_MAX; n++); 	switch (n) 	{
            case 0: 		Py_INCREF(Py_None); 		resultobj = Py_None; 		break; 	case 1: 		resultobj = PyFloat_FromDouble(arg4[0]); 		break; 	case 16: 		dims[0] = 4; 		dims[1] = 4; 		resultobj = _PyObject_FromFloatArray(2, dims, arg4, 0); 		break; 	default: 		resultobj = _PyTuple_FromFloatArray(n, arg4); 	
        } 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_glGetCombinerOutputParameterivNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    GLenum arg1 ;
    GLenum arg2 ;
    GLenum arg3 ;
    GLint *arg4 ;
    int temp_4[4] ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    {
        int i; 	arg4 = temp_4; 	for (i = 0; i < 4; i++) arg4[i] = INT_MIN; 
    }
    if(!PyArg_ParseTuple(args,(char *)"OOO:glGetCombinerOutputParameterivNV",&obj0,&obj1,&obj2)) goto fail;
    {
        arg1 = (GLenum)(SWIG_As_unsigned_SS_int(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (GLenum)(SWIG_As_unsigned_SS_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        arg3 = (GLenum)(SWIG_As_unsigned_SS_int(obj2)); 
        if (SWIG_arg_fail(3)) SWIG_fail;
    }
    {
        glGetCombinerOutputParameterivNV(arg1,arg2,arg3,arg4);
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        int n, dims[2]; 	Py_XDECREF(resultobj); 	 	for (n = 0; n < 4 && arg4[n] != INT_MIN; n++); 	switch (n) 	{
            case 0: 		Py_INCREF(Py_None); 		resultobj = Py_None; 		break; 	case 1: 		resultobj = PyInt_FromLong(arg4[0]); 		break; 	case 16: 		dims[0] = 4; 		dims[1] = 4; 		resultobj = _PyObject_FromIntArray(2, dims, arg4, 0); 		break; 	default: 		resultobj = _PyTuple_FromIntArray(n, arg4); 	
        } 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_glGetFinalCombinerInputParameterfvNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    GLenum arg1 ;
    GLenum arg2 ;
    GLfloat *arg3 ;
    float temp_3[4] ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    {
        int i; 	arg3 = temp_3; 	for (i = 0; i < 4; i++) arg3[i] = -FLT_MAX; 
    }
    if(!PyArg_ParseTuple(args,(char *)"OO:glGetFinalCombinerInputParameterfvNV",&obj0,&obj1)) goto fail;
    {
        arg1 = (GLenum)(SWIG_As_unsigned_SS_int(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (GLenum)(SWIG_As_unsigned_SS_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        glGetFinalCombinerInputParameterfvNV(arg1,arg2,arg3);
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        int n, dims[2]; 	Py_XDECREF(resultobj); 	 	for (n = 0; n < 4 && arg3[n] != -FLT_MAX; n++); 	switch (n) 	{
            case 0: 		Py_INCREF(Py_None); 		resultobj = Py_None; 		break; 	case 1: 		resultobj = PyFloat_FromDouble(arg3[0]); 		break; 	case 16: 		dims[0] = 4; 		dims[1] = 4; 		resultobj = _PyObject_FromFloatArray(2, dims, arg3, 0); 		break; 	default: 		resultobj = _PyTuple_FromFloatArray(n, arg3); 	
        } 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_glGetFinalCombinerInputParameterivNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    GLenum arg1 ;
    GLenum arg2 ;
    GLint *arg3 ;
    int temp_3[4] ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    {
        int i; 	arg3 = temp_3; 	for (i = 0; i < 4; i++) arg3[i] = INT_MIN; 
    }
    if(!PyArg_ParseTuple(args,(char *)"OO:glGetFinalCombinerInputParameterivNV",&obj0,&obj1)) goto fail;
    {
        arg1 = (GLenum)(SWIG_As_unsigned_SS_int(obj0)); 
        if (SWIG_arg_fail(1)) SWIG_fail;
    }
    {
        arg2 = (GLenum)(SWIG_As_unsigned_SS_int(obj1)); 
        if (SWIG_arg_fail(2)) SWIG_fail;
    }
    {
        glGetFinalCombinerInputParameterivNV(arg1,arg2,arg3);
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        int n, dims[2]; 	Py_XDECREF(resultobj); 	 	for (n = 0; n < 4 && arg3[n] != INT_MIN; n++); 	switch (n) 	{
            case 0: 		Py_INCREF(Py_None); 		resultobj = Py_None; 		break; 	case 1: 		resultobj = PyInt_FromLong(arg3[0]); 		break; 	case 16: 		dims[0] = 4; 		dims[1] = 4; 		resultobj = _PyObject_FromIntArray(2, dims, arg3, 0); 		break; 	default: 		resultobj = _PyTuple_FromIntArray(n, arg3); 	
        } 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_glInitRegisterCombinersNV(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)":glInitRegisterCombinersNV")) goto fail;
    {
        result = (int)glInitRegisterCombinersNV();
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    {
        resultobj = SWIG_From_int((int)(result)); 
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap___info(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PyObject *result;
    
    if(!PyArg_ParseTuple(args,(char *)":__info")) goto fail;
    {
        result = (PyObject *)__info();
        
        if (GLErrOccurred()) {
            return NULL; 
        }
    }
    {
        resultobj= result;
    }
    return resultobj;
    fail:
    return NULL;
}


static PyMethodDef SwigMethods[] = {
	 { (char *)"glCombinerParameterfvNV", _wrap_glCombinerParameterfvNV, METH_VARARGS, NULL},
	 { (char *)"glCombinerParameterivNV", _wrap_glCombinerParameterivNV, METH_VARARGS, NULL},
	 { (char *)"glCombinerParameterfNV", _wrap_glCombinerParameterfNV, METH_VARARGS, NULL},
	 { (char *)"glCombinerParameteriNV", _wrap_glCombinerParameteriNV, METH_VARARGS, NULL},
	 { (char *)"glCombinerInputNV", _wrap_glCombinerInputNV, METH_VARARGS, NULL},
	 { (char *)"glCombinerOutputNV", _wrap_glCombinerOutputNV, METH_VARARGS, NULL},
	 { (char *)"glFinalCombinerInputNV", _wrap_glFinalCombinerInputNV, METH_VARARGS, NULL},
	 { (char *)"glGetCombinerInputParameterfvNV", _wrap_glGetCombinerInputParameterfvNV, METH_VARARGS, NULL},
	 { (char *)"glGetCombinerInputParameterivNV", _wrap_glGetCombinerInputParameterivNV, METH_VARARGS, NULL},
	 { (char *)"glGetCombinerOutputParameterfvNV", _wrap_glGetCombinerOutputParameterfvNV, METH_VARARGS, NULL},
	 { (char *)"glGetCombinerOutputParameterivNV", _wrap_glGetCombinerOutputParameterivNV, METH_VARARGS, NULL},
	 { (char *)"glGetFinalCombinerInputParameterfvNV", _wrap_glGetFinalCombinerInputParameterfvNV, METH_VARARGS, NULL},
	 { (char *)"glGetFinalCombinerInputParameterivNV", _wrap_glGetFinalCombinerInputParameterivNV, METH_VARARGS, NULL},
	 { (char *)"glInitRegisterCombinersNV", _wrap_glInitRegisterCombinersNV, METH_VARARGS, NULL},
	 { (char *)"__info", _wrap___info, METH_VARARGS, NULL},
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_GLsizei[] = {{"_p_GLsizei", 0, "int *|GLsizei *", 0, 0, 0, 0},{"_p_GLint", 0, 0, 0, 0, 0, 0},{"_p_GLsizei", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLshort[] = {{"_p_GLshort", 0, "short *|GLshort *", 0, 0, 0, 0},{"_p_GLshort", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLboolean[] = {{"_p_GLboolean", 0, "unsigned char *|GLboolean *", 0, 0, 0, 0},{"_p_GLboolean", 0, 0, 0, 0, 0, 0},{"_p_GLubyte", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__size_t[] = {{"_size_t", 0, "size_t", 0, 0, 0, 0},{"_size_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLushort[] = {{"_p_GLushort", 0, "unsigned short *|GLushort *", 0, 0, 0, 0},{"_p_GLushort", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLenum[] = {{"_p_GLenum", 0, "unsigned int *|GLenum *", 0, 0, 0, 0},{"_p_GLuint", 0, 0, 0, 0, 0, 0},{"_p_GLenum", 0, 0, 0, 0, 0, 0},{"_p_GLbitfield", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLvoid[] = {{"_p_GLvoid", 0, "void *|GLvoid *", 0, 0, 0, 0},{"_p_GLvoid", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLint[] = {{"_p_GLint", 0, "int *|GLint *", 0, 0, 0, 0},{"_p_GLint", 0, 0, 0, 0, 0, 0},{"_p_GLsizei", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_char[] = {{"_p_char", 0, "char *", 0, 0, 0, 0},{"_p_char", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLclampd[] = {{"_p_GLclampd", 0, "double *|GLclampd *", 0, 0, 0, 0},{"_p_GLclampd", 0, 0, 0, 0, 0, 0},{"_p_GLdouble", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLclampf[] = {{"_p_GLclampf", 0, "float *|GLclampf *", 0, 0, 0, 0},{"_p_GLfloat", 0, 0, 0, 0, 0, 0},{"_p_GLclampf", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLuint[] = {{"_p_GLuint", 0, "unsigned int *|GLuint *", 0, 0, 0, 0},{"_p_GLuint", 0, 0, 0, 0, 0, 0},{"_p_GLenum", 0, 0, 0, 0, 0, 0},{"_p_GLbitfield", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__ptrdiff_t[] = {{"_ptrdiff_t", 0, "ptrdiff_t", 0, 0, 0, 0},{"_ptrdiff_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLbyte[] = {{"_p_GLbyte", 0, "signed char *|GLbyte *", 0, 0, 0, 0},{"_p_GLbyte", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLbitfield[] = {{"_p_GLbitfield", 0, "unsigned int *|GLbitfield *", 0, 0, 0, 0},{"_p_GLuint", 0, 0, 0, 0, 0, 0},{"_p_GLbitfield", 0, 0, 0, 0, 0, 0},{"_p_GLenum", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLfloat[] = {{"_p_GLfloat", 0, "float *|GLfloat *", 0, 0, 0, 0},{"_p_GLfloat", 0, 0, 0, 0, 0, 0},{"_p_GLclampf", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLubyte[] = {{"_p_GLubyte", 0, "unsigned char *|GLubyte *", 0, 0, 0, 0},{"_p_GLboolean", 0, 0, 0, 0, 0, 0},{"_p_GLubyte", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLdouble[] = {{"_p_GLdouble", 0, "double *|GLdouble *", 0, 0, 0, 0},{"_p_GLclampd", 0, 0, 0, 0, 0, 0},{"_p_GLdouble", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_GLsizei, 
_swigt__p_GLshort, 
_swigt__p_GLboolean, 
_swigt__size_t, 
_swigt__p_GLushort, 
_swigt__p_GLenum, 
_swigt__p_GLvoid, 
_swigt__p_GLint, 
_swigt__p_char, 
_swigt__p_GLclampd, 
_swigt__p_GLclampf, 
_swigt__p_GLuint, 
_swigt__ptrdiff_t, 
_swigt__p_GLbyte, 
_swigt__p_GLbitfield, 
_swigt__p_GLfloat, 
_swigt__p_GLubyte, 
_swigt__p_GLdouble, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{ SWIG_PY_POINTER, (char*)"__version__", 0, 0, (void *)"1.20.6.1", &SWIGTYPE_p_char},
{ SWIG_PY_POINTER, (char*)"__date__", 0, 0, (void *)"2004/11/14 23:19:04", &SWIGTYPE_p_char},
{ SWIG_PY_POINTER, (char*)"__author__", 0, 0, (void *)"Tarn Weisner Burton <twburton@users.sourceforge.net>", &SWIGTYPE_p_char},
{ SWIG_PY_POINTER, (char*)"__doc__", 0, 0, (void *)"http://oss.sgi.com/projects/ogl-sample/registry/NV/register_combiners.txt", &SWIGTYPE_p_char},
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif


#ifdef SWIG_LINK_RUNTIME
#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  if defined(_MSC_VER) || defined(__GNUC__)
#    define SWIGIMPORT(a) extern a
#  else
#    if defined(__BORLANDC__)
#      define SWIGIMPORT(a) a _export
#    else
#      define SWIGIMPORT(a) a
#    endif
#  endif
#else
#  define SWIGIMPORT(a) a
#endif
#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void *) SWIG_ReturnGlobalTypeList(void *);
#endif

#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) SWIG_init(void) {
    static PyObject *SWIG_globals = 0; 
    static int       typeinit = 0;
    PyObject *m, *d;
    int       i;
    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
    
    /* Fix SwigMethods to carry the callback ptrs when needed */
    SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_types_initial);
    
    m = Py_InitModule((char *) SWIG_name, SwigMethods);
    d = PyModule_GetDict(m);
    
    if (!typeinit) {
#ifdef SWIG_LINK_RUNTIME
        swig_type_list_handle = (swig_type_info **) SWIG_ReturnGlobalTypeList(swig_type_list_handle);
#else
#  ifndef SWIG_STATIC_RUNTIME
        SWIG_Python_LookupTypePointer(&swig_type_list_handle);
#  endif
#endif
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        typeinit = 1;
    }
    SWIG_InstallConstants(d,swig_const_table);
    
    PyDict_SetItemString(d,"__version__", SWIG_FromCharPtr("1.20.6.1"));
    PyDict_SetItemString(d,"__date__", SWIG_FromCharPtr("2004/11/14 23:19:04"));
    {
        PyDict_SetItemString(d,"__api_version__", SWIG_From_int((int)(260))); 
    }
    PyDict_SetItemString(d,"__author__", SWIG_FromCharPtr("Tarn Weisner Burton <twburton@users.sourceforge.net>"));
    PyDict_SetItemString(d,"__doc__", SWIG_FromCharPtr("http://oss.sgi.com/projects/ogl-sample/registry/NV/register_combiners.txt"));
    
#ifdef NUMERIC
    PyArray_API = NULL;
    import_array();
    init_util();
    PyErr_Clear();
#endif
    
    
    {
        PyObject *util = PyImport_ImportModule("OpenGL.GL._GL__init__");
        if (util)
        {
            PyObject *api_object = PyDict_GetItemString(PyModule_GetDict(util), "_util_API");
            if (PyCObject_Check(api_object)) _util_API = (util_API*)PyCObject_AsVoidPtr(api_object);
        }
    }
    
    {
        PyDict_SetItemString(d,"GL_ALL_COMPLETED_NV", SWIG_From_int((int)(0x84F2))); 
    }
    {
        PyDict_SetItemString(d,"GL_REGISTER_COMBINERS_NV", SWIG_From_int((int)(0x8522))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER0_NV", SWIG_From_int((int)(0x8550))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER1_NV", SWIG_From_int((int)(0x8551))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER2_NV", SWIG_From_int((int)(0x8552))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER3_NV", SWIG_From_int((int)(0x8553))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER4_NV", SWIG_From_int((int)(0x8554))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER5_NV", SWIG_From_int((int)(0x8555))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER6_NV", SWIG_From_int((int)(0x8556))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER7_NV", SWIG_From_int((int)(0x8557))); 
    }
    {
        PyDict_SetItemString(d,"GL_VARIABLE_A_NV", SWIG_From_int((int)(0x8523))); 
    }
    {
        PyDict_SetItemString(d,"GL_VARIABLE_B_NV", SWIG_From_int((int)(0x8524))); 
    }
    {
        PyDict_SetItemString(d,"GL_VARIABLE_C_NV", SWIG_From_int((int)(0x8525))); 
    }
    {
        PyDict_SetItemString(d,"GL_VARIABLE_D_NV", SWIG_From_int((int)(0x8526))); 
    }
    {
        PyDict_SetItemString(d,"GL_VARIABLE_E_NV", SWIG_From_int((int)(0x8527))); 
    }
    {
        PyDict_SetItemString(d,"GL_VARIABLE_F_NV", SWIG_From_int((int)(0x8528))); 
    }
    {
        PyDict_SetItemString(d,"GL_VARIABLE_G_NV", SWIG_From_int((int)(0x8529))); 
    }
    {
        PyDict_SetItemString(d,"GL_CONSTANT_COLOR0_NV", SWIG_From_int((int)(0x852A))); 
    }
    {
        PyDict_SetItemString(d,"GL_CONSTANT_COLOR1_NV", SWIG_From_int((int)(0x852B))); 
    }
    {
        PyDict_SetItemString(d,"GL_PRIMARY_COLOR_NV", SWIG_From_int((int)(0x852C))); 
    }
    {
        PyDict_SetItemString(d,"GL_SECONDARY_COLOR_NV", SWIG_From_int((int)(0x852D))); 
    }
    {
        PyDict_SetItemString(d,"GL_SPARE0_NV", SWIG_From_int((int)(0x852E))); 
    }
    {
        PyDict_SetItemString(d,"GL_SPARE1_NV", SWIG_From_int((int)(0x852F))); 
    }
    {
        PyDict_SetItemString(d,"GL_UNSIGNED_IDENTITY_NV", SWIG_From_int((int)(0x8536))); 
    }
    {
        PyDict_SetItemString(d,"GL_UNSIGNED_INVERT_NV", SWIG_From_int((int)(0x8537))); 
    }
    {
        PyDict_SetItemString(d,"GL_EXPAND_NORMAL_NV", SWIG_From_int((int)(0x8538))); 
    }
    {
        PyDict_SetItemString(d,"GL_EXPAND_NEGATE_NV", SWIG_From_int((int)(0x8539))); 
    }
    {
        PyDict_SetItemString(d,"GL_HALF_BIAS_NORMAL_NV", SWIG_From_int((int)(0x853A))); 
    }
    {
        PyDict_SetItemString(d,"GL_HALF_BIAS_NEGATE_NV", SWIG_From_int((int)(0x853B))); 
    }
    {
        PyDict_SetItemString(d,"GL_SIGNED_IDENTITY_NV", SWIG_From_int((int)(0x853C))); 
    }
    {
        PyDict_SetItemString(d,"GL_SIGNED_NEGATE_NV", SWIG_From_int((int)(0x853D))); 
    }
    {
        PyDict_SetItemString(d,"GL_E_TIMES_F_NV", SWIG_From_int((int)(0x8531))); 
    }
    {
        PyDict_SetItemString(d,"GL_SPARE0_PLUS_SECONDARY_COLOR_NV", SWIG_From_int((int)(0x8532))); 
    }
    {
        PyDict_SetItemString(d,"GL_SCALE_BY_TWO_NV", SWIG_From_int((int)(0x853E))); 
    }
    {
        PyDict_SetItemString(d,"GL_SCALE_BY_FOUR_NV", SWIG_From_int((int)(0x853F))); 
    }
    {
        PyDict_SetItemString(d,"GL_SCALE_BY_ONE_HALF_NV", SWIG_From_int((int)(0x8540))); 
    }
    {
        PyDict_SetItemString(d,"GL_BIAS_BY_NEGATIVE_ONE_HALF_NV", SWIG_From_int((int)(0x8541))); 
    }
    {
        PyDict_SetItemString(d,"GL_DISCARD_NV", SWIG_From_int((int)(0x8530))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER_INPUT_NV", SWIG_From_int((int)(0x8542))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER_MAPPING_NV", SWIG_From_int((int)(0x8543))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER_COMPONENT_USAGE_NV", SWIG_From_int((int)(0x8544))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER_AB_DOT_PRODUCT_NV", SWIG_From_int((int)(0x8545))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER_CD_DOT_PRODUCT_NV", SWIG_From_int((int)(0x8546))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER_MUX_SUM_NV", SWIG_From_int((int)(0x8547))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER_SCALE_NV", SWIG_From_int((int)(0x8548))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER_BIAS_NV", SWIG_From_int((int)(0x8549))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER_AB_OUTPUT_NV", SWIG_From_int((int)(0x854A))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER_CD_OUTPUT_NV", SWIG_From_int((int)(0x854B))); 
    }
    {
        PyDict_SetItemString(d,"GL_COMBINER_SUM_OUTPUT_NV", SWIG_From_int((int)(0x854C))); 
    }
    {
        PyDict_SetItemString(d,"GL_NUM_GENERAL_COMBINERS_NV", SWIG_From_int((int)(0x854E))); 
    }
    {
        PyDict_SetItemString(d,"GL_COLOR_SUM_CLAMP_NV", SWIG_From_int((int)(0x854F))); 
    }
    {
        PyDict_SetItemString(d,"GL_MAX_GENERAL_COMBINERS_NV", SWIG_From_int((int)(0x854D))); 
    }
}

